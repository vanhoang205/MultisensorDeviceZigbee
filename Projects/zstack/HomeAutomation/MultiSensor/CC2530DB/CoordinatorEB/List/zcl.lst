###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               21/Jul/2020  15:36:26
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f C:\Users\TS-577\AppData\Local\Temp\EW4D0B.tmp
#        ("C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Components\stack\zcl\zcl.c" -D
#        xBDB_REPORTING -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE
#        -D ZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D
#        xMT_ZDO_FUNC -D xMT_APP_CNF_FUNC -D MULTICAST_ENABLED=FALSE -D
#        ZCL_READ -D xZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D
#        ZCL_GROUPS -D ZCL_REPORT -D ZCL_REPORTING_DEVICE -D
#        ZCL_TEMPERATURE_MEASUREMENT -lC "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00002000 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000) -f
#        "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\Source\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\Source\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  Japanese_JPN.932
#    List file          =  
#        C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\CoordinatorEB\List\zcl.lst
#    Object file        =  
#        C:\Users\TS-577\Desktop\Zigbee
#        workspace\MultiSensorDevice\Projects\zstack\HomeAutomation\MultiSensor\CC2530DB\CoordinatorEB\Obj\zcl.r51
#
###############################################################################

C:\Users\TS-577\Desktop\Zigbee workspace\MultiSensorDevice\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2015-09-09 11:51:49 -0700 (Wed, 09 Sep 2015) $
      4            Revision:       $Revision: 44489 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          #include "APS.h"
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52             
     53          #ifdef BDB_REPORTING
     54            #include "bdb_Reporting.h"
     55          #endif
     56          #include "bdb_interface.h"
     57          
     58          #include "zcl_green_power.h"
     59          
     60             
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          /*** Frame Control ***/
     65          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     66          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     67          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     68          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     69          
     70          /*** Attribute Access Control ***/
     71          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     72          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     73          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     74          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     75          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     76          #define zcl_AccessClient( a )         ( (a) & ACCESS_CLIENT )
     77          
     78          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     79          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     80          
     81          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     82                                                  (zclHdr).fc.manuSpecific == 0          && \
     83                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     84          
     85          // Commands that have corresponding responses (ZCL_CMD_WRITE_NO_RSP, does not have response, but must not send default response)
     86          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     87                                                  (cmd) == ZCL_CMD_WRITE                  || \
     88                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     89                                                  (cmd) == ZCL_CMD_WRITE_NO_RSP           || \
     90                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     91                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     92                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     93                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     94                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     95                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     96                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     97          #define  ZCL_VALID_MIN_HEADER_LEN  3
     98          
     99          
    100          /*********************************************************************
    101           * CONSTANTS
    102           */
    103          
    104          /*********************************************************************
    105           * TYPEDEFS
    106           */
    107          typedef struct zclLibPlugin
    108          {
    109            struct zclLibPlugin *next;
    110            uint16              startClusterID;    // starting cluster ID
    111            uint16              endClusterID;      // ending cluster ID
    112            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    113          } zclLibPlugin_t;
    114          
    115          // Command record list
    116          typedef struct zclCmdRecsList
    117          {
    118            struct zclCmdRecsList *pNext;
    119            uint8                 endpoint;
    120            uint8                 numCommands;
    121            CONST zclCommandRec_t *pCmdRecs;
    122          } zclCmdRecsList_t;
    123          
    124          
    125          // Cluster option list item
    126          typedef struct zclClusterOptionList
    127          {
    128            struct zclClusterOptionList *next;
    129            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    130            uint8                       numOptions; // Number of the following records
    131            zclOptionRec_t              *options;   // option records
    132          } zclClusterOptionList;
    133          
    134          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    135          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    136          
    137          typedef struct
    138          {
    139            zclParseInProfileCmd_t   pfnParseInProfile;
    140            zclProcessInProfileCmd_t pfnProcessInProfile;
    141          } zclCmdItems_t;
    142          
    143          
    144          // List record for external handler for unhandled ZCL Foundation commands/rsps
    145          typedef struct zclExternalFoundationHandlerList
    146          {
    147              struct zclExternalFoundationHandlerList *next;
    148              uint8 zcl_ExternalTaskID;
    149              uint8 zcl_ExternalEndPoint;
    150          } zclExternalFoundationHandlerList;
    151          
    152          
    153          /*********************************************************************
    154           * GLOBAL VARIABLES
    155           */
    156          
    157          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    158            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    159          #endif
    160          
    161          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    162          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    163          
    164          // ZCL Sequence number
    165          //uint8 zcl_SeqNum = 0x00;  //Not longer used, refer to bdb_getZCLFrameCounter() in bdb_interface.h

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    166          uint8 zcl_InSeqNum = 0x00;
   \                     zcl_InSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    167          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    168          uint8 zcl_radius = AF_DEFAULT_RADIUS;
   \                     zcl_radius:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_radius>`
   \   000001                REQUIRE __INIT_XDATA_I
    169          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    170          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    171          
    172          /*********************************************************************
    173           * EXTERNAL VARIABLES
    174           */
    175          
    176          /*********************************************************************
    177           * EXTERNAL FUNCTIONS
    178           */
    179          
    180          /*********************************************************************
    181           * LOCAL VARIABLES
    182           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          
    185          #if defined ( ZCL_DISCOVER )
    186            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    187          #endif
    188          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    189          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    191          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          static zclConfigReportRecsList *configReportRecsList = (zclConfigReportRecsList *)NULL;
   \                     configReportRecsList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    193          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    194          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    195          
    196          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    197          static zclExternalFoundationHandlerList *externalEndPointHandlerList = (zclExternalFoundationHandlerList *)NULL;
   \                     externalEndPointHandlerList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    198          #endif
    199          
    200          /*********************************************************************
    201           * LOCAL FUNCTIONS
    202           */
    203          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    204          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    205          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    206          
    207          #if !defined ( ZCL_STANDALONE )
    208          static uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId );
    209          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg );
    210          #endif // !defined ( ZCL_STANDALONE )
    211          
    212          #if defined ( ZCL_DISCOVER )
    213            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    214          #endif
    215          
    216          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    217          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    218          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    219          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    220          
    221          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    222          
    223          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    224          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    225          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    226          #endif // ZCL_READ || ZCL_WRITE
    227          
    228          #ifdef ZCL_READ
    229          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    230          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    231          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    232                                                   uint8 *pAttrData, uint16 *pDataLen );
    233          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    234          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    235          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    236          #endif // ZCL_READ
    237          
    238          #ifdef ZCL_WRITE
    239          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    240                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    241          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    242                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    243          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    244          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    245          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    246          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    247          #endif // ZCL_WRITE
    248          
    249          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    250          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    251          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    252          #endif
    253          
    254          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    255          
    256          #ifdef ZCL_DISCOVER
    257          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    258          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    259          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    260          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    261          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    262          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    263          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    264          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    265          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    266          #endif // ZCL_DISCOVER
    267          
    268          /*********************************************************************
    269           * Parse Profile Command Function Table
    270           */
    271          

   \                                 In  segment CODE_C, align 1
    272          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW `??zclParseInReadCmd::?relay`
   \   000002   ....         DW `??zclProcessInReadCmd::?relay`
   \   000004   ....         DW `??zclParseInReadRspCmd::?relay`
   \   000006   ....         DW `??zcl_HandleExternal::?relay`
   \   000008   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000A   ....         DW `??zclProcessInWriteCmd::?relay`
   \   00000C   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000E   ....         DW `??zclProcessInWriteUndividedCmd::?relay`
   \   000010   ....         DW `??zclParseInWriteRspCmd::?relay`
   \   000012   ....         DW `??zcl_HandleExternal::?relay`
   \   000014   ....         DW `??zclParseInWriteCmd::?relay`
   \   000016   ....         DW `??zclProcessInWriteCmd::?relay`
   \   000018   ....         DW `??zclParseInConfigReportCmd::?relay`
   \   00001A   ....         DW `??zcl_HandleExternal::?relay`
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H
   \   000020   ....         DW `??zclParseInReadReportCfgCmd::?relay`
   \   000022   ....         DW `??zcl_HandleExternal::?relay`
   \   000024   0000         DW 0H
   \   000026   0000         DW 0H
   \   000028   0000         DW 0H
   \   00002A   0000         DW 0H
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    273          {
    274          #ifdef ZCL_READ
    275            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    276            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    277          #else
    278            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    279            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    280          #endif // ZCL_READ
    281          
    282          #ifdef ZCL_WRITE
    283            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    284            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    285            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    286            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    287          #else
    288            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    289            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    290            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    291            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    292          #endif // ZCL_WRITE
    293          
    294          #ifdef ZCL_REPORTING_DEVICE
    295              /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    296          #else
    297              /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    298          #endif
    299          
    300          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    301              /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    302          #else
    303              /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    304          #endif
    305          
    306          #ifdef ZCL_REPORTING_DEVICE
    307              /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    308          #else
    309              /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    310          #endif
    311          
    312          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    313              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    314          #else
    315              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    316          #endif
    317          
    318          #ifdef ZCL_REPORT_DESTINATION_DEVICE
    319              /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    320          #else
    321              /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    322          #endif
    323          
    324            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    325          
    326          #ifdef ZCL_DISCOVER
    327            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    328            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    329            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    330            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    331            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    332            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    333            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    334            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    335            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    336            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    337            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    338          #else
    339            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    340            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    341            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    342            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    343            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    344            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    345            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    346            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    347            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    348            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    349            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    350          #endif // ZCL_DISCOVER
    351          };
    352          
    353          /*********************************************************************
    354           * PUBLIC FUNCTIONS
    355           *********************************************************************/
    356          
    357          #if !defined ( ZCL_STANDALONE )
    358          /*********************************************************************
    359           * @fn          zcl_Init
    360           *
    361           * @brief       Initialization function for the zcl layer.
    362           *
    363           * @param       task_id - ZCL task id
    364           *
    365           * @return      none
    366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    367          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    368          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    369            zcl_TaskID = task_id;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#zcl_TaskID
   \   000008   F0           MOVX      @DPTR,A
    370          }
   \   000009   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    371          #endif
    372          
    373          #if !defined ( ZCL_STANDALONE )
    374          /*********************************************************************
    375           * @fn          zcl_event_loop
    376           *
    377           * @brief       Event Loop Processor for zcl.
    378           *
    379           * @param       task_id - task id
    380           * @param       events - event bitmap
    381           *
    382           * @return      unprocessed events
    383           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    384          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    385          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 74
   \   000005   74B6         MOV       A,#-0x4a
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
    386            uint8 *msgPtr;
    387          
    388            (void)task_id;  // Intentionally unreferenced parameter
    389          
    390            if ( events & SYS_EVENT_MSG )
   \   00000E   EB           MOV       A,R3
   \   00000F   5480         ANL       A,#0x80
   \   000011   604E         JZ        ??zcl_event_loop_0
    391            {
    392              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000013                ; Setup parameters for call to function osal_msg_receive
   \   000013   800E         SJMP      ??zcl_event_loop_1
    393              while ( msgPtr != NULL )
    394              {
    395                uint8 dealloc = TRUE;
    396          
    397                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    398                {
    399                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000015                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000015   EE           MOV       A,R6
   \   000016   FA           MOV       R2,A
   \   000017   EF           MOV       A,R7
   \   000018   FB           MOV       R3,A
   \   000019   12....       LCALL     `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
    400                }
    401                else
    402                {
    403                  uint8 taskID;
    404                  taskID = zcl_getExternalFoundationHandler( (afIncomingMSGPacket_t *)msgPtr );
    405          
    406                  if ( taskID != TASK_NO_TASK )
    407                  {
    408                    // send it to another task to process.
    409                    osal_msg_send( taskID, msgPtr );
    410                    dealloc = FALSE;
    411                  }
    412                }
    413          
    414                // Release the memory
    415                if ( dealloc )
    416                {
    417                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   00001C                ; Setup parameters for call to function osal_msg_deallocate
   \   00001C   EE           MOV       A,R6
   \   00001D   FA           MOV       R2,A
   \   00001E   EF           MOV       A,R7
   \   00001F   FB           MOV       R3,A
   \   000020   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    418                }
    419          
    420                // Next
    421                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   000023                ; Setup parameters for call to function osal_msg_receive
   \   000023   90....       MOV       DPTR,#zcl_TaskID
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F9           MOV       R1,A
   \   000028   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   00002B   8A..         MOV       ?V2,R2
   \   00002D   8B..         MOV       ?V3,R3
   \   00002F   AE..         MOV       R6,?V2
   \   000031   AF..         MOV       R7,?V3
   \   000033   EE           MOV       A,R6
   \   000034   4F           ORL       A,R7
   \   000035   6020         JZ        ??zcl_event_loop_4
   \   000037   8E82         MOV       DPL,R6
   \   000039   8F83         MOV       DPH,R7
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   641A         XRL       A,#0x1a
   \   00003E   60D5         JZ        ??zcl_event_loop_2
   \   000040                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000040   EE           MOV       A,R6
   \   000041   FA           MOV       R2,A
   \   000042   EF           MOV       A,R7
   \   000043   FB           MOV       R3,A
   \   000044   12....       LCALL     `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000047   E9           MOV       A,R1
   \   000048   F9           MOV       R1,A
   \   000049   74FF         MOV       A,#-0x1
   \   00004B   69           XRL       A,R1
   \   00004C   60CE         JZ        ??zcl_event_loop_3
   \   00004E                ; Setup parameters for call to function osal_msg_send
   \   00004E   EE           MOV       A,R6
   \   00004F   FA           MOV       R2,A
   \   000050   EF           MOV       A,R7
   \   000051   FB           MOV       R3,A
   \   000052   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000055   80CC         SJMP      ??zcl_event_loop_1
    422              }
    423          
    424              // return unprocessed events
    425              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000057   AA..         MOV       R2,?V0
   \   000059   E5..         MOV       A,?V1
   \   00005B   6480         XRL       A,#0x80
   \   00005D   FB           MOV       R3,A
   \   00005E   02....       LJMP      ??zcl_event_loop_5 & 0xFFFF
    426            }
    427          
    428          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    429            if ( events & ZCL_DATABUF_SEND )
   \                     ??zcl_event_loop_0:
   \   000061   EA           MOV       A,R2
   \   000062   5420         ANL       A,#0x20
   \   000064   7003         JNZ       $+5
   \   000066   02....       LJMP      ??zcl_event_loop_6 & 0xFFFF
    430            {
    431              gpNotificationMsg_t *gpNotification = NULL;
    432              gpCmdPayloadMsg_t *pCmdPayloadMsgCurr = NULL;
    433              gpd_ID_t gpd_ID;
    434              uint8 *pgpdid;
    435              uint8 entry[PROXY_TBL_ENTRY_LEN];
    436              uint8 appId;
    437              uint8 nwkSeqNum;
    438              uint8 apsSecNum;
    439              uint16 nwkAddr;
    440              
    441              gpNotification = gp_GetHeadNotificationMsg( );
   \   000069                ; Setup parameters for call to function gp_GetHeadNotificationMsg
   \   000069   12....       LCALL     `??gp_GetHeadNotificationMsg::?relay`; Banked call to: gp_GetHeadNotificationMsg
   \   00006C   8A..         MOV       ?V2,R2
   \   00006E   8B..         MOV       ?V3,R3
    442              
    443              if ( gpNotification == NULL )
   \   000070   EA           MOV       A,R2
   \   000071   4B           ORL       A,R3
   \   000072   7003         JNZ       $+5
   \   000074   02....       LJMP      ??zcl_event_loop_6 & 0xFFFF
    444              {
    445                return 0;
    446              }
    447              
    448              pCmdPayloadMsgCurr = ( gpCmdPayloadMsg_t* ) gpNotification->pMsg ;
   \   000077   EA           MOV       A,R2
   \   000078   240D         ADD       A,#0xd
   \   00007A   F582         MOV       DPL,A
   \   00007C   E4           CLR       A
   \   00007D   35..         ADDC      A,?V3
   \   00007F   F583         MOV       DPH,A
   \   000081   12....       LCALL     ??Subroutine183_0 & 0xFFFF
    449              appId = PROXY_TBL_GET_APPLICTION_ID((uint16)*pCmdPayloadMsgCurr->pMsg);
   \                     ??CrossCallReturnLabel_394:
   \   000084   EE           MOV       A,R6
   \   000085   2402         ADD       A,#0x2
   \   000087   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   00008A   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   5407         ANL       A,#0x7
   \   000090   F8           MOV       R0,A
    450              
    451              // To save the NIB nwk sequense number and use the GP alias nwk sequence number
    452              // for the GP notification
    453              nwkSeqNum = _NIB.SequenceNum;
   \   000091   90....       MOV       DPTR,#_NIB
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F5..         MOV       ?V7,A
    454              _NIB.SequenceNum = pCmdPayloadMsgCurr->secNum;
   \   000097   8E82         MOV       DPL,R6
   \   000099   8F83         MOV       DPH,R7
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   90....       MOV       DPTR,#_NIB
   \   00009F   F0           MOVX      @DPTR,A
    455              
    456              // To save the NIB nwk address and use the GP alias nwk address for the GP notification
    457              nwkAddr = _NIB.nwkDevAddress;
   \   0000A0   90....       MOV       DPTR,#_NIB + 20
   \   0000A3   12....       LCALL     ?Subroutine92 & 0xFFFF
    458              
    459              if( appId == GP_OPT_APP_ID_GPD )
   \                     ??CrossCallReturnLabel_155:
   \   0000A6   7029         JNZ       ??zcl_event_loop_7
    460              {
    461                pgpdid = pCmdPayloadMsgCurr->pMsg + sizeof( uint16 );
   \   0000A8   85..82       MOV       DPL,?V0
   \   0000AB   85..83       MOV       DPH,?V1
   \   0000AE   E0           MOVX      A,@DPTR
   \   0000AF   2402         ADD       A,#0x2
   \   0000B1   12....       LCALL     ?Subroutine70 & 0xFFFF
    462                
    463                osal_memcpy( &_NIB.nwkDevAddress, pgpdid, sizeof(uint16) );
   \                     ??CrossCallReturnLabel_113:
   \   0000B4   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000B7   12....       LCALL     ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   0000BA   12....       LCALL     ?DEALLOC_XSTACK8
    464                gpd_ID.AppID = GP_OPT_APP_ID_GPD;
   \   0000BD   85..82       MOV       DPL,?XSP + 0
   \   0000C0   85..83       MOV       DPH,?XSP + 1
   \   0000C3   E4           CLR       A
   \   0000C4   F0           MOVX      @DPTR,A
    465                osal_memcpy( &gpd_ID.GPDId.SrcID, pgpdid, sizeof( uint32 ) );
   \   0000C5                ; Setup parameters for call to function osal_memcpy
   \   0000C5   78..         MOV       R0,#?V4
   \   0000C7   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000CA   7C04         MOV       R4,#0x4
   \   0000CC   7D00         MOV       R5,#0x0
   \   0000CE   EC           MOV       A,R4
   \   0000CF   8044         SJMP      ??zcl_event_loop_8
    466              }
    467              else if( appId == GP_OPT_APP_ID_IEEE )
   \                     ??zcl_event_loop_7:
   \   0000D1   7402         MOV       A,#0x2
   \   0000D3   68           XRL       A,R0
   \   0000D4   704C         JNZ       ??zcl_event_loop_9
    468              {
    469                pgpdid = pCmdPayloadMsgCurr->pMsg + Z_EXTADDR_LEN;
    470                
    471                osal_revmemcpy( &_NIB.nwkDevAddress,(pCmdPayloadMsgCurr->pMsg + Z_EXTADDR_LEN), sizeof(uint16) );
   \   0000D6                ; Setup parameters for call to function osal_revmemcpy
   \   0000D6   85..82       MOV       DPL,?V0
   \   0000D9   85..83       MOV       DPH,?V1
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   2408         ADD       A,#0x8
   \   0000DF   12....       LCALL     ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0000E2   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000E5   7C02         MOV       R4,#0x2
   \   0000E7   7D00         MOV       R5,#0x0
   \   0000E9   7A..         MOV       R2,#(_NIB + 20) & 0xff
   \   0000EB   7B..         MOV       R3,#((_NIB + 20) >> 8) & 0xff
   \   0000ED   12....       LCALL     `??osal_revmemcpy::?relay`; Banked call to: osal_revmemcpy
   \   0000F0   7403         MOV       A,#0x3
   \   0000F2   12....       LCALL     ?DEALLOC_XSTACK8
    472                
    473                gpd_ID.AppID = GP_OPT_APP_ID_IEEE;
   \   0000F5   85..82       MOV       DPL,?XSP + 0
   \   0000F8   85..83       MOV       DPH,?XSP + 1
   \   0000FB   7402         MOV       A,#0x2
   \   0000FD   12....       LCALL     ?Subroutine31 & 0xFFFF
    474          
    475                pgpdid = pCmdPayloadMsgCurr->pMsg + sizeof( uint16 );
    476                osal_memcpy( gpd_ID.GPDId.GPDExtAddr, pgpdid, Z_EXTADDR_LEN );
    477              }
   \                     ??CrossCallReturnLabel_33:
   \   000100   2402         ADD       A,#0x2
   \   000102   F5..         MOV       ?V4,A
   \   000104   A3           INC       DPTR
   \   000105   E0           MOVX      A,@DPTR
   \   000106   3400         ADDC      A,#0x0
   \   000108   F5..         MOV       ?V5,A
   \   00010A   78..         MOV       R0,#?V4
   \   00010C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00010F   7C08         MOV       R4,#0x8
   \   000111   7D00         MOV       R5,#0x0
   \   000113   7404         MOV       A,#0x4
   \                     ??zcl_event_loop_8:
   \   000115   12....       LCALL     ?XSTACK_DISP0_8
   \   000118   AA82         MOV       R2,DPL
   \   00011A   AB83         MOV       R3,DPH
   \   00011C   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   00011F   12....       LCALL     ?DEALLOC_XSTACK8
    478              
    479              gp_getProxyTableByGpId(&gpd_ID, entry, NULL);
   \                     ??zcl_event_loop_9:
   \   000122                ; Setup parameters for call to function gp_getProxyTableByGpId
   \   000122   E4           CLR       A
   \   000123   F5..         MOV       ?V4,A
   \   000125   F5..         MOV       ?V5,A
   \   000127   78..         MOV       R0,#?V4
   \   000129   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00012C   740B         MOV       A,#0xb
   \   00012E   12....       LCALL     ?XSTACK_DISP102_8
   \   000131   7402         MOV       A,#0x2
   \   000133   12....       LCALL     ?XSTACK_DISP101_8
   \   000136   12....       LCALL     `??gp_getProxyTableByGpId::?relay`; Banked call to: gp_getProxyTableByGpId
   \   000139   7402         MOV       A,#0x2
   \   00013B   12....       LCALL     ?DEALLOC_XSTACK8
    480          
    481              if ( PROXY_TBL_GET_ASSIGNED_ALIAS( entry[PROXY_TBL_ENTRY_OPT + 1] ) )
   \   00013E   740A         MOV       A,#0xa
   \   000140   12....       LCALL     ?XSTACK_DISP0_8
   \   000143   E0           MOVX      A,@DPTR
   \   000144   A2E5         MOV       C,0xE0 /* A   */.5
   \   000146   5022         JNC       ??zcl_event_loop_10
    482              {
    483                _NIB.nwkDevAddress = 0;
   \   000148   90....       MOV       DPTR,#_NIB + 20
   \   00014B   E4           CLR       A
   \   00014C   F0           MOVX      @DPTR,A
   \   00014D   A3           INC       DPTR
   \   00014E   F0           MOVX      @DPTR,A
    484                osal_memcpy( (uint8*)&_NIB.nwkDevAddress, &entry[PROXY_TBL_ENTRY_ALIAS], sizeof(uint16));
   \   00014F                ; Setup parameters for call to function osal_memcpy
   \   00014F   7414         MOV       A,#0x14
   \   000151   12....       LCALL     ?XSTACK_DISP0_8
   \   000154   A982         MOV       R1,DPL
   \   000156   AA83         MOV       R2,DPH
   \   000158   89..         MOV       ?V4,R1
   \   00015A   8A..         MOV       ?V5,R2
   \   00015C   75..00       MOV       ?V6,#0x0
   \   00015F   78..         MOV       R0,#?V4
   \   000161   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000164   12....       LCALL     ?Subroutine98 & 0xFFFF
    485              }
   \                     ??CrossCallReturnLabel_354:
   \   000167   12....       LCALL     ?DEALLOC_XSTACK8
    486              
    487              // save aps sequence number
    488              apsSecNum = APS_Counter;
   \                     ??zcl_event_loop_10:
   \   00016A   90....       MOV       DPTR,#APS_Counter
   \   00016D   E0           MOVX      A,@DPTR
   \   00016E   F5..         MOV       ?V4,A
    489              APS_Counter = pCmdPayloadMsgCurr->secNum;
   \   000170   8E82         MOV       DPL,R6
   \   000172   8F83         MOV       DPH,R7
   \   000174   E0           MOVX      A,@DPTR
   \   000175   90....       MOV       DPTR,#APS_Counter
   \   000178   F0           MOVX      @DPTR,A
    490              
    491              // Set nwk radius for zcl frame
    492              if ( entry[PROXY_TBL_ENTRY_GRP_RAD] != 0xFF)
   \   000179   7448         MOV       A,#0x48
   \   00017B   12....       LCALL     ?XSTACK_DISP0_8
   \   00017E   E0           MOVX      A,@DPTR
   \   00017F   F8           MOV       R0,A
   \   000180   74FF         MOV       A,#-0x1
   \   000182   68           XRL       A,R0
   \   000183   6005         JZ        ??zcl_event_loop_11
    493              {
    494                zcl_radius =  entry[PROXY_TBL_ENTRY_GRP_RAD];
   \   000185   E8           MOV       A,R0
   \   000186   90....       MOV       DPTR,#zcl_radius
   \   000189   F0           MOVX      @DPTR,A
    495              }
    496              
    497              zcl_SendCommand( GREEN_POWER_INTERNAL_ENDPOINT, &gpNotification->addr, ZCL_CLUSTER_ID_GREEN_POWER,
    498                                    COMMAND_GP_NOTIFICATION, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    499                                    TRUE, 0,  bdb_getZCLFrameCounter(), pCmdPayloadMsgCurr->lenght, pCmdPayloadMsgCurr->pMsg );
   \                     ??zcl_event_loop_11:
   \   00018A                ; Setup parameters for call to function bdb_getZCLFrameCounter
   \   00018A   12....       LCALL     `??bdb_getZCLFrameCounter::?relay`; Banked call to: bdb_getZCLFrameCounter
   \   00018D   E9           MOV       A,R1
   \   00018E   F9           MOV       R1,A
   \   00018F                ; Setup parameters for call to function zcl_SendCommand
   \   00018F   85..82       MOV       DPL,?V0
   \   000192   85..83       MOV       DPH,?V1
   \   000195   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000198   8E82         MOV       DPL,R6
   \   00019A   8F83         MOV       DPH,R7
   \   00019C   A3           INC       DPTR
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   F5..         MOV       ?V0,A
   \   0001A0   75..00       MOV       ?V1,#0x0
   \   0001A3   78..         MOV       R0,#?V0
   \   0001A5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001A8   E9           MOV       A,R1
   \   0001A9   F5..         MOV       ?V0,A
   \   0001AB   78..         MOV       R0,#?V0
   \   0001AD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B0   E4           CLR       A
   \   0001B1   F5..         MOV       ?V0,A
   \   0001B3   78..         MOV       R0,#?V0
   \   0001B5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001B8   75..01       MOV       ?V0,#0x1
   \   0001BB   78..         MOV       R0,#?V0
   \   0001BD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C0   75..00       MOV       ?V0,#0x0
   \   0001C3   78..         MOV       R0,#?V0
   \   0001C5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C8   75..01       MOV       ?V0,#0x1
   \   0001CB   78..         MOV       R0,#?V0
   \   0001CD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001D0   75..00       MOV       ?V0,#0x0
   \   0001D3   78..         MOV       R0,#?V0
   \   0001D5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001D8   7C21         MOV       R4,#0x21
   \   0001DA   7D00         MOV       R5,#0x0
   \   0001DC   AA..         MOV       R2,?V2
   \   0001DE   AB..         MOV       R3,?V3
   \   0001E0   79F2         MOV       R1,#-0xe
   \   0001E2   12....       LCALL     ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   0001E5   12....       LCALL     ?DEALLOC_XSTACK8
    500              
    501              // restore nwk radius
    502              zcl_radius = AF_DEFAULT_RADIUS;
   \   0001E8   90....       MOV       DPTR,#zcl_radius
   \   0001EB   741E         MOV       A,#0x1e
   \   0001ED   F0           MOVX      @DPTR,A
    503              
    504              // restore aps sequence number
    505              APS_Counter = apsSecNum;
   \   0001EE   E5..         MOV       A,?V4
   \   0001F0   90....       MOV       DPTR,#APS_Counter
   \   0001F3   F0           MOVX      @DPTR,A
    506               
    507              // Restore the NIB nwk sequence number
    508              _NIB.SequenceNum = nwkSeqNum;
   \   0001F4   E5..         MOV       A,?V7
   \   0001F6   90....       MOV       DPTR,#_NIB
   \   0001F9   F0           MOVX      @DPTR,A
    509              
    510              // Restore the NIB nwk address
    511              _NIB.nwkDevAddress = nwkAddr;
   \   0001FA   90....       MOV       DPTR,#_NIB + 20
   \   0001FD   E5..         MOV       A,?V8
   \   0001FF   F0           MOVX      @DPTR,A
   \   000200   A3           INC       DPTR
   \   000201   E5..         MOV       A,?V9
   \   000203   F0           MOVX      @DPTR,A
    512              
    513              gp_NotificationMsgClean( gp_GetPHeadNotification ( ) );
   \   000204                ; Setup parameters for call to function gp_GetPHeadNotification
   \   000204   12....       LCALL     `??gp_GetPHeadNotification::?relay`; Banked call to: gp_GetPHeadNotification
   \   000207                ; Setup parameters for call to function gp_NotificationMsgClean
   \   000207   12....       LCALL     `??gp_NotificationMsgClean::?relay`; Banked call to: gp_NotificationMsgClean
    514              
    515              if ( gp_GetHeadNotificationMsg ( ) != NULL )
   \   00020A                ; Setup parameters for call to function gp_GetHeadNotificationMsg
   \   00020A   12....       LCALL     `??gp_GetHeadNotificationMsg::?relay`; Banked call to: gp_GetHeadNotificationMsg
   \   00020D   EA           MOV       A,R2
   \   00020E   4B           ORL       A,R3
   \   00020F   6017         JZ        ??zcl_event_loop_6
    516              {
    517                osal_start_timerEx( zcl_TaskID, ZCL_DATABUF_SEND, 50 );
   \   000211                ; Setup parameters for call to function osal_start_timerEx
   \   000211   90....       MOV       DPTR,#__Constant_32
   \   000214   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000217   7A20         MOV       R2,#0x20
   \   000219   7B00         MOV       R3,#0x0
   \   00021B   90....       MOV       DPTR,#zcl_TaskID
   \   00021E   E0           MOVX      A,@DPTR
   \   00021F   F9           MOV       R1,A
   \   000220   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000223   7404         MOV       A,#0x4
   \   000225   12....       LCALL     ?DEALLOC_XSTACK8
    518              }
    519            }
    520          #endif
    521          
    522            // Discard unknown events
    523            return 0;
   \                     ??zcl_event_loop_6:
   \   000228   7A00         MOV       R2,#0x0
   \   00022A   7B00         MOV       R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00022C   744A         MOV       A,#0x4a
   \   00022E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000231   7F0A         MOV       R7,#0xa
   \   000233   02....       LJMP      ?BANKED_LEAVE_XDATA
    524          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   F5..         MOV       ?V4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   3400         ADDC      A,#0x0
   \   000006   F5..         MOV       ?V5,A
   \   000008   75..00       MOV       ?V6,#0x0
   \   00000B                ; Setup parameters for call to function osal_memcpy
   \   00000B   78..         MOV       R0,#?V4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V8,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V9,A
   \   000007   E8           MOV       A,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine162_0:
   \   000000   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000003   740B         MOV       A,#0xb
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   F5..         MOV       ?V0,A
   \   000002   E4           CLR       A
   \   000003   3F           ADDC      A,R7
   \   000004   F5..         MOV       ?V1,A
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV       DPL,?V0
   \   000009   F583         MOV       DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL     ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   E0           MOVX      A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   7C02         MOV       R4,#0x2
   \   000002   7D00         MOV       R5,#0x0
   \   000004   7A..         MOV       R2,#(_NIB + 20) & 0xff
   \   000006   7B..         MOV       R3,#((_NIB + 20) >> 8) & 0xff
   \   000008                REQUIRE ??Subroutine177_0
   \   000008                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000003   7403         MOV       A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   12....       LCALL     ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_425:
   \   000003   F583         MOV       DPH,A
   \   000005   8882         MOV       DPL,R0
   \   000007   22           RET
    525          #endif
    526          
    527          #if !defined ( ZCL_STANDALONE )
    528          /*********************************************************************
    529           * @fn      zcl_registerForMsg
    530           *
    531           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    532           *          messages that aren't processed to one task (if a task is
    533           *          registered).
    534           *
    535           * @param   taskId - task Id of the Application where commands will be sent to
    536           *
    537           * @return  TRUE if task registeration successful, FALSE otherwise
    538           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    539          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    540          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    541            return zcl_addExternalFoundationHandler( taskId, AF_BROADCAST_ENDPOINT );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   7AFF         MOV       R2,#-0x1
   \   000007   02....       LJMP      ?Subroutine1 & 0xFFFF
    542          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   000003                REQUIRE ??Subroutine171_0
   \   000003                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    543          
    544          /*********************************************************************
    545           * @fn      zcl_registerForMsgExt
    546           *
    547           * @brief   This function enables a Task to register to recieve all
    548           *          incoming Foundation Command/Response messages, for a particular
    549           *          End Point, that aren't processed by ZCL.
    550           *
    551           *          NOTE: Any Task registered for a unique end point will take
    552           *          priority over any Task registered with the AF_BROADCAST_ENDPOINT
    553           *          value.  ie. If task A registers for End Point 1, task B registers
    554           *          for AF_BROADCAST_ENDPOINT,  commands addressed to End Point 1 will be
    555           *          sent to Task A and NOT Task B.
    556           *
    557           * @param   taskId - task Id of the Application where commands will be sent to
    558           * @param   endPointId - end point Id of interest
    559           *
    560           * @return  TRUE if task registeration successful, FALSE otherwise
    561           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    562          uint8 zcl_registerForMsgExt( uint8 taskId, uint8 endPointId  )
   \                     zcl_registerForMsgExt:
    563          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    564            return ( zcl_addExternalFoundationHandler( taskId, endPointId  ) );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   02....       LJMP      ?Subroutine1 & 0xFFFF
    565          }
    566          
    567          /*********************************************************************
    568           * @fn      zcl_addExternalFoundationHandler
    569           *
    570           * @brief   This function adds a record to the internal list of external
    571           *          handlers of unhandled incoming Foundation Command/Response messages.
    572           *
    573           * @param   taskId - task Id of the Application where commands will be sent to
    574           * @param   endPointId - end point Id of interest
    575           *
    576           * @return  TRUE if task registeration successful, FALSE otherwise
    577           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    578          uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId  )
   \                     zcl_addExternalFoundationHandler:
    579          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   \   000007   EA           MOV       A,R2
   \   000008   FF           MOV       R7,A
    580            zclExternalFoundationHandlerList *pNewItem;
    581            zclExternalFoundationHandlerList *pLoop;
    582            zclExternalFoundationHandlerList *pLoopPrev;
    583          
    584            // Fill in the new endpoint registrant list
    585            pNewItem = zcl_mem_alloc( sizeof( zclExternalFoundationHandlerList ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A04         MOV       R2,#0x4
   \   00000B   12....       LCALL     ?Subroutine141 & 0xFFFF
    586            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_251:
   \   00000E   6038         JZ        ??zcl_addExternalFoundationHandler_0
    587            {
    588              return ( false );
    589            }
    590          
    591            pNewItem->zcl_ExternalEndPoint = endPointId;
   \   000010   EF           MOV       A,R7
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   F0           MOVX      @DPTR,A
    592            pNewItem->zcl_ExternalTaskID = taskId;
   \   000019   EE           MOV       A,R6
   \   00001A   8A82         MOV       DPL,R2
   \   00001C   8B83         MOV       DPH,R3
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   12....       LCALL     ?Subroutine152 & 0xFFFF
    593            pNewItem->next = NULL;
   \                     ??CrossCallReturnLabel_312:
   \   000023   E4           CLR       A
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   F0           MOVX      @DPTR,A
    594          
    595            // Add to the list
    596            if ( externalEndPointHandlerList == NULL )
   \   000027   90....       MOV       DPTR,#externalEndPointHandlerList
   \   00002A   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   00002D   7009         JNZ       ??zcl_addExternalFoundationHandler_1
    597            {
    598              externalEndPointHandlerList = pNewItem;
   \   00002F   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000032   EA           MOV       A,R2
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   EB           MOV       A,R3
   \   000036   8042         SJMP      ??zcl_addExternalFoundationHandler_2
    599            }
    600            else
    601            {
    602              // make sure no one else tried to register for this endpoint
    603              pLoop = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_1:
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F9           MOV       R1,A
    604              pLoopPrev = externalEndPointHandlerList;
    605          
    606              while ( pLoop != NULL )
    607              {
    608                if ( ( pLoop->zcl_ExternalEndPoint ) == endPointId )
   \                     ??zcl_addExternalFoundationHandler_3:
   \   00003A   8882         MOV       DPL,R0
   \   00003C   8983         MOV       DPH,R1
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   6F           XRL       A,R7
   \   000043   7007         JNZ       ??zcl_addExternalFoundationHandler_4
    609                {
    610                  zcl_mem_free(pNewItem);
   \   000045                ; Setup parameters for call to function osal_mem_free
   \   000045   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    611                  return ( false );
   \                     ??zcl_addExternalFoundationHandler_0:
   \   000048   7900         MOV       R1,#0x0
   \   00004A   8031         SJMP      ??zcl_addExternalFoundationHandler_5
    612                }
    613                pLoopPrev = pLoop;
   \                     ??zcl_addExternalFoundationHandler_4:
   \   00004C   E8           MOV       A,R0
   \   00004D   FC           MOV       R4,A
   \   00004E   E9           MOV       A,R1
   \   00004F   FD           MOV       R5,A
    614                pLoop = pLoop->next;
   \   000050   8882         MOV       DPL,R0
   \   000052   8983         MOV       DPH,R1
   \   000054   12....       LCALL     ??Subroutine175_0 & 0xFFFF
    615              }
   \                     ??CrossCallReturnLabel_329:
   \   000057   70E1         JNZ       ??zcl_addExternalFoundationHandler_3
    616          
    617              if ( endPointId == AF_BROADCAST_ENDPOINT )
   \   000059   74FF         MOV       A,#-0x1
   \   00005B   6F           XRL       A,R7
   \   00005C   700C         JNZ       ??zcl_addExternalFoundationHandler_6
    618              {
    619                // put new registration at the end of the list
    620                pLoopPrev->next = pNewItem;
   \   00005E   8C82         MOV       DPL,R4
   \   000060   8D83         MOV       DPH,R5
   \   000062   12....       LCALL     ?Subroutine32 & 0xFFFF
    621                pNewItem->next = NULL;
    622              }
   \                     ??CrossCallReturnLabel_35:
   \   000065   E4           CLR       A
   \   000066   F0           MOVX      @DPTR,A
   \   000067   A3           INC       DPTR
   \   000068   8010         SJMP      ??zcl_addExternalFoundationHandler_2
    623              else
    624              {
    625                // put new registration at the front of the list
    626                zclExternalFoundationHandlerList *temp = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_6:
   \   00006A   90....       MOV       DPTR,#externalEndPointHandlerList
   \   00006D   12....       LCALL     ??Subroutine186_0 & 0xFFFF
    627                externalEndPointHandlerList = pNewItem;
   \                     ??CrossCallReturnLabel_409:
   \   000070   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000073   12....       LCALL     ?Subroutine32 & 0xFFFF
    628                pNewItem->next = temp;
    629              }
    630            }
   \                     ??CrossCallReturnLabel_36:
   \   000076   E8           MOV       A,R0
   \   000077   F0           MOVX      @DPTR,A
   \   000078   A3           INC       DPTR
   \   000079   E9           MOV       A,R1
   \                     ??zcl_addExternalFoundationHandler_2:
   \   00007A   F0           MOVX      @DPTR,A
    631          
    632            return ( true );
   \   00007B   7901         MOV       R1,#0x1
   \                     ??zcl_addExternalFoundationHandler_5:
   \   00007D   02....       LJMP      ?Subroutine2 & 0xFFFF
    633          
    634          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   7B00         MOV       R3,#0x0
   \   000002                REQUIRE ??Subroutine153_0
   \   000002                ; // Fall through to label ??Subroutine153_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine153_0:
   \   000000   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000003   EA           MOV       A,R2
   \   000004   4B           ORL       A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_420:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_427:
   \   000003   F9           MOV       R1,A
   \   000004   22           RET
    635          
    636          /*********************************************************************
    637           * @fn      zcl_getExternalFoundationHandler
    638           *
    639           * @brief   This function retrieves the Task ID of the task registered
    640           *          to received unhandled incoming Foundation Command/Response messages
    641           *          for a particular End Point ID.
    642           *
    643           * @param   pInMsg - recevied ZCL command
    644           *
    645           * @return  TASK ID of registered task.  If no task is reigistered, it returns
    646           *          TASK_NO_TASK.
    647           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    648          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg )
   \                     zcl_getExternalFoundationHandler:
    649          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    650            zclExternalFoundationHandlerList *pLoop;
    651            uint8 addressedEndPointId = pInMsg->endPoint;
   \   000004   EA           MOV       A,R2
   \   000005   12....       LCALL     ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_457:
   \   000008   3B           ADDC      A,R3
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   FA           MOV       R2,A
    652          
    653            // make sure no one else tried to register for this endpoint
    654            pLoop = externalEndPointHandlerList;
   \   00000D   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000010   8004         SJMP      ??zcl_getExternalFoundationHandler_0
    655          
    656            while ( pLoop != NULL )
    657            {
    658              if ( ( ( pLoop->zcl_ExternalEndPoint ) == addressedEndPointId ) ||
    659                   ( ( pLoop->zcl_ExternalEndPoint ) == AF_BROADCAST_ENDPOINT ) )
    660              {
    661                return ( pLoop->zcl_ExternalTaskID );
    662              }
    663              pLoop = pLoop->next;
   \                     ??zcl_getExternalFoundationHandler_1:
   \   000012   8882         MOV       DPL,R0
   \   000014   8983         MOV       DPH,R1
   \                     ??zcl_getExternalFoundationHandler_0:
   \   000016   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000019   601C         JZ        ??zcl_getExternalFoundationHandler_2
   \   00001B   8882         MOV       DPL,R0
   \   00001D   8983         MOV       DPH,R1
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   FB           MOV       R3,A
   \   000024   EA           MOV       A,R2
   \   000025   6B           XRL       A,R3
   \   000026   6005         JZ        ??zcl_getExternalFoundationHandler_3
   \   000028   74FF         MOV       A,#-0x1
   \   00002A   6B           XRL       A,R3
   \   00002B   70E5         JNZ       ??zcl_getExternalFoundationHandler_1
   \                     ??zcl_getExternalFoundationHandler_3:
   \   00002D   8882         MOV       DPL,R0
   \   00002F   8983         MOV       DPH,R1
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F9           MOV       R1,A
   \   000035   8002         SJMP      ??zcl_getExternalFoundationHandler_4
    664            }
    665          
    666            return ( TASK_NO_TASK );
   \                     ??zcl_getExternalFoundationHandler_2:
   \   000037   79FF         MOV       R1,#-0x1
   \                     ??zcl_getExternalFoundationHandler_4:
   \   000039   02....       LJMP      ?Subroutine0 & 0xFFFF
    667          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_466:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   2414         ADD       A,#0x14
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   22           RET
    668          #endif
    669          
    670          #if !defined ( ZCL_STANDALONE )
    671          /*********************************************************************
    672           * @fn      zcl_HandleExternal
    673           *
    674           * @brief
    675           *
    676           * @param   pInMsg - incoming message to process
    677           *
    678           * @return  TRUE
    679           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    680          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    681          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    682            zclIncomingMsg_t *pCmd;
    683            uint8 taskID;
    684          
    685            taskID = zcl_getExternalFoundationHandler( pInMsg->msg );
   \   000009                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000009   8A82         MOV       DPL,R2
   \   00000B   F583         MOV       DPH,A
   \   00000D   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   000010   12....       LCALL     `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000013   E9           MOV       A,R1
   \   000014   F5..         MOV       ?V0,A
    686          
    687            if ( taskID == TASK_NO_TASK )
   \   000016   74FF         MOV       A,#-0x1
   \   000018   69           XRL       A,R1
   \   000019   7003         JNZ       $+5
   \   00001B   02....       LJMP      ??zcl_HandleExternal_0 & 0xFFFF
    688            {
    689              return ( TRUE );
    690            }
    691          
    692            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00001E                ; Setup parameters for call to function osal_msg_allocate
   \   00001E   7A19         MOV       R2,#0x19
   \   000020   7B00         MOV       R3,#0x0
   \   000022   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    693            if ( pCmd != NULL )
   \   000025   EA           MOV       A,R2
   \   000026   4B           ORL       A,R3
   \   000027   7003         JNZ       $+5
   \   000029   02....       LJMP      ??zcl_HandleExternal_0 & 0xFFFF
    694            {
    695              // fill in the message
    696              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00002C   8A82         MOV       DPL,R2
   \   00002E   8B83         MOV       DPH,R3
   \   000030   7434         MOV       A,#0x34
   \   000032   12....       LCALL     ?Subroutine123 & 0xFFFF
    697              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_348:
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   EA           MOV       A,R2
   \   000038   2402         ADD       A,#0x2
   \   00003A   FC           MOV       R4,A
   \   00003B   E4           CLR       A
   \   00003C   3B           ADDC      A,R3
   \   00003D   FD           MOV       R5,A
   \   00003E   7406         MOV       A,#0x6
   \   000040   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    698              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000043   8E82         MOV       DPL,R6
   \   000045   8F83         MOV       DPH,R7
   \   000047   12....       LCALL     ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   00004A   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   00004D   8A82         MOV       DPL,R2
   \   00004F   8B83         MOV       DPH,R3
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   EC           MOV       A,R4
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   ED           MOV       A,R5
   \   00005D   12....       LCALL     ?Subroutine30 & 0xFFFF
    699              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_30:
   \   000060   A3           INC       DPTR
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   A3           INC       DPTR
   \   000064   A3           INC       DPTR
   \   000065   EA           MOV       A,R2
   \   000066   240A         ADD       A,#0xa
   \   000068   FC           MOV       R4,A
   \   000069   E4           CLR       A
   \   00006A   3B           ADDC      A,R3
   \   00006B   FD           MOV       R5,A
   \   00006C   740C         MOV       A,#0xc
   \   00006E   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    700              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000071   8E82         MOV       DPL,R6
   \   000073   8F83         MOV       DPH,R7
   \   000075   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000078   C0E0         PUSH      A
   \   00007A   EA           MOV       A,R2
   \   00007B   2416         ADD       A,#0x16
   \   00007D   F582         MOV       DPL,A
   \   00007F   E4           CLR       A
   \   000080   3B           ADDC      A,R3
   \   000081   F583         MOV       DPH,A
   \   000083   D0E0         POP       A
   \   000085   F0           MOVX      @DPTR,A
    701              pCmd->attrCmd   = pInMsg->attrCmd;
   \   000086   EE           MOV       A,R6
   \   000087   240C         ADD       A,#0xc
   \   000089   F8           MOV       R0,A
   \   00008A   E4           CLR       A
   \   00008B   3F           ADDC      A,R7
   \   00008C   F9           MOV       R1,A
   \   00008D   8882         MOV       DPL,R0
   \   00008F   F583         MOV       DPH,A
   \   000091   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_428:
   \   000094   EA           MOV       A,R2
   \   000095   2417         ADD       A,#0x17
   \   000097   F582         MOV       DPL,A
   \   000099   E4           CLR       A
   \   00009A   3B           ADDC      A,R3
   \   00009B   F583         MOV       DPH,A
   \   00009D   EC           MOV       A,R4
   \   00009E   F0           MOVX      @DPTR,A
   \   00009F   A3           INC       DPTR
   \   0000A0   ED           MOV       A,R5
   \   0000A1   F0           MOVX      @DPTR,A
    702              
    703          #ifdef BDB_REPORTING
    704              if(pCmd->zclHdr.commandID == ZCL_CMD_CONFIG_REPORT)
    705              {
    706                bdb_ProcessInConfigReportCmd(pCmd);
    707                osal_msg_deallocate((uint8*)pCmd);
    708                return TRUE;          
    709              }
    710              if(pCmd->zclHdr.commandID == ZCL_CMD_READ_REPORT_CFG)
    711              {
    712                bdb_ProcessInReadReportCfgCmd(pCmd);
    713                osal_msg_deallocate((uint8*)pCmd);
    714                return TRUE;
    715              }
    716          #endif
    717              // Application will free the attrCmd buffer
    718              pInMsg->attrCmd = NULL;
   \   0000A2   8882         MOV       DPL,R0
   \   0000A4   8983         MOV       DPH,R1
   \   0000A6   E4           CLR       A
   \   0000A7   F0           MOVX      @DPTR,A
   \   0000A8   A3           INC       DPTR
   \   0000A9   F0           MOVX      @DPTR,A
    719          
    720              /* send message through task message */
    721              osal_msg_send( taskID, (uint8 *)pCmd );
   \   0000AA                ; Setup parameters for call to function osal_msg_send
   \   0000AA   A9..         MOV       R1,?V0
   \   0000AC   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    722            }
    723          
    724            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000AF   7901         MOV       R1,#0x1
   \   0000B1   02....       LJMP      ?Subroutine3 & 0xFFFF
    725          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine163_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_418:
   \   000003   8882         MOV       DPL,R0
   \   000005   F583         MOV       DPH,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   A3           INC       DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   12....       LCALL     ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_489:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine187_0
   \   000002                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine188_0
   \   000002                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   12....       LCALL     ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_496:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   12....       LCALL     ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   A3           INC       DPTR
   \   000001   E0           MOVX      A,@DPTR
   \   000002   C8           XCH       A,R0
   \   000003   2414         ADD       A,#0x14
   \   000005   F582         MOV       DPL,A
   \   000007   E4           CLR       A
   \   000008   38           ADDC      A,R0
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   22           RET
    726          #endif
    727          
    728          
    729          /*********************************************************************
    730           * @fn          zcl_getRawAFMsg
    731           *
    732           * @brief       Call to get original unprocessed AF message
    733           *              (not parsed by ZCL).
    734           *
    735           *   NOTE:  This function can only be called during a ZCL callback function
    736           *          and the calling function must NOT change any data in the message.
    737           *
    738           * @param       none
    739           *
    740           * @return      pointer to original AF message, NULL if not processing
    741           *              AF message.
    742           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    743          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    744          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    745            return ( rawAFMsg );
   \   000004   90....       MOV       DPTR,#rawAFMsg
   \   000007   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   00000A   02....       LJMP      ?Subroutine0 & 0xFFFF
    746          }
    747          
    748          /*********************************************************************
    749           * @fn          zcl_getParsedTransSeqNum
    750           *
    751           * @brief       Call to the get the transaction sequence number from
    752           *              the incoming message.
    753           *
    754           *   NOTE:  This function can only be called during a ZCL callback function
    755           *          and the calling function must NOT change any data in the message.
    756           *
    757           * @param       none
    758           *
    759           * @return      transaction sequence number.
    760           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    761          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    762          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    763            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV       DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   02....       LJMP      ?Subroutine0 & 0xFFFF
    764          }
    765          
    766          /*********************************************************************
    767           * @fn          zcl_registerPlugin
    768           *
    769           * @brief       Add a Cluster Library handler
    770           *
    771           * @param       startClusterID - starting cluster ID
    772           * @param       endClusterID - ending cluster ID
    773           * @param       pfnHdlr - function pointer to incoming message handler
    774           *
    775           * @return      ZSuccess if OK
    776           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    777          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    778                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    779          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    780            zclLibPlugin_t *pNewItem;
    781            zclLibPlugin_t *pLoop;
    782          
    783            // Fill in the new profile list
    784            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV       R2,#0x8
   \   00000F   12....       LCALL     ??Subroutine154_0 & 0xFFFF
    785            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_257:
   \   000012   7004         JNZ       ??zcl_registerPlugin_0
    786            {
    787              return (ZMemError);
   \   000014   7910         MOV       R1,#0x10
   \   000016   8045         SJMP      ??CrossCallReturnLabel_10
    788            }
    789          
    790            // Fill in the plugin record.
    791            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000018   12....       LCALL     ?Subroutine18 & 0xFFFF
    792            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_8:
   \   00001B   A3           INC       DPTR
   \   00001C   E5..         MOV       A,?V1
   \   00001E   12....       LCALL     ?Subroutine26 & 0xFFFF
    793            pNewItem->endClusterID = endClusterID;
   \                     ??CrossCallReturnLabel_24:
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   EE           MOV       A,R6
   \   000025   F0           MOVX      @DPTR,A
   \   000026   A3           INC       DPTR
   \   000027   EF           MOV       A,R7
   \   000028   F0           MOVX      @DPTR,A
    794            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   000029   740C         MOV       A,#0xc
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_366:
   \   000031   8882         MOV       DPL,R0
   \   000033   8983         MOV       DPH,R1
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   12....       LCALL     ??Subroutine167_0 & 0xFFFF
    795          
    796            // Find spot in list
    797            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_292:
   \   00003E   90....       MOV       DPTR,#plugins
   \   000041   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000044   90....       MOV       DPTR,#plugins
   \   000047   6011         JZ        ??zcl_registerPlugin_1
    798            {
    799              plugins = pNewItem;
    800            }
    801            else
    802            {
    803              // Look for end of list
    804              pLoop = plugins;
   \   000049   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   00004C   8003         SJMP      ??zcl_registerPlugin_2
    805              while ( pLoop->next != NULL )
    806              {
    807                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   00004E   EA           MOV       A,R2
   \   00004F   FC           MOV       R4,A
   \   000050   EB           MOV       A,R3
    808              }
   \                     ??zcl_registerPlugin_2:
   \   000051   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000054   70F8         JNZ       ??zcl_registerPlugin_3
    809          
    810              // Put new item at end of list
    811              pLoop->next = pNewItem;
   \   000056   8C82         MOV       DPL,R4
   \   000058   8D83         MOV       DPH,R5
    812            }
   \                     ??zcl_registerPlugin_1:
   \   00005A   12....       LCALL     ?Subroutine19 & 0xFFFF
    813          
    814            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_10:
   \   00005D   02....       LJMP      ?Subroutine3 & 0xFFFF
    815          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL     ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   E4           CLR       A
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   00000A   A3           INC       DPTR
   \   00000B   E5..         MOV       A,?V0
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine154_0:
   \   000000   7B00         MOV       R3,#0x0
   \   000002   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000005   8A..         MOV       ?V2,R2
   \   000007   8B..         MOV       ?V3,R3
   \   000009   A8..         MOV       R0,?V2
   \   00000B   A9..         MOV       R1,?V3
   \   00000D   EA           MOV       A,R2
   \   00000E   49           ORL       A,R1
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   7900         MOV       R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL     ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   FD           MOV       R5,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005                REQUIRE ??Subroutine172_0
   \   000005                ; // Fall through to label ??Subroutine172_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   12....       LCALL     ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_488:
   \   000003   EA           MOV       A,R2
   \   000004   4B           ORL       A,R3
   \   000005   22           RET
    816          
    817          #ifdef ZCL_DISCOVER
    818          /*********************************************************************
    819           * @fn          zcl_registerCmdList
    820           *
    821           * @brief       Register a Command List with ZCL Foundation
    822           *
    823           * @param       endpoint - endpoint the attribute list belongs to
    824           * @param       newCmdList - array of command records
    825           *
    826           * @return      ZSuccess if OK
    827           */
    828          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    829          {
    830            zclCmdRecsList_t *pNewItem;
    831            zclCmdRecsList_t *pLoop;
    832          
    833            // Fill in the new profile list
    834            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    835            if ( pNewItem == NULL )
    836            {
    837              return (ZMemError);
    838            }
    839          
    840            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    841            pNewItem->endpoint = endpoint;
    842            pNewItem->numCommands = cmdListSize;
    843            pNewItem->pCmdRecs = newCmdList;
    844          
    845            // Find spot in list
    846            if ( gpCmdList == NULL )
    847            {
    848              gpCmdList = pNewItem;
    849            }
    850            else
    851            {
    852              // Look for end of list
    853              pLoop = gpCmdList;
    854              while ( pLoop->pNext != NULL )
    855              {
    856                pLoop = pLoop->pNext;
    857              }
    858          
    859              // Put new item at end of list
    860              pLoop->pNext = pNewItem;
    861            }
    862          
    863            return ( ZSuccess );
    864          }
    865          #endif  // ZCL_DISCOVER
    866          
    867          /*********************************************************************
    868           * @fn          zcl_registerAttrList
    869           *
    870           * @brief       Register an Attribute List with ZCL Foundation
    871           *
    872           * @param       endpoint - endpoint the attribute list belongs to
    873           * @param       numAttr - number of attributes in list
    874           * @param       newAttrList - array of Attribute records.
    875           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    876           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    877           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    878           *
    879           * @return      ZSuccess if OK
    880           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    881          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    882          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   8A..         MOV       ?V1,R2
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    883            zclAttrRecsList *pNewItem;
    884            zclAttrRecsList *pLoop;
    885          
    886            // Fill in the new profile list
    887            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV       R2,#0xa
   \   00000F   12....       LCALL     ??Subroutine154_0 & 0xFFFF
    888            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_258:
   \   000012   7004         JNZ       ??zcl_registerAttrList_0
    889            {
    890              return (ZMemError);
   \   000014   7910         MOV       R1,#0x10
   \   000016   803A         SJMP      ??CrossCallReturnLabel_11
    891            }
    892          
    893            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000018   12....       LCALL     ?Subroutine18 & 0xFFFF
    894            pNewItem->endpoint = endpoint;
    895            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_9:
   \   00001B   8A82         MOV       DPL,R2
   \   00001D   8B83         MOV       DPH,R3
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   E4           CLR       A
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   12....       LCALL     ?Subroutine20 & 0xFFFF
    896            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_14:
   \   000028   E5..         MOV       A,?V1
   \   00002A   12....       LCALL     ?Subroutine20 & 0xFFFF
    897            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_15:
   \   00002D   A3           INC       DPTR
   \   00002E   EE           MOV       A,R6
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   EF           MOV       A,R7
   \   000032   F0           MOVX      @DPTR,A
    898          
    899            // Find spot in list
    900            if ( attrList == NULL )
   \   000033   90....       MOV       DPTR,#attrList
   \   000036   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   000039   90....       MOV       DPTR,#attrList
   \   00003C   6011         JZ        ??zcl_registerAttrList_1
    901            {
    902              attrList = pNewItem;
    903            }
    904            else
    905            {
    906              // Look for end of list
    907              pLoop = attrList;
   \   00003E   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000041   8003         SJMP      ??zcl_registerAttrList_2
    908              while ( pLoop->next != NULL )
    909              {
    910                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000043   EA           MOV       A,R2
   \   000044   FC           MOV       R4,A
   \   000045   EB           MOV       A,R3
    911              }
   \                     ??zcl_registerAttrList_2:
   \   000046   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000049   70F8         JNZ       ??zcl_registerAttrList_3
    912          
    913              // Put new item at end of list
    914              pLoop->next = pNewItem;
   \   00004B   8C82         MOV       DPL,R4
   \   00004D   8D83         MOV       DPH,R5
    915            }
   \                     ??zcl_registerAttrList_1:
   \   00004F   12....       LCALL     ?Subroutine19 & 0xFFFF
    916          
    917            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_11:
   \   000052   02....       LJMP      ?Subroutine3 & 0xFFFF
    918          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL     ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   22           RET
    919          
    920          /*********************************************************************
    921           * @fn          zcl_registerClusterOptionList
    922           *
    923           * @brief       Register a Cluster Option List with ZCL Foundation
    924           *
    925           * @param       endpoint - endpoint the option list belongs to
    926           * @param       numOption - number of options in list
    927           * @param       optionList - array of cluster option records.
    928           *
    929           *              NOTE: This API should be called to enable 'Application
    930           *                    Link Key' security and/or 'APS ACK' for a specific
    931           *                    Cluster. The 'Application Link Key' is discarded
    932           *                    if security isn't enabled on the device.
    933           *                    The default behavior is 'Network Key' when security
    934           *                    is enabled and no 'APS ACK' for the ZCL messages.
    935           *
    936           * @return      ZSuccess if OK
    937           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    938          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    939          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL     ?Subroutine101 & 0xFFFF
    940            zclClusterOptionList *pNewItem;
    941            zclClusterOptionList *pLoop;
    942          
    943            // Fill in the new profile list
    944            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
    945            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_255:
   \   000008   7004         JNZ       ??zcl_registerClusterOptionList_0
    946            {
    947              return (ZMemError);
   \   00000A   7910         MOV       R1,#0x10
   \   00000C   8022         SJMP      ??CrossCallReturnLabel_12
    948            }
    949          
    950            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   00000E   12....       LCALL     ?Subroutine13 & 0xFFFF
    951            pNewItem->endpoint = endpoint;
    952            pNewItem->numOptions = numOption;
    953            pNewItem->options = optionList;
    954          
    955            // Find spot in list
    956            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_2:
   \   000011   90....       MOV       DPTR,#clusterOptionList
   \   000014   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000017   90....       MOV       DPTR,#clusterOptionList
   \   00001A   6011         JZ        ??zcl_registerClusterOptionList_1
    957            {
    958              clusterOptionList = pNewItem;
    959            }
    960            else
    961            {
    962              // Look for end of list
    963              pLoop = clusterOptionList;
   \   00001C   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   00001F   8003         SJMP      ??zcl_registerClusterOptionList_2
    964              while ( pLoop->next != NULL )
    965              {
    966                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   000021   EA           MOV       A,R2
   \   000022   FC           MOV       R4,A
   \   000023   EB           MOV       A,R3
    967              }
   \                     ??zcl_registerClusterOptionList_2:
   \   000024   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000027   70F8         JNZ       ??zcl_registerClusterOptionList_3
    968          
    969              // Put new item at end of list
    970              pLoop->next = pNewItem;
   \   000029   8C82         MOV       DPL,R4
   \   00002B   8D83         MOV       DPH,R5
    971            }
   \                     ??zcl_registerClusterOptionList_1:
   \   00002D   12....       LCALL     ?Subroutine19 & 0xFFFF
    972          
    973            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_12:
   \   000030   02....       LJMP      ?Subroutine3 & 0xFFFF
    974          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   89..         MOV       ?V0,R1
   \   000002   8A..         MOV       ?V1,R2
   \   000004   EC           MOV       A,R4
   \   000005   FE           MOV       R6,A
   \   000006   ED           MOV       A,R5
   \   000007   FF           MOV       R7,A
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A06         MOV       R2,#0x6
   \   00000A                REQUIRE ??Subroutine154_0
   \   00000A                ; // Fall through to label ??Subroutine154_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL     ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000003   8A82         MOV       DPL,R2
   \   000005   8B83         MOV       DPH,R3
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   E5..         MOV       A,?V1
   \   00000C   12....       LCALL     ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   EE           MOV       A,R6
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   EF           MOV       A,R7
   \   000016   F0           MOVX      @DPTR,A
   \   000017   22           RET
    975          
    976          /*********************************************************************
    977           * @fn          zcl_registerValidateAttrData
    978           *
    979           * @brief       Add a validation function for attribute data
    980           *
    981           * @param       pfnValidateAttrData - function pointer to validate routine
    982           *
    983           * @return      ZSuccess if OK
    984           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    985          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    986          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    987            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL     ??Subroutine167_0 & 0xFFFF
    988          
    989            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_293:
   \   00000A   7900         MOV       R1,#0x0
   \   00000C                REQUIRE ?Subroutine0
   \   00000C                ; // Fall through to label ?Subroutine0
    990          }
    991          
    992          /*********************************************************************
    993           * @fn          zcl_registerReadWriteCB
    994           *
    995           * @brief       Register the application's callback function to read/write
    996           *              attribute data, and authorize read/write operation.
    997           *
    998           *              Note: The pfnReadWriteCB callback function is only required
    999           *                    when the attribute data format is unknown to ZCL. The
   1000           *                    callback function gets called when the pointer 'dataPtr'
   1001           *                    to the attribute value is NULL in the attribute database
   1002           *                    registered with the ZCL.
   1003           *
   1004           *              Note: The pfnAuthorizeCB callback function is only required
   1005           *                    when the Read/Write operation on an attribute requires
   1006           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
   1007           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
   1008           *
   1009           * @param       endpoint - application's endpoint
   1010           * @param       pfnReadWriteCB - function pointer to read/write routine
   1011           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
   1012           *
   1013           * @return      ZSuccess if successful. ZFailure, otherwise.
   1014           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1015          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
   1016                                             zclAuthorizeCB_t pfnAuthorizeCB )
   1017          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   1018            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8B..         MOV       ?V5,R3
   \   000012   A9..         MOV       R1,?V5
   1019          
   1020            if ( pRec != NULL )
   \   000014   EA           MOV       A,R2
   \   000015   49           ORL       A,R1
   \   000016   6019         JZ        ??zcl_registerReadWriteCB_0
   1021            {
   1022              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   000018   8A82         MOV       DPL,R2
   \   00001A   8B83         MOV       DPH,R3
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   EE           MOV       A,R6
   \   000020   F0           MOVX      @DPTR,A
   \   000021   A3           INC       DPTR
   \   000022   EF           MOV       A,R7
   \   000023   12....       LCALL     ?Subroutine23 & 0xFFFF
   1023              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_18:
   \   000026   E5..         MOV       A,?V0
   \   000028   F0           MOVX      @DPTR,A
   \   000029   A3           INC       DPTR
   \   00002A   E5..         MOV       A,?V1
   \   00002C   F0           MOVX      @DPTR,A
   1024          
   1025              return ( ZSuccess );
   \   00002D   7900         MOV       R1,#0x0
   \   00002F   8002         SJMP      ??zcl_registerReadWriteCB_1
   1026            }
   1027          
   1028            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000031   7901         MOV       R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000033   02....       LJMP      ?Subroutine4 & 0xFFFF
   1029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL     ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1030          
   1031          /*********************************************************************
   1032           * @fn      zcl_DeviceOperational
   1033           *
   1034           * @brief   Used to see whether or not the device can send or respond
   1035           *          to application level commands.
   1036           *
   1037           * @param   srcEP - source endpoint
   1038           * @param   clusterID - cluster ID
   1039           * @param   frameType - command type
   1040           * @param   cmd - command ID
   1041           *
   1042           * @return  TRUE if device is operational, FALSE otherwise
   1043           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1044          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
   1045                                              uint8 frameType, uint8 cmd, uint16 profileID )
   1046          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   1047            zclAttrRec_t attrRec;
   1048            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000C   85..82       MOV       DPL,?XSP + 0
   \   00000F   85..83       MOV       DPH,?XSP + 1
   \   000012   7401         MOV       A,#0x1
   \   000014   F0           MOVX      @DPTR,A
   1049          
   1050            (void)profileID;  // Intentionally unreferenced parameter
   1051          
   1052            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
   1053            // cannot send or respond to application level commands, other than commands
   1054            // to read or write attributes. Note that the Identify cluster cannot be
   1055            // disabled, and remains functional regardless of this setting.
   1056            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000015   EC           MOV       A,R4
   \   000016   7006         JNZ       ??zcl_DeviceOperational_0
   \   000018   ED           MOV       A,R5
   \   000019   C3           CLR       C
   \   00001A   9406         SUBB      A,#0x6
   \   00001C   404D         JC        ??zcl_DeviceOperational_1
   1057            {
   1058              return ( TRUE );
   1059            }
   1060          
   1061            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   00001E   7403         MOV       A,#0x3
   \   000020   6A           XRL       A,R2
   \   000021   4B           ORL       A,R3
   \   000022   6047         JZ        ??zcl_DeviceOperational_1
   1062            {
   1063              return ( TRUE );
   1064            }
   1065          
   1066            // Is device enabled?
   1067            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
   1068                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000024                ; Setup parameters for call to function zclFindAttrRec
   \   000024   7401         MOV       A,#0x1
   \   000026   12....       LCALL     ?XSTACK_DISP100_8
   \   000029   88..         MOV       ?V2,R0
   \   00002B   89..         MOV       ?V3,R1
   \   00002D   78..         MOV       R0,#?V2
   \   00002F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000032   7C12         MOV       R4,#0x12
   \   000034   7D00         MOV       R5,#0x0
   \   000036   7A00         MOV       R2,#0x0
   \   000038   7B00         MOV       R3,#0x0
   \   00003A   EE           MOV       A,R6
   \   00003B   12....       LCALL     ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   00003E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000041   E9           MOV       A,R1
   \   000042   601C         JZ        ??zcl_DeviceOperational_2
   1069            {
   1070          #ifdef ZCL_READ
   1071              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000044                ; Setup parameters for call to function zclReadAttrData
   \   000044   E4           CLR       A
   \   000045   F5..         MOV       ?V2,A
   \   000047   F5..         MOV       ?V3,A
   \   000049   78..         MOV       R0,#?V2
   \   00004B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004E   7403         MOV       A,#0x3
   \   000050   12....       LCALL     ?XSTACK_DISP102_8
   \   000053   7402         MOV       A,#0x2
   \   000055   12....       LCALL     ?XSTACK_DISP101_8
   \   000058   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   00005B   7402         MOV       A,#0x2
   \   00005D   12....       LCALL     ?DEALLOC_XSTACK8
   1072          #endif
   1073            }
   1074          
   1075            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000060   85..82       MOV       DPL,?XSP + 0
   \   000063   85..83       MOV       DPH,?XSP + 1
   \   000066   E0           MOVX      A,@DPTR
   \   000067   6401         XRL       A,#0x1
   \   000069   7004         JNZ       ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   00006B   7901         MOV       R1,#0x1
   \   00006D   8002         SJMP      ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   00006F   7900         MOV       R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000071   7409         MOV       A,#0x9
   \   000073   12....       LCALL     ?DEALLOC_XSTACK8
   \   000076                REQUIRE ?Subroutine3
   \   000076                ; // Fall through to label ?Subroutine3
   1076          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   F9           MOV       R1,A
   \   000001                REQUIRE ??Subroutine155_0
   \   000001                ; // Fall through to label ??Subroutine155_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine155_0:
   \   000000   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET
   1077          
   1078          /*********************************************************************
   1079           * @fn      zcl_SendCommand
   1080           *
   1081           * @brief   Used to send Profile and Cluster Specific Command messages.
   1082           *
   1083           *          NOTE: The calling application is responsible for incrementing
   1084           *                the Sequence Number.
   1085           *
   1086           * @param   srcEp - source endpoint
   1087           * @param   destAddr - destination address
   1088           * @param   clusterID - cluster ID
   1089           * @param   cmd - command ID
   1090           * @param   specific - whether the command is Cluster Specific
   1091           * @param   direction - client/server direction of the command
   1092           * @param   disableDefaultRsp - disable Default Response command
   1093           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1094           * @param   seqNumber - identification number for the transaction
   1095           * @param   cmdFormatLen - length of the command to be sent
   1096           * @param   cmdFormat - command to be sent
   1097           *
   1098           * @return  ZSuccess if OK
   1099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1100          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
   1101                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
   1102                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
   1103                                     uint16 cmdFormatLen, uint8 *cmdFormat )
   1104          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V10,R1
   \   00000C   8A..         MOV       ?V14,R2
   \   00000E   8B..         MOV       ?V15,R3
   \   000010   8C..         MOV       ?V0,R4
   \   000012   8D..         MOV       ?V1,R5
   1105            endPointDesc_t *epDesc;
   1106            zclFrameHdr_t hdr;
   1107            uint8 *msgBuf;
   1108            uint16 msgLen;
   1109            uint8 *pBuf;
   1110            uint8 options;
   1111            ZStatus_t status;
   1112          
   1113            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL     `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV       ?V12,R2
   \   000019   8B..         MOV       ?V13,R3
   1114            if ( epDesc == NULL )
   \   00001B   EA           MOV       A,R2
   \   00001C   4B           ORL       A,R3
   \   00001D   7005         JNZ       ??zcl_SendCommand_0
   1115            {
   1116              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   00001F   7902         MOV       R1,#0x2
   \   000021   02....       LJMP      ??zcl_SendCommand_1 & 0xFFFF
   1117            }
   1118          
   1119          #if defined ( INTER_PAN )
   1120            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   1121            {
   1122              options = AF_TX_OPTIONS_NONE;
   1123            }
   1124            else
   1125          #endif
   1126            {
   1127              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000024                ; Setup parameters for call to function zclGetClusterOption
   \   000024   AA..         MOV       R2,?V0
   \   000026   AB..         MOV       R3,?V1
   \   000028   A9..         MOV       R1,?V10
   \   00002A   12....       LCALL     `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00002D   E9           MOV       A,R1
   \   00002E   F5..         MOV       ?V7,A
   1128          
   1129              // The cluster might not have been defined to use security but if this message
   1130              // is in response to another message that was using APS security this message
   1131              // will be sent with APS security
   1132              if ( !( options & AF_EN_SECURITY ) )
   \   000030   A2E6         MOV       C,0xE0 /* A   */.6
   \   000032   401C         JC        ??zcl_SendCommand_2
   1133              {
   1134                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000034   90....       MOV       DPTR,#rawAFMsg
   \   000037   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   1135          
   1136                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_331:
   \   00003A   6014         JZ        ??zcl_SendCommand_2
   \   00003C   E8           MOV       A,R0
   \   00003D   2419         ADD       A,#0x19
   \   00003F   F582         MOV       DPL,A
   \   000041   E4           CLR       A
   \   000042   39           ADDC      A,R1
   \   000043   F583         MOV       DPH,A
   \   000045   E0           MOVX      A,@DPTR
   \   000046   6401         XRL       A,#0x1
   \   000048   7006         JNZ       ??zcl_SendCommand_2
   1137                {
   1138                  options |= AF_EN_SECURITY;
   \   00004A   E5..         MOV       A,?V7
   \   00004C   D2E6         SETB      0xE0 /* A   */.6
   \   00004E   F5..         MOV       ?V7,A
   1139                }
   1140              }
   1141            }
   1142          
   1143            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000050                ; Setup parameters for call to function osal_memset
   \   000050   7C06         MOV       R4,#0x6
   \   000052   7D00         MOV       R5,#0x0
   \   000054   7900         MOV       R1,#0x0
   \   000056   AA..         MOV       R2,?XSP + 0
   \   000058   AB..         MOV       R3,?XSP + 1
   \   00005A   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1144          
   1145            // Not Profile wide command (like READ, WRITE)
   1146            if ( specific )
   \   00005D   741F         MOV       A,#0x1f
   \   00005F   12....       LCALL     ?XSTACK_DISP0_8
   \   000062   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000065   6009         JZ        ??zcl_SendCommand_3
   1147            {
   1148              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000067   E0           MOVX      A,@DPTR
   \   000068   54FC         ANL       A,#0xfc
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   4401         ORL       A,#0x1
   \   00006E   8003         SJMP      ??zcl_SendCommand_4
   1149            }
   1150            else
   1151            {
   1152              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   000070   E0           MOVX      A,@DPTR
   \   000071   54FC         ANL       A,#0xfc
   1153            }
   \                     ??zcl_SendCommand_4:
   \   000073   12....       LCALL     ?Subroutine25 & 0xFFFF
   1154          
   1155            if ( ( epDesc->simpleDesc == NULL ) ||
   1156                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
   1157                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_22:
   \   000076   12....       LCALL     ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   000079   602B         JZ        ??zcl_SendCommand_5
   \   00007B   741E         MOV       A,#0x1e
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   E0           MOVX      A,@DPTR
   \   000081   FE           MOV       R6,A
   \   000082                ; Setup parameters for call to function zcl_DeviceOperational
   \   000082   8882         MOV       DPL,R0
   \   000084   8983         MOV       DPH,R1
   \   000086   A3           INC       DPTR
   \   000087   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00008A   EE           MOV       A,R6
   \   00008B   FD           MOV       R5,A
   \   00008C   7402         MOV       A,#0x2
   \   00008E   12....       LCALL     ?XSTACK_DISP0_8
   \   000091   E0           MOVX      A,@DPTR
   \   000092   5403         ANL       A,#0x3
   \   000094   FC           MOV       R4,A
   \   000095   AA..         MOV       R2,?V0
   \   000097   AB..         MOV       R3,?V1
   \   000099   A9..         MOV       R1,?V10
   \   00009B   12....       LCALL     `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   00009E   7402         MOV       A,#0x2
   \   0000A0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A3   E9           MOV       A,R1
   \   0000A4   7005         JNZ       ??zcl_SendCommand_6
   1158            {
   1159              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000A6   7901         MOV       R1,#0x1
   \   0000A8   02....       LJMP      ??zcl_SendCommand_1 & 0xFFFF
   1160            }
   \                     ??zcl_SendCommand_6:
   \   0000AB   7422         MOV       A,#0x22
   \   0000AD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B0   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   1161          
   1162            // Fill in the Maufacturer Code
   1163            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_332:
   \   0000B3   6013         JZ        ??CrossCallReturnLabel_498
   1164            {
   1165              hdr.fc.manuSpecific = 1;
   \   0000B5   85..82       MOV       DPL,?XSP + 0
   \   0000B8   85..83       MOV       DPH,?XSP + 1
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   4404         ORL       A,#0x4
   \   0000BE   F0           MOVX      @DPTR,A
   1166              hdr.manuCode = manuCode;
   \   0000BF   7402         MOV       A,#0x2
   \   0000C1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C4   E8           MOV       A,R0
   \   0000C5   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   1167            }
   1168          
   1169            // Set the Command Direction
   1170            if ( direction )
   \                     ??CrossCallReturnLabel_498:
   \   0000C8   7420         MOV       A,#0x20
   \   0000CA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   0000D0   6005         JZ        ??zcl_SendCommand_7
   1171            {
   1172              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000D2   E0           MOVX      A,@DPTR
   \   0000D3   4408         ORL       A,#0x8
   \   0000D5   8003         SJMP      ??zcl_SendCommand_8
   1173            }
   1174            else
   1175            {
   1176              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000D7   E0           MOVX      A,@DPTR
   \   0000D8   54F7         ANL       A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000DA   F0           MOVX      @DPTR,A
   1177            }
   1178          
   1179            // Set the Disable Default Response field
   1180            if ( disableDefaultRsp )
   \   0000DB   7421         MOV       A,#0x21
   \   0000DD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E0   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   0000E3   6005         JZ        ??zcl_SendCommand_9
   1181            {
   1182              hdr.fc.disableDefaultRsp = 1;
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   4410         ORL       A,#0x10
   \   0000E8   8003         SJMP      ??zcl_SendCommand_10
   1183            }
   1184            else
   1185            {
   1186              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000EA   E0           MOVX      A,@DPTR
   \   0000EB   54EF         ANL       A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000ED   F0           MOVX      @DPTR,A
   1187            }
   1188          
   1189            // Fill in the Transaction Sequence Number
   1190            hdr.transSeqNum = seqNum;
   \   0000EE   7424         MOV       A,#0x24
   \   0000F0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   C0E0         PUSH      A
   \   0000F6   7404         MOV       A,#0x4
   \   0000F8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FB   D0E0         POP       A
   \   0000FD   F0           MOVX      @DPTR,A
   1191          
   1192            // Fill in the command
   1193            hdr.commandID = cmd;
   \   0000FE   7405         MOV       A,#0x5
   \   000100   12....       LCALL     ?XSTACK_DISP0_8
   \   000103   EE           MOV       A,R6
   \   000104   F0           MOVX      @DPTR,A
   1194          
   1195            // calculate the needed buffer size
   1196            msgLen = zclCalcHdrSize( &hdr );
   \   000105   7803         MOV       R0,#0x3
   \   000107   85..82       MOV       DPL,?XSP + 0
   \   00010A   85..83       MOV       DPH,?XSP + 1
   \   00010D   E0           MOVX      A,@DPTR
   \   00010E   5404         ANL       A,#0x4
   \   000110   6002         JZ        ??zcl_SendCommand_11
   \   000112   7805         MOV       R0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000114   7425         MOV       A,#0x25
   \   000116   12....       LCALL     ?XSTACK_DISP0_8
   \   000119   12....       LCALL     ?Subroutine92 & 0xFFFF
   1197            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_156:
   \   00011C   25..         ADD       A,?V8
   \   00011E   FE           MOV       R6,A
   \   00011F   E4           CLR       A
   \   000120   35..         ADDC      A,?V9
   \   000122   FF           MOV       R7,A
   1198          
   1199            // Allocate the buffer needed
   1200            msgBuf = zcl_mem_alloc( msgLen );
   \   000123                ; Setup parameters for call to function osal_mem_alloc
   \   000123   12....       LCALL     ?Subroutine107 & 0xFFFF
   1201            if ( msgBuf != NULL )
   \                     ??CrossCallReturnLabel_173:
   \   000126   6066         JZ        ??zcl_SendCommand_12
   1202            {
   1203              // Fill in the ZCL Header
   1204              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   000128                ; Setup parameters for call to function zclBuildHdr
   \   000128   AC..         MOV       R4,?V2
   \   00012A   AD..         MOV       R5,?V3
   \   00012C   AA..         MOV       R2,?XSP + 0
   \   00012E   AB..         MOV       R3,?XSP + 1
   \   000130   12....       LCALL     `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
   1205          
   1206              // Fill in the command frame
   1207              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000133                ; Setup parameters for call to function osal_memcpy
   \   000133   7427         MOV       A,#0x27
   \   000135   12....       LCALL     ?XSTACK_DISP0_8
   \   000138   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00013B   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00013E   AC..         MOV       R4,?V8
   \   000140   AD..         MOV       R5,?V9
   \   000142   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   000145   12....       LCALL     ?DEALLOC_XSTACK8
   1208          
   1209              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
   1210                                       &APS_Counter, options, zcl_radius );
   \   000148                ; Setup parameters for call to function AF_DataRequest
   \   000148   90....       MOV       DPTR,#zcl_radius
   \   00014B   E0           MOVX      A,@DPTR
   \   00014C   F5..         MOV       ?V4,A
   \   00014E   78..         MOV       R0,#?V4
   \   000150   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000153   75....       MOV       ?V4,#APS_Counter & 0xff
   \   000156   75....       MOV       ?V5,#(APS_Counter >> 8) & 0xff
   \   000159   78..         MOV       R0,#?V4
   \   00015B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00015E   78..         MOV       R0,#?V2
   \   000160   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000163   8E..         MOV       ?V4,R6
   \   000165   8F..         MOV       ?V5,R7
   \   000167   78..         MOV       R0,#?V4
   \   000169   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00016C   78..         MOV       R0,#?V0
   \   00016E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000171   A9..         MOV       R1,?V7
   \   000173   AC..         MOV       R4,?V12
   \   000175   AD..         MOV       R5,?V13
   \   000177   AA..         MOV       R2,?V14
   \   000179   AB..         MOV       R3,?V15
   \   00017B   12....       LCALL     `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   00017E   7409         MOV       A,#0x9
   \   000180   12....       LCALL     ?DEALLOC_XSTACK8
   \   000183   E9           MOV       A,R1
   \   000184   FE           MOV       R6,A
   1211              zcl_mem_free ( msgBuf );
   \   000185                ; Setup parameters for call to function osal_mem_free
   \   000185   AA..         MOV       R2,?V2
   \   000187   AB..         MOV       R3,?V3
   \   000189   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   00018C   8002         SJMP      ??zcl_SendCommand_13
   1212            }
   1213            else
   1214            {
   1215              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   00018E   7E10         MOV       R6,#0x10
   1216            }
   1217          
   1218            return ( status );
   \                     ??zcl_SendCommand_13:
   \   000190   EE           MOV       A,R6
   \   000191   F9           MOV       R1,A
   \                     ??zcl_SendCommand_1:
   \   000192   7406         MOV       A,#0x6
   \   000194   02....       LJMP      ?Subroutine5 & 0xFFFF
   1219          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   EE           MOV       A,R6
   \   000001   FA           MOV       R2,A
   \   000002   EF           MOV       A,R7
   \   000003   FB           MOV       R3,A
   \   000004   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
   \   00000B   EA           MOV       A,R2
   \   00000C   4B           ORL       A,R3
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?XSP + 0
   \   000004   85..83       MOV       DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V4,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine175_0
   \   000001                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL     ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000003   75..00       MOV       ?V6,#0x0
   \   000006   78..         MOV       R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F10         MOV       R7,#0x10
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E9           MOV       A,R1
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL     ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V12
   \   000004   85..83       MOV       DPH,?V13
   \   000007   A3           INC       DPTR
   \   000008   22           RET
   1220          
   1221          #ifdef ZCL_READ
   1222          /*********************************************************************
   1223           * @fn      zcl_SendRead
   1224           *
   1225           * @brief   Send a Read command
   1226           *
   1227           * @param   srcEP - Application's endpoint
   1228           * @param   dstAddr - destination address
   1229           * @param   clusterID - cluster ID
   1230           * @param   readCmd - read command to be sent
   1231           * @param   direction - direction of the command
   1232           * @param   seqNum - transaction sequence number
   1233           *
   1234           * @return  ZSuccess if OK
   1235           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1236          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
   1237                                  uint16 clusterID, zclReadCmd_t *readCmd,
   1238                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
   1239          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine40 & 0xFFFF
   1240            uint16 dataLen;
   1241            uint8 *buf;
   1242            uint8 *pBuf;
   1243            ZStatus_t status;
   1244          
   1245            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_43:
   \   000017   25E0         ADD       A,0xE0 /* A   */
   \   000019   F5..         MOV       ?V6,A
   \   00001B   E4           CLR       A
   \   00001C   33           RLC       A
   \   00001D   12....       LCALL     ?Subroutine102 & 0xFFFF
   1246          
   1247            buf = zcl_mem_alloc( dataLen );
   1248            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_403:
   \   000020   7003         JNZ       $+5
   \   000022   02....       LJMP      ??zcl_SendRead_0 & 0xFFFF
   1249            {
   1250              uint8 i;
   1251          
   1252              // Load the buffer - serially
   1253              pBuf = buf;
   \   000025   A8..         MOV       R0,?V0
   \   000027   A9..         MOV       R1,?V1
   1254              for (i = 0; i < readCmd->numAttr; i++)
   \   000029   7C00         MOV       R4,#0x0
   \   00002B   801D         SJMP      ??zcl_SendRead_1
   1255              {
   1256                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   00002D   EC           MOV       A,R4
   \   00002E   25E0         ADD       A,0xE0 /* A   */
   \   000030   FA           MOV       R2,A
   \   000031   E4           CLR       A
   \   000032   33           RLC       A
   \   000033   FB           MOV       R3,A
   \   000034   12....       LCALL     ?Subroutine143 & 0xFFFF
   1257                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   1258              }
   \                     ??CrossCallReturnLabel_232:
   \   000037   AA82         MOV       R2,DPL
   \   000039   AB83         MOV       R3,DPH
   \   00003B   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   00003E   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000041   F0           MOVX      @DPTR,A
   \   000042   E8           MOV       A,R0
   \   000043   2402         ADD       A,#0x2
   \   000045   F8           MOV       R0,A
   \   000046   5001         JNC       ??zcl_SendRead_3
   \   000048   09           INC       R1
   \                     ??zcl_SendRead_3:
   \   000049   0C           INC       R4
   \                     ??zcl_SendRead_1:
   \   00004A   85..82       MOV       DPL,?V4
   \   00004D   85..83       MOV       DPH,?V5
   \   000050   E0           MOVX      A,@DPTR
   \   000051   FA           MOV       R2,A
   \   000052   EC           MOV       A,R4
   \   000053   C3           CLR       C
   \   000054   9A           SUBB      A,R2
   \   000055   40D6         JC        ??zcl_SendRead_2
   1259          
   1260              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
   1261                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000057                ; Setup parameters for call to function zcl_SendCommand
   \   000057   78..         MOV       R0,#?V0
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   78..         MOV       R0,#?V6
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000061   741C         MOV       A,#0x1c
   \   000063   12....       LCALL     ?XSTACK_DISP0_8
   \   000066   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006C   E4           CLR       A
   \   00006D   F5..         MOV       ?V4,A
   \   00006F   F5..         MOV       ?V5,A
   \   000071   78..         MOV       R0,#?V4
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000076   741E         MOV       A,#0x1e
   \   000078   12....       LCALL     ?XSTACK_DISP0_8
   \   00007B   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000081   741E         MOV       A,#0x1e
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000089   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008C   75..00       MOV       ?V3,#0x0
   \   00008F   78..         MOV       R0,#?V3
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000094   78..         MOV       R0,#?V3
   \   000096   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000099   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   00009C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00009F   E9           MOV       A,R1
   \   0000A0   FE           MOV       R6,A
   1262              zcl_mem_free( buf );
   \   0000A1                ; Setup parameters for call to function osal_mem_free
   \   0000A1   AA..         MOV       R2,?V0
   \   0000A3   AB..         MOV       R3,?V1
   \   0000A5   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000A8   8002         SJMP      ??zcl_SendRead_4
   1263            }
   1264            else
   1265            {
   1266              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000AA   7E10         MOV       R6,#0x10
   1267            }
   1268          
   1269            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000AC   02....       LJMP      ?Subroutine6 & 0xFFFF
   1270          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V3,A
   \   000003   78..         MOV       R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL     ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000003   85..82       MOV       DPL,?V4
   \   000006   F583         MOV       DPH,A
   \   000008   E0           MOVX      A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL     ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000003   12....       LCALL     ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   EE           MOV       A,R6
   \   000001   F9           MOV       R1,A
   \   000002                REQUIRE ??Subroutine158_0
   \   000002                ; // Fall through to label ??Subroutine158_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine158_0:
   \   000000   7F0C         MOV       R7,#0xc
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   EE           MOV       A,R6
   \   000001   FC           MOV       R4,A
   \   000002   EF           MOV       A,R7
   \   000003   FD           MOV       R5,A
   \   000004   AA..         MOV       R2,?V8
   \   000006   AB..         MOV       R3,?V9
   \   000008   A9..         MOV       R1,?V2
   \   00000A                REQUIRE ??Subroutine162_0
   \   00000A                ; // Fall through to label ??Subroutine162_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   E5..         MOV       A,?V4
   \   000002   2A           ADD       A,R2
   \   000003   F582         MOV       DPL,A
   \   000005   E5..         MOV       A,?V5
   \   000007   3B           ADDC      A,R3
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   F5..         MOV       ?V7,A
   \   000002                ; Setup parameters for call to function osal_mem_alloc
   \   000002                ; Setup parameters for call to function osal_mem_alloc
   \   000002   AA..         MOV       R2,?V6
   \   000004                REQUIRE ??Subroutine184_0
   \   000004                ; // Fall through to label ??Subroutine184_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine185_0
   \   000001                ; // Fall through to label ??Subroutine185_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000003   8A..         MOV       ?V0,R2
   \   000005   8B..         MOV       ?V1,R3
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   22           RET
   1271          
   1272          /*********************************************************************
   1273           * @fn      zcl_SendReadRsp
   1274           *
   1275           * @brief   Send a Read Response command.
   1276           *
   1277           * @param   srcEP - Application's endpoint
   1278           * @param   dstAddr - destination address
   1279           * @param   clusterID - cluster ID
   1280           * @param   readRspCmd - read response command to be sent
   1281           * @param   direction - direction of the command
   1282           * @param   seqNum - transaction sequence number
   1283           *
   1284           * @return  ZSuccess if OK
   1285           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1286          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1287                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1288                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1289          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V3,R1
   \   00000C   8A..         MOV       ?V12,R2
   \   00000E   8B..         MOV       ?V13,R3
   \   000010   8C..         MOV       ?V6,R4
   \   000012   8D..         MOV       ?V7,R5
   1290            uint8 *buf;
   1291            uint16 len = 0;
   \   000014   7E00         MOV       R6,#0x0
   \   000016   7F00         MOV       R7,#0x0
   1292            ZStatus_t status;
   1293            uint8 i;
   1294          
   1295            // calculate the size of the command
   1296            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   75..00       MOV       ?V2,#0x0
   \   00001B   7418         MOV       A,#0x18
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   000023   8011         SJMP      ??zcl_SendReadRsp_0
   1297            {
   1298              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1299          
   1300              len += 2 + 1; // Attribute ID + Status
   1301          
   1302              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1303              {
   1304                len++; // Attribute Data Type length
   1305          
   1306                // Attribute Data length
   1307                if ( statusRec->data != NULL )
   1308                {
   1309                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1310                }
   1311                else
   1312                {
   1313                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000025                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000025   12....       LCALL     ?Subroutine66 & 0xFFFF
   1314                }
   \                     ??CrossCallReturnLabel_107:
   \   000028   12....       LCALL     `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002B   8B..         MOV       ?V1,R3
   \   00002D   EE           MOV       A,R6
   \   00002E   2A           ADD       A,R2
   \   00002F   FE           MOV       R6,A
   \   000030   EF           MOV       A,R7
   \   000031   35..         ADDC      A,?V1
   \   000033   FF           MOV       R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000034   05..         INC       ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000036   12....       LCALL     ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000039   502E         JNC       ??zcl_SendReadRsp_4
   \   00003B   E5..         MOV       A,?V2
   \   00003D   75F006       MOV       B,#0x6
   \   000040   12....       LCALL     ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000043   2403         ADD       A,#0x3
   \   000045   FE           MOV       R6,A
   \   000046   E4           CLR       A
   \   000047   3F           ADDC      A,R7
   \   000048   FF           MOV       R7,A
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   70E6         JNZ       ??zcl_SendReadRsp_3
   \   00004E   0E           INC       R6
   \   00004F   EE           MOV       A,R6
   \   000050   7001         JNZ       ??zcl_SendReadRsp_5
   \   000052   0F           INC       R7
   \                     ??zcl_SendReadRsp_5:
   \   000053   8882         MOV       DPL,R0
   \   000055   8983         MOV       DPH,R1
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   00005E   8882         MOV       DPL,R0
   \   000060   8983         MOV       DPH,R1
   \   000062   60C1         JZ        ??zcl_SendReadRsp_1
   \   000064                ; Setup parameters for call to function zclGetAttrDataLength
   \   000064   12....       LCALL     ??Subroutine156_0 & 0xFFFF
   1315              }
   1316            }
   \                     ??CrossCallReturnLabel_265:
   \   000067   80C2         SJMP      ??zcl_SendReadRsp_2
   1317          
   1318            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   000069                ; Setup parameters for call to function osal_mem_alloc
   \   000069   EE           MOV       A,R6
   \   00006A   FA           MOV       R2,A
   \   00006B   EF           MOV       A,R7
   \   00006C   FB           MOV       R3,A
   \   00006D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000070   8A..         MOV       ?V0,R2
   \   000072   8B..         MOV       ?V1,R3
   \   000074   8A..         MOV       ?V4,R2
   \   000076   8B..         MOV       ?V5,R3
   1319            if ( buf != NULL )
   \   000078   EA           MOV       A,R2
   \   000079   4B           ORL       A,R3
   \   00007A   7003         JNZ       $+5
   \   00007C   02....       LJMP      ??zcl_SendReadRsp_6 & 0xFFFF
   1320            {
   1321              // Load the buffer - serially
   1322              uint8 *pBuf = buf;
   1323          
   1324              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   00007F   75..00       MOV       ?V2,#0x0
   \   000082   8030         SJMP      ??zcl_SendReadRsp_7
   1325              {
   1326                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1327          
   1328                *pBuf++ = LO_UINT16( statusRec->attrID );
   1329                *pBuf++ = HI_UINT16( statusRec->attrID );
   1330                *pBuf++ = statusRec->status;
   1331          
   1332                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1333                {
   1334                  *pBuf++ = statusRec->dataType;
   1335          
   1336                  if ( statusRec->data != NULL )
   1337                  {
   1338                    // Copy attribute data to the buffer to be sent out
   1339                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1340                  }
   1341                  else
   1342                  {
   1343                    uint16 dataLen;
   1344          
   1345                    // Read attribute data directly into the buffer to be sent out
   1346                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   000084                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000084   A8..         MOV       R0,?XSP + 0
   \   000086   A9..         MOV       R1,?XSP + 1
   \   000088   88..         MOV       ?V10,R0
   \   00008A   89..         MOV       ?V11,R1
   \   00008C   78..         MOV       R0,#?V10
   \   00008E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000091   78..         MOV       R0,#?V0
   \   000093   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000096   8A82         MOV       DPL,R2
   \   000098   8B83         MOV       DPH,R3
   \   00009A   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   00009D   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   0000A0   7404         MOV       A,#0x4
   \   0000A2   12....       LCALL     ?DEALLOC_XSTACK8
   1347                    pBuf += dataLen;
   \   0000A5   12....       LCALL     ?Subroutine80 & 0xFFFF
   1348                  }
   \                     ??CrossCallReturnLabel_415:
   \   0000A8   E5..         MOV       A,?V0
   \   0000AA   28           ADD       A,R0
   \   0000AB   F5..         MOV       ?V0,A
   \   0000AD   E5..         MOV       A,?V1
   \   0000AF   39           ADDC      A,R1
   \   0000B0   F5..         MOV       ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000B2   05..         INC       ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000B4   12....       LCALL     ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   0000B7   5071         JNC       ??zcl_SendReadRsp_10
   \   0000B9   E5..         MOV       A,?V2
   \   0000BB   75F006       MOV       B,#0x6
   \   0000BE   12....       LCALL     ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   0000C1   12....       LCALL     ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   0000C4   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   0000C7   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000CA   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   0000CD   A3           INC       DPTR
   \   0000CE   F0           MOVX      @DPTR,A
   \   0000CF   12....       LCALL     ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   0000D2   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   0000D5   F0           MOVX      @DPTR,A
   \   0000D6   E5..         MOV       A,?V0
   \   0000D8   2403         ADD       A,#0x3
   \   0000DA   F5..         MOV       ?V0,A
   \   0000DC   5002         JNC       ??zcl_SendReadRsp_11
   \   0000DE   05..         INC       ?V1
   \                     ??zcl_SendReadRsp_11:
   \   0000E0   8882         MOV       DPL,R0
   \   0000E2   8983         MOV       DPH,R1
   \   0000E4   E0           MOVX      A,@DPTR
   \   0000E5   70CB         JNZ       ??zcl_SendReadRsp_9
   \   0000E7   EA           MOV       A,R2
   \   0000E8   2403         ADD       A,#0x3
   \   0000EA   08           INC       R0
   \   0000EB   E4           CLR       A
   \   0000EC   3B           ADDC      A,R3
   \   0000ED   F9           MOV       R1,A
   \   0000EE   8882         MOV       DPL,R0
   \   0000F0   F583         MOV       DPH,A
   \   0000F2   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   0000F5   F0           MOVX      @DPTR,A
   \   0000F6   A3           INC       DPTR
   \   0000F7   8582..       MOV       ?V0,DPL
   \   0000FA   8583..       MOV       ?V1,DPH
   \   0000FD   8A82         MOV       DPL,R2
   \   0000FF   8B83         MOV       DPH,R3
   \   000101   A3           INC       DPTR
   \   000102   A3           INC       DPTR
   \   000103   A3           INC       DPTR
   \   000104   A3           INC       DPTR
   \   000105   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000108   8C82         MOV       DPL,R4
   \   00010A   F583         MOV       DPH,A
   \   00010C   E582         MOV       A,DPL
   \   00010E   4583         ORL       A,DPH
   \   000110   7003         JNZ       $+5
   \   000112   02....       LJMP      ??zcl_SendReadRsp_8 & 0xFFFF
   \   000115                ; Setup parameters for call to function zclSerializeData
   \   000115   AC..         MOV       R4,?V0
   \   000117   AD..         MOV       R5,?V1
   \   000119   AA82         MOV       R2,DPL
   \   00011B   AB83         MOV       R3,DPH
   \   00011D   8882         MOV       DPL,R0
   \   00011F   8983         MOV       DPH,R1
   \   000121   12....       LCALL     ??Subroutine160_0 & 0xFFFF
   1349                }
   1350              } // for loop
   \                     ??CrossCallReturnLabel_273:
   \   000124   8A..         MOV       ?V0,R2
   \   000126   8B..         MOV       ?V1,R3
   \   000128   8088         SJMP      ??zcl_SendReadRsp_9
   1351          
   1352              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1353                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   00012A                ; Setup parameters for call to function zcl_SendCommand
   \   00012A   78..         MOV       R0,#?V4
   \   00012C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00012F   8E..         MOV       ?V0,R6
   \   000131   8F..         MOV       ?V1,R7
   \   000133   78..         MOV       R0,#?V0
   \   000135   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000138   7420         MOV       A,#0x20
   \   00013A   12....       LCALL     ?XSTACK_DISP0_8
   \   00013D   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000140   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000143   E4           CLR       A
   \   000144   F5..         MOV       ?V0,A
   \   000146   F5..         MOV       ?V1,A
   \   000148   78..         MOV       R0,#?V0
   \   00014A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014D   7422         MOV       A,#0x22
   \   00014F   12....       LCALL     ?XSTACK_DISP0_8
   \   000152   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000155   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000158   7422         MOV       A,#0x22
   \   00015A   12....       LCALL     ?XSTACK_DISP0_8
   \   00015D   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000160   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000163   75..00       MOV       ?V0,#0x0
   \   000166   78..         MOV       R0,#?V0
   \   000168   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00016B   75..01       MOV       ?V0,#0x1
   \   00016E   78..         MOV       R0,#?V0
   \   000170   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000173   AC..         MOV       R4,?V6
   \   000175   AD..         MOV       R5,?V7
   \   000177   AA..         MOV       R2,?V12
   \   000179   AB..         MOV       R3,?V13
   \   00017B   A9..         MOV       R1,?V3
   \   00017D   12....       LCALL     ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000180   12....       LCALL     ?DEALLOC_XSTACK8
   \   000183   E9           MOV       A,R1
   \   000184   FE           MOV       R6,A
   1354              zcl_mem_free( buf );
   \   000185                ; Setup parameters for call to function osal_mem_free
   \   000185   AA..         MOV       R2,?V4
   \   000187   AB..         MOV       R3,?V5
   \   000189   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   00018C   8002         SJMP      ??zcl_SendReadRsp_12
   1355            }
   1356            else
   1357            {
   1358              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   00018E   7E10         MOV       R6,#0x10
   1359            }
   1360          
   1361            return ( status );
   \                     ??zcl_SendReadRsp_12:
   \   000190   EE           MOV       A,R6
   \   000191   F9           MOV       R1,A
   \   000192   02....       LJMP      ?Subroutine7 & 0xFFFF
   1362          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL     ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_493:
   \   000003   AA..         MOV       R2,?V6
   \   000005   AB..         MOV       R3,?V7
   \   000007   A9..         MOV       R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine156_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine157_0
   \   000003                ; // Fall through to label ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine157_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine160_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002   12....       LCALL     `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   12....       LCALL     ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000003   12....       LCALL     ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000006   EE           MOV       A,R6
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   A4           MUL       AB
   \   000001   F8           MOV       R0,A
   \   000002   A9F0         MOV       R1,B
   \   000004   E5..         MOV       A,?V8
   \   000006   28           ADD       A,R0
   \   000007   F582         MOV       DPL,A
   \   000009   E5..         MOV       A,?V9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   A882         MOV       R0,DPL
   \   000005   A983         MOV       R1,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7402         MOV       A,#0x2
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine164_0
   \   000005                ; // Fall through to label ??Subroutine164_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine164_0:
   \   000000   7F0E         MOV       R7,#0xe
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   EA           MOV       A,R2
   \   000001   2402         ADD       A,#0x2
   \   000003   F8           MOV       R0,A
   \   000004   E4           CLR       A
   \   000005   3B           ADDC      A,R3
   \   000006   F9           MOV       R1,A
   \   000007   8882         MOV       DPL,R0
   \   000009   F583         MOV       DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   39           ADDC      A,R1
   \   000001   F583         MOV       DPH,A
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000003   AA82         MOV       R2,DPL
   \   000005   AB83         MOV       R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine186_0
   \   000006                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   85..82       MOV       DPL,?V8
   \   000003   85..83       MOV       DPH,?V9
   \   000006                REQUIRE ??Subroutine189_0
   \   000006                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   E5..         MOV       A,?V2
   \   000004   C3           CLR       C
   \   000005   98           SUBB      A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V8,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V9,A
   \   000007   22           RET
   1363          #endif // ZCL_READ
   1364          
   1365          #ifdef ZCL_WRITE
   1366          /*********************************************************************
   1367           * @fn      sendWriteRequest
   1368           *
   1369           * @brief   Send a Write command
   1370           *
   1371           * @param   dstAddr - destination address
   1372           * @param   clusterID - cluster ID
   1373           * @param   writeCmd - write command to be sent
   1374           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1375           * @param   direction - direction of the command
   1376           * @param   seqNum - transaction sequence number
   1377           *
   1378           * @return  ZSuccess if OK
   1379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1380          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1381                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1382                                          uint8 disableDefaultRsp, uint8 seqNum )
   1383          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V3,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   8C..         MOV       ?V6,R4
   \   00000D   8D..         MOV       ?V7,R5
   1384            uint8 *buf;
   1385            uint16 dataLen = 0;
   \   00000F   7E00         MOV       R6,#0x0
   \   000011   7F00         MOV       R7,#0x0
   1386            ZStatus_t status;
   1387            uint8 i;
   1388          
   1389            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   75..00       MOV       ?V2,#0x0
   \   000016   7416         MOV       A,#0x16
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   00001E   8003         SJMP      ??CrossCallReturnLabel_39
   1390            {
   1391              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000020   12....       LCALL     ?Subroutine38 & 0xFFFF
   1392          
   1393              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1394          
   1395              // Attribute Data
   1396              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1397            }
   \                     ??CrossCallReturnLabel_39:
   \   000023   85..82       MOV       DPL,?V4
   \   000026   85..83       MOV       DPH,?V5
   \   000029   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   00002C   40F2         JC        ??zcl_SendWriteRequest_0
   1398          
   1399            buf = zcl_mem_alloc( dataLen );
   \   00002E                ; Setup parameters for call to function osal_mem_alloc
   \   00002E   EE           MOV       A,R6
   \   00002F   FA           MOV       R2,A
   \   000030   EF           MOV       A,R7
   \   000031   12....       LCALL     ??Subroutine184_0 & 0xFFFF
   1400            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_405:
   \   000034   7003         JNZ       $+5
   \   000036   02....       LJMP      ??zcl_SendWriteRequest_1 & 0xFFFF
   1401            {
   1402              // Load the buffer - serially
   1403              uint8 *pBuf = buf;
   \   000039   A8..         MOV       R0,?V0
   \   00003B   A9..         MOV       R1,?V1
   1404              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00003D   75..00       MOV       ?V2,#0x0
   \   000040   8003         SJMP      ??CrossCallReturnLabel_0
   1405              {
   1406                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_2:
   \   000042   12....       LCALL     ?Subroutine12 & 0xFFFF
   1407          
   1408                *pBuf++ = LO_UINT16( statusRec->attrID );
   1409                *pBuf++ = HI_UINT16( statusRec->attrID );
   1410                *pBuf++ = statusRec->dataType;
   1411          
   1412                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1413              }
   \                     ??CrossCallReturnLabel_0:
   \   000045   85..82       MOV       DPL,?V4
   \   000048   85..83       MOV       DPH,?V5
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   FA           MOV       R2,A
   \   00004D   E5..         MOV       A,?V2
   \   00004F   C3           CLR       C
   \   000050   9A           SUBB      A,R2
   \   000051   40EF         JC        ??zcl_SendWriteRequest_2
   1414          
   1415              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1416                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000053                ; Setup parameters for call to function zcl_SendCommand
   \   000053   78..         MOV       R0,#?V0
   \   000055   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000058   8E..         MOV       ?V4,R6
   \   00005A   8F..         MOV       ?V5,R7
   \   00005C   78..         MOV       R0,#?V4
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000061   741F         MOV       A,#0x1f
   \   000063   12....       LCALL     ?XSTACK_DISP0_8
   \   000066   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006C   E4           CLR       A
   \   00006D   F5..         MOV       ?V4,A
   \   00006F   F5..         MOV       ?V5,A
   \   000071   78..         MOV       R0,#?V4
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000076   7421         MOV       A,#0x21
   \   000078   12....       LCALL     ?XSTACK_DISP0_8
   \   00007B   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_443:
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000081   7421         MOV       A,#0x21
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_444:
   \   000089   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008C   75..00       MOV       ?V2,#0x0
   \   00008F   78..         MOV       R0,#?V2
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000094   7422         MOV       A,#0x22
   \   000096   12....       LCALL     ?XSTACK_DISP0_8
   \   000099   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_445:
   \   00009C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009F   AC..         MOV       R4,?V6
   \   0000A1   AD..         MOV       R5,?V7
   \   0000A3   AA..         MOV       R2,?V8
   \   0000A5   AB..         MOV       R3,?V9
   \   0000A7   A9..         MOV       R1,?V3
   \   0000A9   12....       LCALL     ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   0000AC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000AF   E9           MOV       A,R1
   \   0000B0   FE           MOV       R6,A
   1417              zcl_mem_free( buf );
   \   0000B1                ; Setup parameters for call to function osal_mem_free
   \   0000B1   AA..         MOV       R2,?V0
   \   0000B3   AB..         MOV       R3,?V1
   \   0000B5   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000B8   8002         SJMP      ??zcl_SendWriteRequest_3
   1418            }
   1419            else
   1420            {
   1421              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000BA   7E10         MOV       R6,#0x10
   1422            }
   1423          
   1424            return ( status);
   \                     ??zcl_SendWriteRequest_3:
   \   0000BC                REQUIRE ?Subroutine11
   \   0000BC                ; // Fall through to label ?Subroutine11
   1425          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   EE           MOV       A,R6
   \   000001   F9           MOV       R1,A
   \   000002   02....       LJMP      ??Subroutine164_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   85..82       MOV       DPL,?V10
   \   000003   85..83       MOV       DPH,?V11
   \   000006                REQUIRE ??Subroutine160_0
   \   000006                ; // Fall through to label ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   E5..         MOV       A,?V2
   \   000002   75F005       MOV       B,#0x5
   \   000005   A4           MUL       AB
   \   000006   F8           MOV       R0,A
   \   000007   A9F0         MOV       R1,B
   \   000009   E5..         MOV       A,?V4
   \   00000B   28           ADD       A,R0
   \   00000C   F582         MOV       DPL,A
   \   00000E   E5..         MOV       A,?V5
   \   000010   12....       LCALL     ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000013                ; Setup parameters for call to function zclGetAttrDataLength
   \   000013                ; Setup parameters for call to function zclGetAttrDataLength
   \   000013   12....       LCALL     ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_491:
   \   000016   8882         MOV       DPL,R0
   \   000018   8983         MOV       DPH,R1
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F9           MOV       R1,A
   \   00001E   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000021   8B..         MOV       ?V1,R3
   \   000023   EA           MOV       A,R2
   \   000024   2403         ADD       A,#0x3
   \   000026   F8           MOV       R0,A
   \   000027   E4           CLR       A
   \   000028   35..         ADDC      A,?V1
   \   00002A   F9           MOV       R1,A
   \   00002B   EE           MOV       A,R6
   \   00002C   28           ADD       A,R0
   \   00002D   FE           MOV       R6,A
   \   00002E   EF           MOV       A,R7
   \   00002F   39           ADDC      A,R1
   \   000030   FF           MOV       R7,A
   \   000031   05..         INC       ?V2
   \   000033   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine163_0
   \   000003                ; // Fall through to label ??Subroutine163_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E5..         MOV       A,?V2
   \   000002   75F005       MOV       B,#0x5
   \   000005   A4           MUL       AB
   \   000006   FA           MOV       R2,A
   \   000007   ABF0         MOV       R3,B
   \   000009   12....       LCALL     ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00000C   8582..       MOV       ?V12,DPL
   \   00000F   8583..       MOV       ?V13,DPH
   \   000012   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000015   12....       LCALL     ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000018   12....       LCALL     ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   E5..         MOV       A,?V12
   \   00001E   2402         ADD       A,#0x2
   \   000020   FA           MOV       R2,A
   \   000021   E4           CLR       A
   \   000022   35..         ADDC      A,?V13
   \   000024   8A..         MOV       ?V10,R2
   \   000026   F5..         MOV       ?V11,A
   \   000028   8A82         MOV       DPL,R2
   \   00002A   F583         MOV       DPH,A
   \   00002C   12....       LCALL     ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   00002F   A3           INC       DPTR
   \   000030   F0           MOVX      @DPTR,A
   \   000031                ; Setup parameters for call to function zclSerializeData
   \   000031                ; Setup parameters for call to function zclSerializeData
   \   000031   E8           MOV       A,R0
   \   000032   2403         ADD       A,#0x3
   \   000034   FC           MOV       R4,A
   \   000035   E4           CLR       A
   \   000036   39           ADDC      A,R1
   \   000037   FD           MOV       R5,A
   \   000038   85..82       MOV       DPL,?V12
   \   00003B   85..83       MOV       DPH,?V13
   \   00003E   12....       LCALL     ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_490:
   \   000041   12....       LCALL     ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000044   8A..         MOV       ?V10,R2
   \   000046   8B..         MOV       ?V11,R3
   \   000048   A8..         MOV       R0,?V10
   \   00004A   A9..         MOV       R1,?V11
   \   00004C   05..         INC       ?V2
   \   00004E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   12....       LCALL     ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V2,A
   \   000003   78..         MOV       R0,#?V2
   \   000005   22           RET
   1426          
   1427          /*********************************************************************
   1428           * @fn      zcl_SendWriteRsp
   1429           *
   1430           * @brief   Send a Write Response command
   1431           *
   1432           * @param   dstAddr - destination address
   1433           * @param   clusterID - cluster ID
   1434           * @param   wrtieRspCmd - write response command to be sent
   1435           * @param   direction - direction of the command
   1436           * @param   seqNum - transaction sequence number
   1437           *
   1438           * @return  ZSuccess if OK
   1439           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1440          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1441                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1442                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1443          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine40 & 0xFFFF
   1444            uint16 dataLen;
   1445            uint8 *buf;
   1446            ZStatus_t status;
   1447          
   1448            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \                     ??CrossCallReturnLabel_44:
   \   000017   75F003       MOV       B,#0x3
   \   00001A   A4           MUL       AB
   \   00001B   F5..         MOV       ?V6,A
   \   00001D   E5F0         MOV       A,B
   \   00001F   12....       LCALL     ?Subroutine102 & 0xFFFF
   1449          
   1450            buf = zcl_mem_alloc( dataLen );
   1451            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_404:
   \   000022   7003         JNZ       $+5
   \   000024   02....       LJMP      ??zcl_SendWriteRsp_0 & 0xFFFF
   1452            {
   1453              // Load the buffer - serially
   1454              uint8 i;
   1455              uint8 *pBuf = buf;
   \   000027   A8..         MOV       R0,?V0
   \   000029   A9..         MOV       R1,?V1
   1456              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00002B   7C00         MOV       R4,#0x0
   \   00002D   8033         SJMP      ??zcl_SendWriteRsp_1
   1457              {
   1458                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_2:
   \   00002F   EC           MOV       A,R4
   \   000030   75F003       MOV       B,#0x3
   \   000033   A4           MUL       AB
   \   000034   FA           MOV       R2,A
   \   000035   ABF0         MOV       R3,B
   \   000037   E5..         MOV       A,?V4
   \   000039   2A           ADD       A,R2
   \   00003A   FA           MOV       R2,A
   \   00003B   E5..         MOV       A,?V5
   \   00003D   3B           ADDC      A,R3
   \   00003E   FB           MOV       R3,A
   \   00003F   8A82         MOV       DPL,R2
   \   000041   F583         MOV       DPH,A
   \   000043   A3           INC       DPTR
   \   000044   12....       LCALL     ?Subroutine82 & 0xFFFF
   1459                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_135:
   \   000047   EA           MOV       A,R2
   \   000048   2402         ADD       A,#0x2
   \   00004A   FA           MOV       R2,A
   \   00004B   5001         JNC       ??zcl_SendWriteRsp_3
   \   00004D   0B           INC       R3
   \                     ??zcl_SendWriteRsp_3:
   \   00004E   F582         MOV       DPL,A
   \   000050   8B83         MOV       DPH,R3
   \   000052   12....       LCALL     ?Subroutine127 & 0xFFFF
   1460                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1461              }
   \                     ??CrossCallReturnLabel_206:
   \   000055   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000058   A3           INC       DPTR
   \   000059   F0           MOVX      @DPTR,A
   \   00005A   E8           MOV       A,R0
   \   00005B   2403         ADD       A,#0x3
   \   00005D   F8           MOV       R0,A
   \   00005E   5001         JNC       ??zcl_SendWriteRsp_4
   \   000060   09           INC       R1
   \                     ??zcl_SendWriteRsp_4:
   \   000061   0C           INC       R4
   \                     ??zcl_SendWriteRsp_1:
   \   000062   85..82       MOV       DPL,?V4
   \   000065   85..83       MOV       DPH,?V5
   \   000068   E0           MOVX      A,@DPTR
   \   000069   FA           MOV       R2,A
   \   00006A   EC           MOV       A,R4
   \   00006B   C3           CLR       C
   \   00006C   9A           SUBB      A,R2
   \   00006D   40C0         JC        ??zcl_SendWriteRsp_2
   1462          
   1463              // If there's only a single status record and its status field is set to
   1464              // SUCCESS then omit the attribute ID field.
   1465              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00006F   7401         MOV       A,#0x1
   \   000071   6A           XRL       A,R2
   \   000072   700A         JNZ       ??zcl_SendWriteRsp_5
   \   000074   A3           INC       DPTR
   \   000075   E0           MOVX      A,@DPTR
   \   000076   7006         JNZ       ??zcl_SendWriteRsp_5
   1466              {
   1467                dataLen = 1;
   \   000078   75..01       MOV       ?V6,#0x1
   \   00007B   75..00       MOV       ?V7,#0x0
   1468              }
   1469          
   1470              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1471                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_5:
   \   00007E                ; Setup parameters for call to function zcl_SendCommand
   \   00007E   78..         MOV       R0,#?V0
   \   000080   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000083   78..         MOV       R0,#?V6
   \   000085   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000088   741C         MOV       A,#0x1c
   \   00008A   12....       LCALL     ?XSTACK_DISP0_8
   \   00008D   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000090   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000093   E4           CLR       A
   \   000094   F5..         MOV       ?V4,A
   \   000096   F5..         MOV       ?V5,A
   \   000098   78..         MOV       R0,#?V4
   \   00009A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009D   741E         MOV       A,#0x1e
   \   00009F   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A2   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0000A5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A8   741E         MOV       A,#0x1e
   \   0000AA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AD   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   0000B0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B3   75..00       MOV       ?V3,#0x0
   \   0000B6   78..         MOV       R0,#?V3
   \   0000B8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000BB   75..04       MOV       ?V3,#0x4
   \   0000BE   78..         MOV       R0,#?V3
   \   0000C0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C3   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   0000C6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C9   E9           MOV       A,R1
   \   0000CA   FE           MOV       R6,A
   1472              zcl_mem_free( buf );
   \   0000CB                ; Setup parameters for call to function osal_mem_free
   \   0000CB   AA..         MOV       R2,?V0
   \   0000CD   AB..         MOV       R3,?V1
   \   0000CF   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D2   8002         SJMP      ??zcl_SendWriteRsp_6
   1473            }
   1474            else
   1475            {
   1476              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000D4   7E10         MOV       R6,#0x10
   1477            }
   1478          
   1479            return ( status );
   \                     ??zcl_SendWriteRsp_6:
   \   0000D6   02....       LJMP      ?Subroutine6 & 0xFFFF
   1480          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET
   1481          #endif // ZCL_WRITE
   1482          
   1483          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1484          /*********************************************************************
   1485           * @fn      zcl_SendConfigReportCmd
   1486           *
   1487           * @brief   Send a Configure Reporting command
   1488           *
   1489           * @param   dstAddr - destination address
   1490           * @param   clusterID - cluster ID
   1491           * @param   cfgReportCmd - configure reporting command to be sent
   1492           * @param   direction - direction of the command
   1493           * @param   seqNum - transaction sequence number
   1494           *
   1495           * @return  ZSuccess if OK
   1496           */
   1497          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1498                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1499                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1500          {
   1501            uint8 *buf;
   1502            uint16 dataLen = 0;
   1503            ZStatus_t status;
   1504            uint8 i;
   1505          
   1506            // Find out the data length
   1507            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1508            {
   1509              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1510          
   1511              dataLen += 1 + 2; // Direction + Attribute ID
   1512          
   1513              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1514              {
   1515                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1516          
   1517                // Find out the size of the Reportable Change field (for Analog data types)
   1518                if ( zclAnalogDataType( reportRec->dataType ) )
   1519                {
   1520                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1521                }
   1522              }
   1523              else
   1524              {
   1525                dataLen += 2; // Timeout Period
   1526              }
   1527            }
   1528          
   1529            buf = zcl_mem_alloc( dataLen );
   1530            if ( buf != NULL )
   1531            {
   1532              // Load the buffer - serially
   1533              uint8 *pBuf = buf;
   1534          
   1535              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1536              {
   1537                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1538          
   1539                *pBuf++ = reportRec->direction;
   1540                *pBuf++ = LO_UINT16( reportRec->attrID );
   1541                *pBuf++ = HI_UINT16( reportRec->attrID );
   1542          
   1543                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1544                {
   1545                  *pBuf++ = reportRec->dataType;
   1546                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1547                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1548                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1549                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1550          
   1551                  if ( zclAnalogDataType( reportRec->dataType ) )
   1552                  {
   1553                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1554                  }
   1555                }
   1556                else
   1557                {
   1558                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1559                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1560                }
   1561              } // for loop
   1562          
   1563              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1564                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1565              zcl_mem_free( buf );
   1566            }
   1567            else
   1568            {
   1569              status = ZMemError;
   1570            }
   1571          
   1572            return ( status );
   1573          }
   1574          #endif
   1575          
   1576          #ifdef ZCL_REPORTING_DEVICE
   1577          /*********************************************************************
   1578           * @fn      zcl_SendConfigReportRspCmd
   1579           *
   1580           * @brief   Send a Configure Reporting Response command
   1581           *
   1582           * @param   dstAddr - destination address
   1583           * @param   clusterID - cluster ID
   1584           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1585           * @param   direction - direction of the command
   1586           * @param   seqNum - transaction sequence number
   1587           *
   1588           * @return  ZSuccess if OK
   1589           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1590          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1591                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1592                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1593          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine40 & 0xFFFF
   1594            uint16 dataLen;
   1595            uint8 *buf;
   1596            ZStatus_t status;
   1597          
   1598            // Atrribute list (Status, Direction and Attribute ID)
   1599            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_45:
   \   000017   F5..         MOV       ?V0,A
   \   000019   75..00       MOV       ?V1,#0x0
   \   00001C   7402         MOV       A,#0x2
   \   00001E   78..         MOV       R0,#?V0
   \   000020   12....       LCALL     ?S_SHL
   \   000023   85....       MOV       ?V6,?V0
   \   000026   85....       MOV       ?V7,?V1
   1600          
   1601            buf = zcl_mem_alloc( dataLen );
   \   000029                ; Setup parameters for call to function osal_mem_alloc
   \   000029   AA..         MOV       R2,?V6
   \   00002B   AB..         MOV       R3,?V7
   \   00002D   12....       LCALL     ??Subroutine185_0 & 0xFFFF
   1602            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_408:
   \   000030   7003         JNZ       $+5
   \   000032   02....       LJMP      ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1603            {
   1604              // Load the buffer - serially
   1605              uint8 *pBuf = buf;
   1606              uint8 i;
   1607          
   1608              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000035   7900         MOV       R1,#0x0
   \   000037   804A         SJMP      ??zcl_SendConfigReportRspCmd_1
   1609              {
   1610                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   000039   E9           MOV       A,R1
   \   00003A   F5..         MOV       ?V10,A
   \   00003C   75..00       MOV       ?V11,#0x0
   \   00003F   7402         MOV       A,#0x2
   \   000041   78..         MOV       R0,#?V10
   \   000043   12....       LCALL     ?S_SHL
   \   000046   E5..         MOV       A,?V4
   \   000048   25..         ADD       A,?V10
   \   00004A   FC           MOV       R4,A
   \   00004B   E5..         MOV       A,?V5
   \   00004D   35..         ADDC      A,?V11
   \   00004F   FD           MOV       R5,A
   \   000050   8C82         MOV       DPL,R4
   \   000052   F583         MOV       DPH,A
   \   000054   A3           INC       DPTR
   \   000055   12....       LCALL     ?Subroutine85 & 0xFFFF
   1611                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \                     ??CrossCallReturnLabel_143:
   \   000058   8C82         MOV       DPL,R4
   \   00005A   8D83         MOV       DPH,R5
   \   00005C   A3           INC       DPTR
   \   00005D   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   000060   F0           MOVX      @DPTR,A
   1612                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000061   EC           MOV       A,R4
   \   000062   2403         ADD       A,#0x3
   \   000064   FC           MOV       R4,A
   \   000065   5001         JNC       ??zcl_SendConfigReportRspCmd_3
   \   000067   0D           INC       R5
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   000068   F582         MOV       DPL,A
   \   00006A   8D83         MOV       DPH,R5
   \   00006C   12....       LCALL     ??Subroutine181_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   00006F   A3           INC       DPTR
   \   000070   F0           MOVX      @DPTR,A
   1613                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000071   8C82         MOV       DPL,R4
   \   000073   8D83         MOV       DPH,R5
   \   000075   12....       LCALL     ?Subroutine63 & 0xFFFF
   1614              }
   \                     ??CrossCallReturnLabel_388:
   \   000078   A3           INC       DPTR
   \   000079   A3           INC       DPTR
   \   00007A   F0           MOVX      @DPTR,A
   \   00007B   EA           MOV       A,R2
   \   00007C   2404         ADD       A,#0x4
   \   00007E   FA           MOV       R2,A
   \   00007F   5001         JNC       ??zcl_SendConfigReportRspCmd_4
   \   000081   0B           INC       R3
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   000082   09           INC       R1
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   000083   85..82       MOV       DPL,?V4
   \   000086   85..83       MOV       DPH,?V5
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   F8           MOV       R0,A
   \   00008B   E9           MOV       A,R1
   \   00008C   C3           CLR       C
   \   00008D   98           SUBB      A,R0
   \   00008E   40A9         JC        ??zcl_SendConfigReportRspCmd_2
   1615          
   1616              // If there's only a single status record and its status field is set to
   1617              // SUCCESS then omit the attribute ID field.
   1618              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000090   7401         MOV       A,#0x1
   \   000092   68           XRL       A,R0
   \   000093   700A         JNZ       ??zcl_SendConfigReportRspCmd_5
   \   000095   A3           INC       DPTR
   \   000096   E0           MOVX      A,@DPTR
   \   000097   7006         JNZ       ??zcl_SendConfigReportRspCmd_5
   1619              {
   1620                dataLen = 1;
   \   000099   75..01       MOV       ?V6,#0x1
   \   00009C   75..00       MOV       ?V7,#0x0
   1621              }
   1622          
   1623              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1624                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1625                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   00009F                ; Setup parameters for call to function zcl_SendCommand
   \   00009F   78..         MOV       R0,#?V0
   \   0000A1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A4   78..         MOV       R0,#?V6
   \   0000A6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A9   741C         MOV       A,#0x1c
   \   0000AB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AE   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   0000B1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B4   E4           CLR       A
   \   0000B5   F5..         MOV       ?V4,A
   \   0000B7   F5..         MOV       ?V5,A
   \   0000B9   78..         MOV       R0,#?V4
   \   0000BB   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BE   741E         MOV       A,#0x1e
   \   0000C0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C3   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0000C6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C9   741E         MOV       A,#0x1e
   \   0000CB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CE   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0000D1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D4   75..00       MOV       ?V3,#0x0
   \   0000D7   78..         MOV       R0,#?V3
   \   0000D9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DC   75..07       MOV       ?V3,#0x7
   \   0000DF   78..         MOV       R0,#?V3
   \   0000E1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E4   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   0000E7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000EA   E9           MOV       A,R1
   \   0000EB   FE           MOV       R6,A
   1626              zcl_mem_free( buf );
   \   0000EC                ; Setup parameters for call to function osal_mem_free
   \   0000EC   AA..         MOV       R2,?V0
   \   0000EE   AB..         MOV       R3,?V1
   \   0000F0   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000F3   8002         SJMP      ??zcl_SendConfigReportRspCmd_6
   1627            }
   1628            else
   1629            {
   1630              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F5   7E10         MOV       R6,#0x10
   1631            }
   1632          
   1633            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_6:
   \   0000F7                REQUIRE ?Subroutine6
   \   0000F7                ; // Fall through to label ?Subroutine6
   1634          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   F0           MOVX      @DPTR,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine181_0
   \   000001                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   22           RET
   1635          #endif
   1636          
   1637          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1638          /*********************************************************************
   1639           * @fn      zcl_SendReadReportCfgCmd
   1640           *
   1641           * @brief   Send a Read Reporting Configuration command
   1642           *
   1643           * @param   dstAddr - destination address
   1644           * @param   clusterID - cluster ID
   1645           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1646           * @param   direction - direction of the command
   1647           * @param   seqNum - transaction sequence number
   1648           *
   1649           * @return  ZSuccess if OK
   1650           */
   1651          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1652                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1653                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1654          {
   1655            uint16 dataLen;
   1656            uint8 *buf;
   1657            ZStatus_t status;
   1658          
   1659            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1660          
   1661            buf = zcl_mem_alloc( dataLen );
   1662            if ( buf != NULL )
   1663            {
   1664              // Load the buffer - serially
   1665              uint8 *pBuf = buf;
   1666              uint8 i;
   1667          
   1668              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1669              {
   1670                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1671                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1672                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1673              }
   1674          
   1675              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1676                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1677              zcl_mem_free( buf );
   1678            }
   1679            else
   1680            {
   1681              status = ZMemError;
   1682            }
   1683          
   1684            return ( status );
   1685          }
   1686          #endif
   1687          
   1688          #ifdef ZCL_REPORTING_DEVICE
   1689          /*********************************************************************
   1690           * @fn      zcl_SendReadReportCfgRspCmd
   1691           *
   1692           * @brief   Send a Read Reporting Configuration Response command
   1693           *
   1694           * @param   dstAddr - destination address
   1695           * @param   clusterID - cluster ID
   1696           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1697           * @param   direction - direction of the command
   1698           * @param   seqNum - transaction sequence number
   1699           *
   1700           * @return  ZSuccess if OK
   1701           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1702          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1703                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1704                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1705          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   00000D   89..         MOV       ?V1,R1
   \   00000F   8C..         MOV       ?V12,R4
   \   000011   8D..         MOV       ?V13,R5
   1706            uint8 *buf;
   1707            uint16 dataLen = 0;
   \   000013   7E00         MOV       R6,#0x0
   \   000015   7F00         MOV       R7,#0x0
   1708            ZStatus_t status;
   1709            uint8 i;
   1710          
   1711            // Find out the data length
   1712            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000017   75..00       MOV       ?V0,#0x0
   \   00001A   741A         MOV       A,#0x1a
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   000022   8009         SJMP      ??zcl_SendReadReportCfgRspCmd_0
   1713            {
   1714              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1715          
   1716              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1717          
   1718              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1719              {
   1720                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1721                {
   1722                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1723          
   1724                  // Find out the size of the Reportable Change field (for Analog data types)
   1725                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1726                  {
   1727                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1728                  }
   1729                }
   1730                else
   1731                {
   1732                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   000024   EE           MOV       A,R6
   \   000025   2402         ADD       A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000027   FE           MOV       R6,A
   \   000028   E4           CLR       A
   \   000029   3F           ADDC      A,R7
   \   00002A   FF           MOV       R7,A
   1733                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   00002B   05..         INC       ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   00002D   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000030   5041         JNC       ??zcl_SendReadReportCfgRspCmd_4
   \   000032   E5..         MOV       A,?V0
   \   000034   75F00D       MOV       B,#0xd
   \   000037   12....       LCALL     ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   00003A   2404         ADD       A,#0x4
   \   00003C   FE           MOV       R6,A
   \   00003D   E4           CLR       A
   \   00003E   3F           ADDC      A,R7
   \   00003F   FF           MOV       R7,A
   \   000040   E0           MOVX      A,@DPTR
   \   000041   70E8         JNZ       ??zcl_SendReadReportCfgRspCmd_3
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   70DD         JNZ       ??zcl_SendReadReportCfgRspCmd_1
   \   000047   EE           MOV       A,R6
   \   000048   2405         ADD       A,#0x5
   \   00004A   FE           MOV       R6,A
   \   00004B   E4           CLR       A
   \   00004C   3F           ADDC      A,R7
   \   00004D   FF           MOV       R7,A
   \   00004E   E8           MOV       A,R0
   \   00004F   2404         ADD       A,#0x4
   \   000051   F5..         MOV       ?V2,A
   \   000053   E4           CLR       A
   \   000054   39           ADDC      A,R1
   \   000055   F5..         MOV       ?V3,A
   \   000057                ; Setup parameters for call to function zclAnalogDataType
   \   000057   85..82       MOV       DPL,?V2
   \   00005A   F583         MOV       DPH,A
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F9           MOV       R1,A
   \   00005E   12....       LCALL     `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000061   E9           MOV       A,R1
   \   000062   60C7         JZ        ??zcl_SendReadReportCfgRspCmd_3
   \   000064                ; Setup parameters for call to function zclGetDataTypeLength
   \   000064   85..82       MOV       DPL,?V2
   \   000067   85..83       MOV       DPH,?V3
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   F9           MOV       R1,A
   \   00006C   12....       LCALL     `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   00006F   EE           MOV       A,R6
   \   000070   29           ADD       A,R1
   \   000071   80B4         SJMP      ??zcl_SendReadReportCfgRspCmd_2
   1734              }
   1735            }
   1736          
   1737            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   000073                ; Setup parameters for call to function osal_mem_alloc
   \   000073   12....       LCALL     ?Subroutine107 & 0xFFFF
   1738            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_174:
   \   000076   7003         JNZ       $+5
   \   000078   02....       LJMP      ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1739            {
   1740              // Load the buffer - serially
   1741              uint8 *pBuf = buf;
   \   00007B   8A..         MOV       ?V6,R2
   \   00007D   8B..         MOV       ?V7,R3
   1742          
   1743              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   00007F   75..00       MOV       ?V0,#0x0
   \   000082   801A         SJMP      ??zcl_SendReadReportCfgRspCmd_6
   1744              {
   1745                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1746          
   1747                *pBuf++ = reportRspRec->status;
   1748                *pBuf++ = reportRspRec->direction;
   1749                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1750                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1751          
   1752                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1753                {
   1754                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1755                  {
   1756                    *pBuf++ = reportRspRec->dataType;
   1757                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1758                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1759                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1760                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1761          
   1762                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1763                    {
   1764                      pBuf = zclSerializeData( reportRspRec->dataType,
   1765                                               reportRspRec->reportableChange, pBuf );
   1766                    }
   1767                  }
   1768                  else
   1769                  {
   1770                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   000084   E5..         MOV       A,?V4
   \   000086   2409         ADD       A,#0x9
   \   000088   FA           MOV       R2,A
   \   000089   E4           CLR       A
   \   00008A   35..         ADDC      A,?V5
   \   00008C   FB           MOV       R3,A
   \   00008D   8A82         MOV       DPL,R2
   \   00008F   12....       LCALL     ?Subroutine140 & 0xFFFF
   1771                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1772                  }
   \                     ??CrossCallReturnLabel_269:
   \   000092   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000095   12....       LCALL     ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000098   8C..         MOV       ?V6,R4
   \   00009A   8D..         MOV       ?V7,R5
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   00009C   05..         INC       ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   00009E   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   0000A1   4003         JC        $+5
   \   0000A3   02....       LJMP      ??zcl_SendReadReportCfgRspCmd_9 & 0xFFFF
   \   0000A6   E5..         MOV       A,?V0
   \   0000A8   75F00D       MOV       B,#0xd
   \   0000AB   12....       LCALL     ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   0000AE   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   0000B1   8582..       MOV       ?V4,DPL
   \   0000B4   8583..       MOV       ?V5,DPH
   \   0000B7   12....       LCALL     ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   0000BA   85..82       MOV       DPL,?V4
   \   0000BD   85..83       MOV       DPH,?V5
   \   0000C0   A3           INC       DPTR
   \   0000C1   AA82         MOV       R2,DPL
   \   0000C3   AB83         MOV       R3,DPH
   \   0000C5   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   0000C8   F0           MOVX      @DPTR,A
   \   0000C9   E5..         MOV       A,?V4
   \   0000CB   2402         ADD       A,#0x2
   \   0000CD   F8           MOV       R0,A
   \   0000CE   E4           CLR       A
   \   0000CF   35..         ADDC      A,?V5
   \   0000D1   F9           MOV       R1,A
   \   0000D2   8882         MOV       DPL,R0
   \   0000D4   12....       LCALL     ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   0000D7   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000DA   F0           MOVX      @DPTR,A
   \   0000DB   E5..         MOV       A,?V6
   \   0000DD   2404         ADD       A,#0x4
   \   0000DF   F5..         MOV       ?V6,A
   \   0000E1   5002         JNC       ??zcl_SendReadReportCfgRspCmd_10
   \   0000E3   05..         INC       ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_10:
   \   0000E5   85..82       MOV       DPL,?V4
   \   0000E8   85..83       MOV       DPH,?V5
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   70AE         JNZ       ??zcl_SendReadReportCfgRspCmd_8
   \   0000EE   E5..         MOV       A,?V6
   \   0000F0   2402         ADD       A,#0x2
   \   0000F2   FC           MOV       R4,A
   \   0000F3   E4           CLR       A
   \   0000F4   35..         ADDC      A,?V7
   \   0000F6   FD           MOV       R5,A
   \   0000F7   85..82       MOV       DPL,?V6
   \   0000FA   85..83       MOV       DPH,?V7
   \   0000FD   A3           INC       DPTR
   \   0000FE   A882         MOV       R0,DPL
   \   000100   A983         MOV       R1,DPH
   \   000102   8A82         MOV       DPL,R2
   \   000104   8B83         MOV       DPH,R3
   \   000106   E0           MOVX      A,@DPTR
   \   000107   6003         JZ        $+5
   \   000109   02....       LJMP      ??zcl_SendReadReportCfgRspCmd_7 & 0xFFFF
   \   00010C   E5..         MOV       A,?V4
   \   00010E   2404         ADD       A,#0x4
   \   000110   F5..         MOV       ?V10,A
   \   000112   E4           CLR       A
   \   000113   35..         ADDC      A,?V5
   \   000115   F5..         MOV       ?V11,A
   \   000117   85..82       MOV       DPL,?V10
   \   00011A   F583         MOV       DPH,A
   \   00011C   12....       LCALL     ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   00011F   E5..         MOV       A,?V4
   \   000121   2405         ADD       A,#0x5
   \   000123   F5..         MOV       ?V14,A
   \   000125   E4           CLR       A
   \   000126   35..         ADDC      A,?V5
   \   000128   F5..         MOV       ?V15,A
   \   00012A   85..82       MOV       DPL,?V14
   \   00012D   F583         MOV       DPH,A
   \   00012F   12....       LCALL     ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000132   85..82       MOV       DPL,?V14
   \   000135   85..83       MOV       DPH,?V15
   \   000138   12....       LCALL     ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   00013B   F0           MOVX      @DPTR,A
   \   00013C   E5..         MOV       A,?V4
   \   00013E   2407         ADD       A,#0x7
   \   000140   F8           MOV       R0,A
   \   000141   E4           CLR       A
   \   000142   35..         ADDC      A,?V5
   \   000144   F9           MOV       R1,A
   \   000145   8882         MOV       DPL,R0
   \   000147   F583         MOV       DPH,A
   \   000149   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00014C   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00014F   A3           INC       DPTR
   \   000150   F0           MOVX      @DPTR,A
   \   000151   E5..         MOV       A,?V6
   \   000153   2405         ADD       A,#0x5
   \   000155   F5..         MOV       ?V6,A
   \   000157   5002         JNC       ??zcl_SendReadReportCfgRspCmd_11
   \   000159   05..         INC       ?V7
   \                     ??zcl_SendReadReportCfgRspCmd_11:
   \   00015B                ; Setup parameters for call to function zclAnalogDataType
   \   00015B   85..82       MOV       DPL,?V10
   \   00015E   85..83       MOV       DPH,?V11
   \   000161   E0           MOVX      A,@DPTR
   \   000162   F9           MOV       R1,A
   \   000163   12....       LCALL     `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   000166   E9           MOV       A,R1
   \   000167   7003         JNZ       $+5
   \   000169   02....       LJMP      ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   \   00016C                ; Setup parameters for call to function zclSerializeData
   \   00016C   AC..         MOV       R4,?V6
   \   00016E   AD..         MOV       R5,?V7
   \   000170   E5..         MOV       A,?V4
   \   000172   240B         ADD       A,#0xb
   \   000174   F582         MOV       DPL,A
   \   000176   E4           CLR       A
   \   000177   35..         ADDC      A,?V5
   \   000179   F583         MOV       DPH,A
   \   00017B   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   1773                }
   1774              }
   \                     ??CrossCallReturnLabel_367:
   \   00017E   12....       LCALL     ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000181   8A..         MOV       ?V6,R2
   \   000183   8B..         MOV       ?V7,R3
   \   000185   02....       LJMP      ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   1775          
   1776              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1777                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1778                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000188                ; Setup parameters for call to function zcl_SendCommand
   \   000188   78..         MOV       R0,#?V2
   \   00018A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00018D   8E..         MOV       ?V4,R6
   \   00018F   8F..         MOV       ?V5,R7
   \   000191   78..         MOV       R0,#?V4
   \   000193   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000196   7422         MOV       A,#0x22
   \   000198   12....       LCALL     ?XSTACK_DISP0_8
   \   00019B   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00019E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001A1   E4           CLR       A
   \   0001A2   F5..         MOV       ?V4,A
   \   0001A4   F5..         MOV       ?V5,A
   \   0001A6   78..         MOV       R0,#?V4
   \   0001A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001AB   7424         MOV       A,#0x24
   \   0001AD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B0   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0001B3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B6   7424         MOV       A,#0x24
   \   0001B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001BB   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0001BE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C1   75..00       MOV       ?V0,#0x0
   \   0001C4   78..         MOV       R0,#?V0
   \   0001C6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C9   75..09       MOV       ?V0,#0x9
   \   0001CC   78..         MOV       R0,#?V0
   \   0001CE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001D1   AC..         MOV       R4,?V12
   \   0001D3   AD..         MOV       R5,?V13
   \   0001D5   740B         MOV       A,#0xb
   \   0001D7   12....       LCALL     ?XSTACK_DISP0_8
   \   0001DA   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   0001DD   A9..         MOV       R1,?V1
   \   0001DF   12....       LCALL     ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   0001E2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001E5   E9           MOV       A,R1
   \   0001E6   FE           MOV       R6,A
   1779              zcl_mem_free( buf );
   \   0001E7                ; Setup parameters for call to function osal_mem_free
   \   0001E7   AA..         MOV       R2,?V2
   \   0001E9   AB..         MOV       R3,?V3
   \   0001EB   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001EE   8002         SJMP      ??zcl_SendReadReportCfgRspCmd_12
   1780            }
   1781            else
   1782            {
   1783              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   0001F0   7E10         MOV       R6,#0x10
   1784            }
   1785          
   1786            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_12:
   \   0001F2   EE           MOV       A,R6
   \   0001F3   F9           MOV       R1,A
   \   0001F4   7402         MOV       A,#0x2
   \   0001F6   02....       LJMP      ?Subroutine5 & 0xFFFF
   1787          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine159_0
   \   000002                ; // Fall through to label ??Subroutine159_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine159_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?V6
   \   000004   85..83       MOV       DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL     ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?V6
   \   000004   85..83       MOV       DPH,?V7
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL     ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   85..82       MOV       DPL,?V8
   \   000003   85..83       MOV       DPH,?V9
   \   000006                REQUIRE ??Subroutine161_0
   \   000006                ; // Fall through to label ??Subroutine161_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine161_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   E5..         MOV       A,?V0
   \   000004   C3           CLR       C
   \   000005   98           SUBB      A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   F0           MOVX      @DPTR,A
   \   000003   8882         MOV       DPL,R0
   \   000005   8983         MOV       DPH,R1
   \   000007   A3           INC       DPTR
   \   000008   12....       LCALL     ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine167_0
   \   000006                ; // Fall through to label ??Subroutine167_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine169_0
   \   000001                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   22           RET
   1788          
   1789          /*********************************************************************
   1790           * @fn      zcl_SendReportCmd
   1791           *
   1792           * @brief   Send a Report command
   1793           *
   1794           * @param   dstAddr - destination address
   1795           * @param   clusterID - cluster ID
   1796           * @param   reportCmd - report command to be sent
   1797           * @param   direction - direction of the command
   1798           * @param   seqNum - transaction sequence number
   1799           *
   1800           * @return  ZSuccess if OK
   1801           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1802          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1803                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1804                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1805          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V3,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   8C..         MOV       ?V6,R4
   \   00000D   8D..         MOV       ?V7,R5
   1806            uint16 dataLen = 0;
   \   00000F   7E00         MOV       R6,#0x0
   \   000011   7F00         MOV       R7,#0x0
   1807            uint8 *buf;
   1808            ZStatus_t status;
   1809            uint8 i;
   1810          
   1811            // calculate the size of the command
   1812            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   75..00       MOV       ?V2,#0x0
   \   000016   7416         MOV       A,#0x16
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00001E   8003         SJMP      ??CrossCallReturnLabel_40
   1813            {
   1814              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   000020   12....       LCALL     ?Subroutine38 & 0xFFFF
   1815          
   1816              dataLen += 2 + 1; // Attribute ID + data type
   1817          
   1818              // Attribute Data
   1819              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1820            }
   \                     ??CrossCallReturnLabel_40:
   \   000023   85..82       MOV       DPL,?V4
   \   000026   85..83       MOV       DPH,?V5
   \   000029   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   00002C   40F2         JC        ??zcl_SendReportCmd_0
   1821          
   1822            buf = zcl_mem_alloc( dataLen );
   \   00002E                ; Setup parameters for call to function osal_mem_alloc
   \   00002E   EE           MOV       A,R6
   \   00002F   FA           MOV       R2,A
   \   000030   EF           MOV       A,R7
   \   000031   12....       LCALL     ??Subroutine184_0 & 0xFFFF
   1823            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_406:
   \   000034   607E         JZ        ??zcl_SendReportCmd_1
   1824            {
   1825              // Load the buffer - serially
   1826              uint8 *pBuf = buf;
   \   000036   A8..         MOV       R0,?V0
   \   000038   A9..         MOV       R1,?V1
   1827          
   1828              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   00003A   75..00       MOV       ?V2,#0x0
   \   00003D   8003         SJMP      ??CrossCallReturnLabel_1
   1829              {
   1830                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_2:
   \   00003F   12....       LCALL     ?Subroutine12 & 0xFFFF
   1831          
   1832                *pBuf++ = LO_UINT16( reportRec->attrID );
   1833                *pBuf++ = HI_UINT16( reportRec->attrID );
   1834                *pBuf++ = reportRec->dataType;
   1835          
   1836                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1837              }
   \                     ??CrossCallReturnLabel_1:
   \   000042   85..82       MOV       DPL,?V4
   \   000045   85..83       MOV       DPH,?V5
   \   000048   E0           MOVX      A,@DPTR
   \   000049   FA           MOV       R2,A
   \   00004A   E5..         MOV       A,?V2
   \   00004C   C3           CLR       C
   \   00004D   9A           SUBB      A,R2
   \   00004E   40EF         JC        ??zcl_SendReportCmd_2
   1838          
   1839              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1840                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000050                ; Setup parameters for call to function zcl_SendCommand
   \   000050   78..         MOV       R0,#?V0
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000055   8E..         MOV       ?V4,R6
   \   000057   8F..         MOV       ?V5,R7
   \   000059   78..         MOV       R0,#?V4
   \   00005B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005E   741E         MOV       A,#0x1e
   \   000060   12....       LCALL     ?XSTACK_DISP0_8
   \   000063   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000069   E4           CLR       A
   \   00006A   F5..         MOV       ?V4,A
   \   00006C   F5..         MOV       ?V5,A
   \   00006E   78..         MOV       R0,#?V4
   \   000070   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000073   7420         MOV       A,#0x20
   \   000075   12....       LCALL     ?XSTACK_DISP0_8
   \   000078   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   00007B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00007E   7420         MOV       A,#0x20
   \   000080   12....       LCALL     ?XSTACK_DISP0_8
   \   000083   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   000086   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000089   75..00       MOV       ?V2,#0x0
   \   00008C   78..         MOV       R0,#?V2
   \   00008E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000091   75..0A       MOV       ?V2,#0xa
   \   000094   78..         MOV       R0,#?V2
   \   000096   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000099   AC..         MOV       R4,?V6
   \   00009B   AD..         MOV       R5,?V7
   \   00009D   AA..         MOV       R2,?V8
   \   00009F   AB..         MOV       R3,?V9
   \   0000A1   A9..         MOV       R1,?V3
   \   0000A3   12....       LCALL     ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   0000A6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A9   E9           MOV       A,R1
   \   0000AA   FE           MOV       R6,A
   1841              zcl_mem_free( buf );
   \   0000AB                ; Setup parameters for call to function osal_mem_free
   \   0000AB   AA..         MOV       R2,?V0
   \   0000AD   AB..         MOV       R3,?V1
   \   0000AF   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000B2   8002         SJMP      ??zcl_SendReportCmd_3
   1842            }
   1843            else
   1844            {
   1845              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000B4   7E10         MOV       R6,#0x10
   1846            }
   1847          
   1848            return ( status );
   \                     ??zcl_SendReportCmd_3:
   \   0000B6   02....       LJMP      ?Subroutine11 & 0xFFFF
   1849          }
   1850          #endif
   1851          
   1852          /*********************************************************************
   1853           * @fn      zcl_SendDefaultRspCmd
   1854           *
   1855           * @brief   Send a Default Response command
   1856           *
   1857           *          Note: The manufacturer code field should be set if this
   1858           *          command is being sent in response to a manufacturer specific
   1859           *          command.
   1860           *
   1861           * @param   dstAddr - destination address
   1862           * @param   clusterID - cluster ID
   1863           * @param   defaultRspCmd - default response command to be sent
   1864           * @param   direction - direction of the command
   1865           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1866           * @param   seqNum - transaction sequence number
   1867           *
   1868           * @return  ZSuccess if OK
   1869           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1870          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1871                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1872                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1873          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   740C         MOV       A,#0xc
   \   00000E   12....       LCALL     ?XSTACK_DISP0_8
   \   000011   12....       LCALL     ?Subroutine78 & 0xFFFF
   1874            uint8 buf[2]; // Command ID and Status;
   1875          
   1876            // Load the buffer - serially
   1877            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_131:
   \   000014   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000017   12....       LCALL     ?Subroutine30 & 0xFFFF
   1878            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_31:
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   C0E0         PUSH      A
   \   00001D   7401         MOV       A,#0x1
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   D0E0         POP       A
   \   000024   F0           MOVX      @DPTR,A
   1879          
   1880            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1881                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000025                ; Setup parameters for call to function zcl_SendCommand
   \   000025   A8..         MOV       R0,?XSP + 0
   \   000027   A9..         MOV       R1,?XSP + 1
   \   000029   88..         MOV       ?V0,R0
   \   00002B   89..         MOV       ?V1,R1
   \   00002D   78..         MOV       R0,#?V0
   \   00002F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV       ?V0,#0x2
   \   000035   75..00       MOV       ?V1,#0x0
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7416         MOV       A,#0x16
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   7415         MOV       A,#0x15
   \   00004A   12....       LCALL     ?XSTACK_DISP0_8
   \   00004D   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000050   7416         MOV       A,#0x16
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000058   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005B   7416         MOV       A,#0x16
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000063   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000066   75..00       MOV       ?V0,#0x0
   \   000069   78..         MOV       R0,#?V0
   \   00006B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006E   75..0B       MOV       ?V0,#0xb
   \   000071   78..         MOV       R0,#?V0
   \   000073   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000076   EE           MOV       A,R6
   \   000077   F9           MOV       R1,A
   \   000078   12....       LCALL     ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007E   7402         MOV       A,#0x2
   \   000080   12....       LCALL     ?DEALLOC_XSTACK8
   \   000083   02....       LJMP      ?Subroutine2 & 0xFFFF
   1882          }
   1883          
   1884          #ifdef ZCL_DISCOVER
   1885          /*********************************************************************
   1886           * @fn      zcl_SendDiscoverCmdsCmd
   1887           *
   1888           * @brief   Send a Discover Commands command
   1889           *
   1890           * @param   dstAddr - destination address
   1891           * @param   clusterID - cluster ID
   1892           * @param   cmdType - requesting command ID
   1893           * @param   pDiscoverCmd - discover command to be sent
   1894           * @param   direction - direction of the command
   1895           * @param   seqNum - transaction sequence number
   1896           *
   1897           * @return  ZSuccess if OK
   1898           */
   1899          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1900                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1901                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1902          {
   1903            uint8 payload[2]; // size of startCmdID and maxCmdID
   1904            ZStatus_t status;
   1905          
   1906            payload[0] = pDiscoverCmd->startCmdID;
   1907            payload[1] = pDiscoverCmd->maxCmdID;
   1908          
   1909            // Send message for either commands received or generated
   1910            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1911            {
   1912              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1913                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1914            }
   1915            else  // generated
   1916            {
   1917              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1918                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1919            }
   1920          
   1921            return ( status );
   1922          }
   1923          
   1924          /*********************************************************************
   1925           * @fn      zcl_SendDiscoverCmdsRspCmd
   1926           *
   1927           * @brief   Send a Discover Commands Response command
   1928           *
   1929           * @param   dstAddr - destination address
   1930           * @param   clusterID - cluster ID
   1931           * @param   pDiscoverRspCmd - response command to be sent
   1932           * @param   direction - direction of the command
   1933           * @param   seqNum - transaction sequence number
   1934           *
   1935           * @return  ZSuccess if OK
   1936           */
   1937          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1938                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1939                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1940          {
   1941            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1942            uint8 *pCmdBuf;
   1943            uint8 i;
   1944            ZStatus_t status = ZSuccess;
   1945          
   1946            // allocate memory
   1947            pCmdBuf = zcl_mem_alloc( payloadSize );
   1948            if ( pCmdBuf != NULL )
   1949            {
   1950              uint8 *pBuf = pCmdBuf;
   1951          
   1952              // Load the buffer - serially
   1953              *pBuf++ = pDiscoverRspCmd->discComplete;
   1954              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1955              {
   1956                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1957              }
   1958          
   1959              // Send response message for either commands received or generated
   1960              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1961              {
   1962                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1963                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1964              }
   1965              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1966              {
   1967                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1968                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1969              }
   1970          
   1971              zcl_mem_free( pCmdBuf );
   1972            }
   1973            else
   1974            {
   1975              status = ZMemError;
   1976            }
   1977          
   1978            return ( status );
   1979          }
   1980          
   1981          /*********************************************************************
   1982           * @fn      zcl_SendDiscoverAttrsCmd
   1983           *
   1984           * @brief   Send a Discover Attributes command
   1985           *
   1986           * @param   dstAddr - destination address
   1987           * @param   clusterID - cluster ID
   1988           * @param   pDiscoverCmd - discover command to be sent
   1989           * @param   direction - direction of the command
   1990           * @param   seqNum - transaction sequence number
   1991           *
   1992           * @return  ZSuccess if OK
   1993           */
   1994          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1995                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1996                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1997          {
   1998            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1999            uint8 *buf;
   2000            ZStatus_t status;
   2001          
   2002            buf = zcl_mem_alloc( dataLen );
   2003            if ( buf != NULL )
   2004            {
   2005              // Load the buffer - serially
   2006              uint8 *pBuf = buf;
   2007              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   2008              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   2009              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   2010          
   2011              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   2012                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   2013              zcl_mem_free( buf );
   2014            }
   2015            else
   2016            {
   2017              status = ZMemError;
   2018            }
   2019          
   2020            return ( status );
   2021          }
   2022          
   2023          /*********************************************************************
   2024           * @fn      zcl_SendDiscoverAttrsRspCmd
   2025           *
   2026           * @brief   Send a Discover Attributes Response command
   2027           *
   2028           * @param   dstAddr - destination address
   2029           * @param   clusterID - cluster ID
   2030           * @param   reportRspCmd - report response command to be sent
   2031           * @param   direction - direction of the command
   2032           * @param   seqNum - transaction sequence number
   2033           *
   2034           * @return  ZSuccess if OK
   2035           */
   2036          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   2037                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   2038                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2039          {
   2040            uint16 dataLen = 1; // Discovery complete
   2041            uint8 *buf;
   2042            ZStatus_t status;
   2043          
   2044            // calculate the size of the command
   2045            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   2046          
   2047            buf = zcl_mem_alloc( dataLen );
   2048            if ( buf != NULL )
   2049            {
   2050              // Load the buffer - serially
   2051              uint8 i;
   2052              uint8 *pBuf = buf;
   2053          
   2054              *pBuf++ = pDiscoverRspCmd->discComplete;
   2055          
   2056              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   2057              {
   2058                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   2059                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   2060                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   2061              }
   2062          
   2063              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   2064                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   2065              zcl_mem_free( buf );
   2066            }
   2067            else
   2068            {
   2069              status = ZMemError;
   2070            }
   2071          
   2072            return ( status );
   2073          }
   2074          
   2075          /*********************************************************************
   2076           * @fn      zcl_SendDiscoverAttrsExt
   2077           *
   2078           * @brief   Send a Discover Attributes Extended command
   2079           *
   2080           * @param   dstAddr - destination address
   2081           * @param   clusterID - cluster ID
   2082           * @param   pDiscoverAttrsExt:
   2083           *            - startAttrID: the first attribute to be selected
   2084           *            - maxAttrIDs: maximum number of returned attributes
   2085           * @param   direction - direction of the command
   2086           * @param   seqNum - transaction sequence number
   2087           *
   2088           * @return  ZSuccess if OK
   2089           */
   2090          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   2091                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   2092                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2093          {
   2094            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   2095            ZStatus_t status;
   2096          
   2097            // Load the buffer - serially
   2098            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   2099            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   2100            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   2101          
   2102            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   2103                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   2104          
   2105            return ( status );
   2106          }
   2107          
   2108          /*********************************************************************
   2109           * @fn      zcl_SendDiscoverAttrsExtRsp
   2110           *
   2111           * @brief   Send a Discover Attributes Extended Response command
   2112           *
   2113           * @param   dstAddr - destination address
   2114           * @param   clusterID - cluster ID
   2115           * @param   pDiscoverRspCmd:
   2116           *            - discComplete: indicates whether all requested attributes returned
   2117           *            - attrID: attribute ID
   2118           *            - attrDataType: data type of the given attribute
   2119           *            - attrAccessControl: access control of the given attribute
   2120           * @param   direction - direction of the command
   2121           * @param   seqNum - transaction sequence number
   2122           *
   2123           * @return  ZSuccess if OK
   2124           */
   2125          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   2126                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   2127                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2128          {
   2129            uint8 *buf;
   2130            uint8 i;
   2131            uint16 dataLen = 1; // Discovery complete
   2132            ZStatus_t status;
   2133          
   2134            // calculate the size of the command
   2135            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   2136          
   2137            buf = zcl_mem_alloc( dataLen );
   2138            if ( buf != NULL )
   2139            {
   2140              // Load the buffer - serially
   2141              uint8 *pBuf = buf;
   2142              *pBuf++ = pDiscoverRspCmd->discComplete;
   2143              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   2144              {
   2145                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2146                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2147                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   2148                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   2149              }
   2150          
   2151              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   2152                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   2153              zcl_mem_free( buf );
   2154            }
   2155            else
   2156            {
   2157              status = ZMemError;
   2158            }
   2159          
   2160            return ( status );
   2161          }
   2162          #endif // ZCL_DISCOVER
   2163          
   2164          /*********************************************************************
   2165           * @fn      zcl_ProcessMessageMSG
   2166           *
   2167           * @brief   Data message processor callback.  This function processes
   2168           *          any incoming data - probably from other devices.  So, based
   2169           *          on cluster ID, perform the intended action.
   2170           *
   2171           * @param   pkt - incoming message
   2172           *
   2173           * @return  zclProcMsgStatus_t
   2174           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2175          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   2176          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV       A,#-0x15
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2177            endPointDesc_t *epDesc;
   2178            zclIncoming_t inMsg;
   2179            zclLibPlugin_t *pInPlugin;
   2180            zclDefaultRspCmd_t defautlRspCmd;
   2181            uint8 options;
   2182            uint8 securityEnable;
   2183            uint8 interPanMsg;
   2184            ZStatus_t status = ZFailure;
   2185            uint8 defaultResponseSent = FALSE;
   \   00000E   C2..         CLR       ?VB.0
   2186          
   2187            if ( pkt->cmd.DataLength < ZCL_VALID_MIN_HEADER_LEN  )
   \   000010   EA           MOV       A,R2
   \   000011   2420         ADD       A,#0x20
   \   000013   F8           MOV       R0,A
   \   000014   E4           CLR       A
   \   000015   3F           ADDC      A,R7
   \   000016   88..         MOV       ?V0,R0
   \   000018   F5..         MOV       ?V1,A
   \   00001A   8882         MOV       DPL,R0
   \   00001C   F583         MOV       DPH,A
   \   00001E   C3           CLR       C
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   9403         SUBB      A,#0x3
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   9400         SUBB      A,#0x0
   \   000026   5005         JNC       ??zcl_ProcessMessageMSG_0
   2188            {
   2189              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000028   7901         MOV       R1,#0x1
   \   00002A   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2190            }
   2191          
   2192            // Initialize
   2193            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   00002D   90....       MOV       DPTR,#rawAFMsg
   \   000030   12....       LCALL     ??Subroutine167_0 & 0xFFFF
   2194            inMsg.msg = pkt;
   \                     ??CrossCallReturnLabel_294:
   \   000033   7402         MOV       A,#0x2
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   12....       LCALL     ??Subroutine167_0 & 0xFFFF
   2195            inMsg.attrCmd = NULL;
   \                     ??CrossCallReturnLabel_295:
   \   00003B   740E         MOV       A,#0xe
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   E4           CLR       A
   \   000041   F0           MOVX      @DPTR,A
   \   000042   A3           INC       DPTR
   \   000043   F0           MOVX      @DPTR,A
   2196            inMsg.pData = NULL;
   \   000044   740A         MOV       A,#0xa
   \   000046   12....       LCALL     ?XSTACK_DISP0_8
   \   000049   E4           CLR       A
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   A3           INC       DPTR
   \   00004C   F0           MOVX      @DPTR,A
   2197            inMsg.pDataLen = 0;
   \   00004D   740C         MOV       A,#0xc
   \   00004F   12....       LCALL     ?XSTACK_DISP0_8
   \   000052   E4           CLR       A
   \   000053   F0           MOVX      @DPTR,A
   \   000054   A3           INC       DPTR
   \   000055   F0           MOVX      @DPTR,A
   2198          
   2199            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000056   EA           MOV       A,R2
   \   000057   2422         ADD       A,#0x22
   \   000059   F8           MOV       R0,A
   \   00005A   E4           CLR       A
   \   00005B   3F           ADDC      A,R7
   \   00005C   88..         MOV       ?V2,R0
   \   00005E   F5..         MOV       ?V3,A
   \   000060                ; Setup parameters for call to function zclParseHdr
   \   000060   8882         MOV       DPL,R0
   \   000062   F583         MOV       DPH,A
   \   000064   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_429:
   \   000067   7404         MOV       A,#0x4
   \   000069   12....       LCALL     ?XSTACK_DISP0_8
   \   00006C   AA82         MOV       R2,DPL
   \   00006E   AB83         MOV       R3,DPH
   \   000070   12....       LCALL     `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000073   8A..         MOV       ?V4,R2
   \   000075   8B..         MOV       ?V5,R3
   \   000077   A8..         MOV       R0,?V4
   \   000079   A9..         MOV       R1,?V5
   \   00007B   740A         MOV       A,#0xa
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   EA           MOV       A,R2
   \   000081   F0           MOVX      @DPTR,A
   \   000082   A3           INC       DPTR
   \   000083   EB           MOV       A,R3
   \   000084   12....       LCALL     ?Subroutine31 & 0xFFFF
   2200            inMsg.pDataLen = pkt->cmd.DataLength;
   2201            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_34:
   \   000087   FA           MOV       R2,A
   \   000088   A3           INC       DPTR
   \   000089   E0           MOVX      A,@DPTR
   \   00008A   FB           MOV       R3,A
   \   00008B   EA           MOV       A,R2
   \   00008C   C3           CLR       C
   \   00008D   98           SUBB      A,R0
   \   00008E   F8           MOV       R0,A
   \   00008F   EB           MOV       A,R3
   \   000090   99           SUBB      A,R1
   \   000091   F9           MOV       R1,A
   \   000092   85..82       MOV       DPL,?V2
   \   000095   85..83       MOV       DPH,?V3
   \   000098   12....       LCALL     ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   00009B   740C         MOV       A,#0xc
   \   00009D   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A0   E8           MOV       A,R0
   \   0000A1   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   2202          
   2203            // Temporary workaround to allow callback functions access to the
   2204            // transaction sequence number.  Callback functions will call
   2205            // zcl_getParsedTransSeqNum() to retrieve this number.
   2206            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_499:
   \   0000A4   7408         MOV       A,#0x8
   \   0000A6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A9   E0           MOVX      A,@DPTR
   \   0000AA   90....       MOV       DPTR,#savedZCLTransSeqNum
   \   0000AD   F0           MOVX      @DPTR,A
   2207          
   2208            // Find the wanted endpoint
   2209            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000AE   EE           MOV       A,R6
   \   0000AF   2414         ADD       A,#0x14
   \   0000B1   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   0000B4   E0           MOVX      A,@DPTR
   \   0000B5   F9           MOV       R1,A
   \   0000B6   12....       LCALL     `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   0000B9   8A82         MOV       DPL,R2
   \   0000BB   8B83         MOV       DPH,R3
   2210            if ( epDesc == NULL )
   \   0000BD   E582         MOV       A,DPL
   \   0000BF   4583         ORL       A,DPH
   \   0000C1   700C         JNZ       ??zcl_ProcessMessageMSG_2
   2211            {
   2212              rawAFMsg = NULL;
   \   0000C3   90....       MOV       DPTR,#rawAFMsg
   \   0000C6   E4           CLR       A
   \   0000C7   F0           MOVX      @DPTR,A
   \   0000C8   A3           INC       DPTR
   \   0000C9   F0           MOVX      @DPTR,A
   2213              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000CA   7902         MOV       R1,#0x2
   \   0000CC   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2214            }
   2215          
   2216            if ( ( epDesc->simpleDesc == NULL ) ||
   2217                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   2218                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000CF   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   0000D2   602B         JZ        ??zcl_ProcessMessageMSG_3
   \   0000D4   EE           MOV       A,R6
   \   0000D5   2404         ADD       A,#0x4
   \   0000D7   F5..         MOV       ?V2,A
   \   0000D9   E4           CLR       A
   \   0000DA   3F           ADDC      A,R7
   \   0000DB   F5..         MOV       ?V3,A
   \   0000DD                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000DD   A3           INC       DPTR
   \   0000DE   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0000E1   740B         MOV       A,#0xb
   \   0000E3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E6   E0           MOVX      A,@DPTR
   \   0000E7   FD           MOV       R5,A
   \   0000E8   7406         MOV       A,#0x6
   \   0000EA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000ED   E0           MOVX      A,@DPTR
   \   0000EE   5403         ANL       A,#0x3
   \   0000F0   FC           MOV       R4,A
   \   0000F1   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000F4   12....       LCALL     `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   0000F7   7402         MOV       A,#0x2
   \   0000F9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000FC   E9           MOV       A,R1
   \   0000FD   700C         JNZ       ??zcl_ProcessMessageMSG_4
   2219            {
   2220              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000FF   90....       MOV       DPTR,#rawAFMsg
   \   000102   E4           CLR       A
   \   000103   F0           MOVX      @DPTR,A
   \   000104   A3           INC       DPTR
   \   000105   F0           MOVX      @DPTR,A
   2221              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   000106   7903         MOV       R1,#0x3
   \   000108   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2222            }
   2223          
   2224          #if defined ( INTER_PAN )
   2225            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   2226            {
   2227              // No foundation command is supported thru Inter-PAN communication.
   2228              // But the Light Link cluster uses a different Frame Control format
   2229              // for it's Inter-PAN messages, where the messages could be confused
   2230              // with the foundation commands.
   2231              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   2232              {
   2233                rawAFMsg = NULL;
   2234                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   2235              }
   2236          
   2237              interPanMsg = TRUE;
   2238              options = AF_TX_OPTIONS_NONE;
   2239            }
   2240            else
   2241          #endif
   2242            {
   2243              interPanMsg = FALSE;
   2244              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   00010B                ; Setup parameters for call to function zclGetClusterOption
   \   00010B   12....       LCALL     ?Subroutine42 & 0xFFFF
   2245            }
   \                     ??CrossCallReturnLabel_58:
   \   00010E   12....       LCALL     `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   000111   E9           MOV       A,R1
   \   000112   F5..         MOV       ?V6,A
   2246          
   2247            // Find the appropriate plugin
   2248            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000114   85..82       MOV       DPL,?V2
   \   000117   85..83       MOV       DPH,?V3
   \   00011A   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   00011D   EA           MOV       A,R2
   \   00011E   FC           MOV       R4,A
   \   00011F   EB           MOV       A,R3
   \   000120   FD           MOV       R5,A
   \   000121   90....       MOV       DPTR,#plugins
   \   000124   8004         SJMP      ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   000126   8882         MOV       DPL,R0
   \   000128   8983         MOV       DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00012A   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   00012D   7003         JNZ       $+5
   \   00012F   02....       LJMP      ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000132   8882         MOV       DPL,R0
   \   000134   8983         MOV       DPH,R1
   \   000136   A3           INC       DPTR
   \   000137   A3           INC       DPTR
   \   000138   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00013B   C3           CLR       C
   \   00013C   EA           MOV       A,R2
   \   00013D   95..         SUBB      A,?V4
   \   00013F   EB           MOV       A,R3
   \   000140   95..         SUBB      A,?V5
   \   000142   40E2         JC        ??zcl_ProcessMessageMSG_6
   \   000144   8882         MOV       DPL,R0
   \   000146   8983         MOV       DPH,R1
   \   000148   A3           INC       DPTR
   \   000149   A3           INC       DPTR
   \   00014A   A3           INC       DPTR
   \   00014B   A3           INC       DPTR
   \   00014C   C3           CLR       C
   \   00014D   E0           MOVX      A,@DPTR
   \   00014E   9C           SUBB      A,R4
   \   00014F   A3           INC       DPTR
   \   000150   E0           MOVX      A,@DPTR
   \   000151   9D           SUBB      A,R5
   \   000152   40D2         JC        ??zcl_ProcessMessageMSG_6
   \   000154   E8           MOV       A,R0
   \   000155   FC           MOV       R4,A
   \   000156   E9           MOV       A,R1
   \   000157   FD           MOV       R5,A
   \   000158   7404         MOV       A,#0x4
   \   00015A   12....       LCALL     ?XSTACK_DISP0_8
   \   00015D   E0           MOVX      A,@DPTR
   \   00015E   5407         ANL       A,#0x7
   \   000160   700D         JNZ       ??zcl_ProcessMessageMSG_8
   \   000162   7409         MOV       A,#0x9
   \   000164   12....       LCALL     ?XSTACK_DISP0_8
   \   000167   E0           MOVX      A,@DPTR
   \   000168   640B         XRL       A,#0xb
   \   00016A   7003         JNZ       $+5
   \   00016C   02....       LJMP      ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2249          
   2250            // Local and remote Security options must match except for Default Response command
   2251            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   2252            {
   2253              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   00016F   E5..         MOV       A,?V6
   \   000171   A2E6         MOV       C,0xE0 /* A   */.6
   \   000173   4003         JC        $+5
   \   000175   02....       LJMP      ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   000178   EE           MOV       A,R6
   \   000179   2419         ADD       A,#0x19
   \   00017B   F582         MOV       DPL,A
   \   00017D   E4           CLR       A
   \   00017E   3F           ADDC      A,R7
   \   00017F   F583         MOV       DPH,A
   \   000181   E0           MOVX      A,@DPTR
   \   000182   6003         JZ        $+5
   \   000184   02....       LJMP      ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2254          
   2255              // Make sure that Clusters specifically defined to use security are received secure,
   2256              // any other cluster that wants to use APS security will be allowed
   2257              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   2258              {
   2259                if ( UNICAST_MSG( inMsg.msg ) )
   \   000187   7402         MOV       A,#0x2
   \   000189   12....       LCALL     ?XSTACK_DISP0_8
   \   00018C   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00018F   707E         JNZ       ??zcl_ProcessMessageMSG_10
   \   000191   7402         MOV       A,#0x2
   \   000193   12....       LCALL     ?XSTACK_DISP0_8
   \   000196   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   000199   7074         JNZ       ??zcl_ProcessMessageMSG_10
   2260                {
   2261                  // Send a Default Response command back with no Application Link Key security
   2262                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   00019B                ; Setup parameters for call to function zclSetSecurityOption
   \   00019B   7C00         MOV       R4,#0x0
   \   00019D   85..82       MOV       DPL,?V0
   \   0001A0   85..83       MOV       DPH,?V1
   \   0001A3   E0           MOVX      A,@DPTR
   \   0001A4   F9           MOV       R1,A
   \   0001A5   12....       LCALL     `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2263          
   2264                  defautlRspCmd.statusCode = status;
   \   0001A8   7401         MOV       A,#0x1
   \   0001AA   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AD   7401         MOV       A,#0x1
   \   0001AF   F0           MOVX      @DPTR,A
   2265                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001B0   7409         MOV       A,#0x9
   \   0001B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B5   12....       LCALL     ?Subroutine71 & 0xFFFF
   2266                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2267                                         inMsg.msg->clusterId, &defautlRspCmd,
   2268                                         !inMsg.hdr.fc.direction, true,
   2269                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_115:
   \   0001B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001BB   E0           MOVX      A,@DPTR
   \   0001BC   F5..         MOV       ?V4,A
   \   0001BE   78..         MOV       R0,#?V4
   \   0001C0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C3   7407         MOV       A,#0x7
   \   0001C5   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C8   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0001CB   75..01       MOV       ?V4,#0x1
   \   0001CE   78..         MOV       R0,#?V4
   \   0001D0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001D3   7408         MOV       A,#0x8
   \   0001D5   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D8   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   0001DB   F5..         MOV       ?V4,A
   \   0001DD   78..         MOV       R0,#?V4
   \   0001DF   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001E2   7405         MOV       A,#0x5
   \   0001E4   12....       LCALL     ?XSTACK_DISP100_8
   \   0001E7   88..         MOV       ?V4,R0
   \   0001E9   89..         MOV       ?V5,R1
   \   0001EB   78..         MOV       R0,#?V4
   \   0001ED   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001F0   7409         MOV       A,#0x9
   \   0001F2   12....       LCALL     ?XSTACK_DISP0_8
   \   0001F5   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0001F8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FB   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   0001FE   12....       LCALL     ?XSTACK_DISP0_8
   \   000201   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000204   12....       LCALL     ?DEALLOC_XSTACK8
   2270          
   2271                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000207                ; Setup parameters for call to function zclSetSecurityOption
   \   000207   7C01         MOV       R4,#0x1
   \   000209   12....       LCALL     ?Subroutine42 & 0xFFFF
   2272                }
   \                     ??CrossCallReturnLabel_59:
   \   00020C   12....       LCALL     `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2273          
   2274                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   00020F   90....       MOV       DPTR,#rawAFMsg
   \   000212   E4           CLR       A
   \   000213   F0           MOVX      @DPTR,A
   \   000214   A3           INC       DPTR
   \   000215   F0           MOVX      @DPTR,A
   2275                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000216   7905         MOV       R1,#0x5
   \   000218   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2276              }
   2277            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   00021B   7C00         MOV       R4,#0x0
   \   00021D   7D00         MOV       R5,#0x0
   2278          
   2279            // Is this a foundation type message
   2280            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   00021F   7404         MOV       A,#0x4
   \   000221   12....       LCALL     ?XSTACK_DISP0_8
   \   000224   E0           MOVX      A,@DPTR
   \   000225   F8           MOV       R0,A
   \   000226   5403         ANL       A,#0x3
   \   000228   6003         JZ        $+5
   \   00022A   02....       LJMP      ??zcl_ProcessMessageMSG_11 & 0xFFFF
   2281            {
   2282              if ( inMsg.hdr.fc.manuSpecific )
   \   00022D   E8           MOV       A,R0
   \   00022E   5404         ANL       A,#0x4
   \   000230   6005         JZ        ??zcl_ProcessMessageMSG_12
   2283              {
   2284                // We don't support any manufacturer specific command
   2285                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000232   7E84         MOV       R6,#-0x7c
   \   000234   02....       LJMP      ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2286              }
   2287              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2288                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   000237   7409         MOV       A,#0x9
   \   000239   12....       LCALL     ?XSTACK_DISP0_8
   \   00023C   E0           MOVX      A,@DPTR
   \   00023D   F8           MOV       R0,A
   \   00023E   C3           CLR       C
   \   00023F   9417         SUBB      A,#0x17
   \   000241   4003         JC        $+5
   \   000243   02....       LJMP      ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   000246   E8           MOV       A,R0
   \   000247   F5..         MOV       ?V2,A
   \   000249   75..00       MOV       ?V3,#0x0
   \   00024C   7402         MOV       A,#0x2
   \   00024E   78..         MOV       R0,#?V2
   \   000250   12....       LCALL     ?S_SHL
   \   000253   74..         MOV       A,#zclCmdTable & 0xff
   \   000255   25..         ADD       A,?V2
   \   000257   F582         MOV       DPL,A
   \   000259   74..         MOV       A,#(zclCmdTable >> 8) & 0xff
   \   00025B   35..         ADDC      A,?V3
   \   00025D   F583         MOV       DPH,A
   \   00025F   E4           CLR       A
   \   000260   93           MOVC      A,@A+DPTR
   \   000261   F8           MOV       R0,A
   \   000262   7401         MOV       A,#0x1
   \   000264   93           MOVC      A,@A+DPTR
   \   000265   F9           MOV       R1,A
   \   000266   E8           MOV       A,R0
   \   000267   49           ORL       A,R1
   \   000268   7003         JNZ       $+5
   \   00026A   02....       LJMP      ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2289              {
   2290                zclParseCmd_t parseCmd;
   2291          
   2292                parseCmd.endpoint = pkt->endPoint;
   \   00026D   85..82       MOV       DPL,?V0
   \   000270   85..83       MOV       DPH,?V1
   \   000273   E0           MOVX      A,@DPTR
   \   000274   C0E0         PUSH      A
   \   000276   7410         MOV       A,#0x10
   \   000278   12....       LCALL     ?XSTACK_DISP0_8
   \   00027B   D0E0         POP       A
   \   00027D   F0           MOVX      @DPTR,A
   2293                parseCmd.dataLen = inMsg.pDataLen;
   \   00027E   740C         MOV       A,#0xc
   \   000280   12....       LCALL     ?XSTACK_DISP0_8
   \   000283   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   000286   7411         MOV       A,#0x11
   \   000288   12....       LCALL     ?XSTACK_DISP0_8
   \   00028B   12....       LCALL     ??Subroutine167_0 & 0xFFFF
   2294                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_296:
   \   00028E   740A         MOV       A,#0xa
   \   000290   12....       LCALL     ?XSTACK_DISP0_8
   \   000293   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   000296   7413         MOV       A,#0x13
   \   000298   12....       LCALL     ?XSTACK_DISP0_8
   \   00029B   12....       LCALL     ??Subroutine167_0 & 0xFFFF
   2295          
   2296                // Parse the command, remember that the return value is a pointer to allocated memory
   2297                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_297:
   \   00029E                ; Setup parameters for indirect call
   \   00029E   7410         MOV       A,#0x10
   \   0002A0   12....       LCALL     ?XSTACK_DISP101_8
   \   0002A3   8882         MOV       DPL,R0
   \   0002A5   8983         MOV       DPH,R1
   \   0002A7   12....       LCALL     ?CALL_IND
   \   0002AA   8B..         MOV       ?V1,R3
   \   0002AC   A9..         MOV       R1,?V1
   \   0002AE   740E         MOV       A,#0xe
   \   0002B0   12....       LCALL     ?XSTACK_DISP0_8
   \   0002B3   12....       LCALL     ??Subroutine167_0 & 0xFFFF
   2298                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_298:
   \   0002B6   EA           MOV       A,R2
   \   0002B7   49           ORL       A,R1
   \   0002B8   604B         JZ        ??zcl_ProcessMessageMSG_15
   \   0002BA   7409         MOV       A,#0x9
   \   0002BC   12....       LCALL     ?XSTACK_DISP0_8
   \   0002BF   E0           MOVX      A,@DPTR
   \   0002C0   F5..         MOV       ?V0,A
   \   0002C2   75..00       MOV       ?V1,#0x0
   \   0002C5   7402         MOV       A,#0x2
   \   0002C7   78..         MOV       R0,#?V0
   \   0002C9   12....       LCALL     ?S_SHL
   \   0002CC   74..         MOV       A,#(zclCmdTable + 2) & 0xff
   \   0002CE   25..         ADD       A,?V0
   \   0002D0   F582         MOV       DPL,A
   \   0002D2   74..         MOV       A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002D4   35..         ADDC      A,?V1
   \   0002D6   F583         MOV       DPH,A
   \   0002D8   E4           CLR       A
   \   0002D9   93           MOVC      A,@A+DPTR
   \   0002DA   F8           MOV       R0,A
   \   0002DB   7401         MOV       A,#0x1
   \   0002DD   93           MOVC      A,@A+DPTR
   \   0002DE   8882         MOV       DPL,R0
   \   0002E0   F583         MOV       DPH,A
   \   0002E2   E582         MOV       A,DPL
   \   0002E4   4583         ORL       A,DPH
   \   0002E6   6012         JZ        ??zcl_ProcessMessageMSG_16
   2299                {
   2300                  // Process the command
   2301                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002E8                ; Setup parameters for indirect call
   \   0002E8   7402         MOV       A,#0x2
   \   0002EA   12....       LCALL     ?XSTACK_DISP101_8
   \   0002ED   12....       LCALL     ?CALL_IND
   2302                  {
   2303                    // Couldn't find attribute in the table.
   2304                  }
   2305                }
   2306          
   2307                // Free the buffer
   2308                if ( inMsg.attrCmd )
   \   0002F0   740E         MOV       A,#0xe
   \   0002F2   12....       LCALL     ?XSTACK_DISP0_8
   \   0002F5   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   0002F8   600B         JZ        ??zcl_ProcessMessageMSG_15
   2309                {
   2310                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   0002FA                ; Setup parameters for call to function osal_mem_free
   \   0002FA   740E         MOV       A,#0xe
   \   0002FC   12....       LCALL     ?XSTACK_DISP0_8
   \   0002FF   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   2311                }
   \                     ??CrossCallReturnLabel_372:
   \   000302   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2312          
   2313                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000305   7409         MOV       A,#0x9
   \   000307   12....       LCALL     ?XSTACK_DISP0_8
   \   00030A   E0           MOVX      A,@DPTR
   \   00030B   F8           MOV       R0,A
   \   00030C   6058         JZ        ??zcl_ProcessMessageMSG_17
   \   00030E   7402         MOV       A,#0x2
   \   000310   68           XRL       A,R0
   \   000311   6053         JZ        ??zcl_ProcessMessageMSG_17
   \   000313   7403         MOV       A,#0x3
   \   000315   68           XRL       A,R0
   \   000316   604E         JZ        ??zcl_ProcessMessageMSG_17
   \   000318   7405         MOV       A,#0x5
   \   00031A   68           XRL       A,R0
   \   00031B   6049         JZ        ??zcl_ProcessMessageMSG_17
   \   00031D   7406         MOV       A,#0x6
   \   00031F   68           XRL       A,R0
   \   000320   6044         JZ        ??zcl_ProcessMessageMSG_17
   \   000322   7408         MOV       A,#0x8
   \   000324   68           XRL       A,R0
   \   000325   603F         JZ        ??zcl_ProcessMessageMSG_17
   \   000327   740C         MOV       A,#0xc
   \   000329   68           XRL       A,R0
   \   00032A   603A         JZ        ??zcl_ProcessMessageMSG_17
   \   00032C   7411         MOV       A,#0x11
   \   00032E   68           XRL       A,R0
   \   00032F   6035         JZ        ??zcl_ProcessMessageMSG_17
   \   000331   7413         MOV       A,#0x13
   \   000333   68           XRL       A,R0
   \   000334   6030         JZ        ??zcl_ProcessMessageMSG_17
   \   000336   7415         MOV       A,#0x15
   \   000338   68           XRL       A,R0
   \   000339   602B         JZ        ??zcl_ProcessMessageMSG_17
   \   00033B   740B         MOV       A,#0xb
   \   00033D   68           XRL       A,R0
   \   00033E   6026         JZ        ??zcl_ProcessMessageMSG_17
   2314                {
   2315                  rawAFMsg = NULL;
   2316                  return ( ZCL_PROC_SUCCESS ); // We're done
   2317                }
   2318          
   2319                status = ZSuccess;
   \   000340   7E00         MOV       R6,#0x0
   \   000342   8042         SJMP      ??zcl_ProcessMessageMSG_13
   2320              }
   2321              else
   2322              {
   2323                // Unsupported message
   2324                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   000344   7E82         MOV       R6,#-0x7e
   \   000346   803E         SJMP      ??zcl_ProcessMessageMSG_13
   2325              }
   2326            }
   2327            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2328            {
   2329              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   000348   EC           MOV       A,R4
   \   000349   4D           ORL       A,R5
   \   00034A   602A         JZ        ??zcl_ProcessMessageMSG_18
   \   00034C   8C82         MOV       DPL,R4
   \   00034E   8D83         MOV       DPH,R5
   \   000350   A3           INC       DPTR
   \   000351   A3           INC       DPTR
   \   000352   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000355   601F         JZ        ??zcl_ProcessMessageMSG_18
   2330              {
   2331                // The return value of the plugin function will be
   2332                //  ZSuccess - Supported and need default response
   2333                //  ZFailure - Unsupported
   2334                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2335                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2336                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2337                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2338                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000357                ; Setup parameters for indirect call
   \   000357   7402         MOV       A,#0x2
   \   000359   12....       LCALL     ?XSTACK_DISP101_8
   \   00035C   12....       LCALL     ?CALL_IND
   \   00035F   E9           MOV       A,R1
   \   000360   FE           MOV       R6,A
   2339                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000361   74FF         MOV       A,#-0x1
   \   000363   6E           XRL       A,R6
   \   000364   700B         JNZ       ??zcl_ProcessMessageMSG_19
   2340                {
   2341                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   000366   90....       MOV       DPTR,#rawAFMsg
   \   000369   E4           CLR       A
   \   00036A   F0           MOVX      @DPTR,A
   \   00036B   A3           INC       DPTR
   \   00036C   F0           MOVX      @DPTR,A
   2342                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   00036D   F9           MOV       R1,A
   \   00036E   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2343                }
   2344              }
   2345          
   2346              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000371   7401         MOV       A,#0x1
   \   000373   6E           XRL       A,R6
   \   000374   7010         JNZ       ??zcl_ProcessMessageMSG_13
   2347              {
   2348                // Unsupported message
   2349                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   000376   7404         MOV       A,#0x4
   \   000378   12....       LCALL     ?XSTACK_DISP0_8
   \   00037B   E0           MOVX      A,@DPTR
   \   00037C   5404         ANL       A,#0x4
   \   00037E   6004         JZ        ??zcl_ProcessMessageMSG_20
   2350                {
   2351                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000380   7E83         MOV       R6,#-0x7d
   \   000382   8002         SJMP      ??zcl_ProcessMessageMSG_13
   2352                }
   2353                else
   2354                {
   2355                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   000384   7E81         MOV       R6,#-0x7f
   2356                }
   2357              }
   2358            }
   2359          
   2360            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   000386   7402         MOV       A,#0x2
   \   000388   12....       LCALL     ?XSTACK_DISP0_8
   \   00038B   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   00038E   7075         JNZ       ??zcl_ProcessMessageMSG_21
   \   000390   7402         MOV       A,#0x2
   \   000392   12....       LCALL     ?XSTACK_DISP0_8
   \   000395   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   000398   706B         JNZ       ??zcl_ProcessMessageMSG_21
   \   00039A   7404         MOV       A,#0x4
   \   00039C   12....       LCALL     ?XSTACK_DISP0_8
   \   00039F   E0           MOVX      A,@DPTR
   \   0003A0   FA           MOV       R2,A
   \   0003A1   5410         ANL       A,#0x10
   \   0003A3   7060         JNZ       ??zcl_ProcessMessageMSG_21
   2361            {
   2362              // Send a Default Response command back
   2363              defautlRspCmd.statusCode = status;
   \   0003A5   7401         MOV       A,#0x1
   \   0003A7   12....       LCALL     ?XSTACK_DISP0_8
   \   0003AA   EE           MOV       A,R6
   \   0003AB   F0           MOVX      @DPTR,A
   2364              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003AC   7409         MOV       A,#0x9
   \   0003AE   12....       LCALL     ?XSTACK_DISP0_8
   \   0003B1   12....       LCALL     ?Subroutine71 & 0xFFFF
   2365              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2366                                     inMsg.msg->clusterId, &defautlRspCmd,
   2367                                     !inMsg.hdr.fc.direction, true,
   2368                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_116:
   \   0003B4   12....       LCALL     ?XSTACK_DISP0_8
   \   0003B7   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0003BA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0003BD   7407         MOV       A,#0x7
   \   0003BF   12....       LCALL     ?XSTACK_DISP0_8
   \   0003C2   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0003C5   75..01       MOV       ?V0,#0x1
   \   0003C8   78..         MOV       R0,#?V0
   \   0003CA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0003CD   EA           MOV       A,R2
   \   0003CE   13           RRC       A
   \   0003CF   13           RRC       A
   \   0003D0   13           RRC       A
   \   0003D1   541F         ANL       A,#0x1f
   \   0003D3   6401         XRL       A,#0x1
   \   0003D5   5401         ANL       A,#0x1
   \   0003D7   F5..         MOV       ?V0,A
   \   0003D9   78..         MOV       R0,#?V0
   \   0003DB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0003DE   7405         MOV       A,#0x5
   \   0003E0   12....       LCALL     ?XSTACK_DISP100_8
   \   0003E3   88..         MOV       ?V0,R0
   \   0003E5   89..         MOV       ?V1,R1
   \   0003E7   78..         MOV       R0,#?V0
   \   0003E9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0003EC   7409         MOV       A,#0x9
   \   0003EE   12....       LCALL     ?XSTACK_DISP0_8
   \   0003F1   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0003F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0003F7   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0003FA   12....       LCALL     ?XSTACK_DISP0_8
   \   0003FD   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000400   12....       LCALL     ?DEALLOC_XSTACK8
   2369              defaultResponseSent = TRUE;
   \   000403   D2..         SETB      ?VB.0
   2370            }
   2371          
   2372            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   000405   90....       MOV       DPTR,#rawAFMsg
   \   000408   E4           CLR       A
   \   000409   F0           MOVX      @DPTR,A
   \   00040A   A3           INC       DPTR
   \   00040B   F0           MOVX      @DPTR,A
   2373            if ( status == ZSuccess )
   \   00040C   EE           MOV       A,R6
   \   00040D   7004         JNZ       ??zcl_ProcessMessageMSG_22
   2374            {
   2375              return ( ZCL_PROC_SUCCESS );
   \   00040F   7900         MOV       R1,#0x0
   \   000411   8019         SJMP      ??zcl_ProcessMessageMSG_1
   2376            }
   2377            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   000413   7484         MOV       A,#-0x7c
   \   000415   6E           XRL       A,R6
   \   000416   A2..         MOV       C,?VB.0
   \   000418   700A         JNZ       ??zcl_ProcessMessageMSG_23
   2378            {
   2379              if ( defaultResponseSent )
   \   00041A   5004         JNC       ??zcl_ProcessMessageMSG_24
   2380              {
   2381                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   00041C   7907         MOV       R1,#0x7
   \   00041E   800C         SJMP      ??zcl_ProcessMessageMSG_1
   2382              }
   2383              else
   2384              {
   2385                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   000420   7906         MOV       R1,#0x6
   \   000422   8008         SJMP      ??zcl_ProcessMessageMSG_1
   2386              }
   2387            }
   2388            else
   2389            {
   2390              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   000424   5004         JNC       ??zcl_ProcessMessageMSG_25
   2391              {
   2392                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000426   7909         MOV       R1,#0x9
   \   000428   8002         SJMP      ??zcl_ProcessMessageMSG_1
   2393              }
   2394              else
   2395              {
   2396                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   00042A   7908         MOV       R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   00042C   7415         MOV       A,#0x15
   \   00042E   12....       LCALL     ?DEALLOC_XSTACK8
   2397              }
   2398            }
   \   000431   02....       LJMP      ?Subroutine8 & 0xFFFF
   2399          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   E0           MOVX      A,@DPTR
   \   000001                REQUIRE ??Subroutine165_0
   \   000001                ; // Fall through to label ??Subroutine165_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine165_0:
   \   000000   28           ADD       A,R0
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   39           ADDC      A,R1
   \   000005   F9           MOV       R1,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?XSP + 0
   \   000004   85..83       MOV       DPH,?XSP + 1
   \   000007   F0           MOVX      @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV       A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2406         ADD       A,#0x6
   \   000003   FA           MOV       R2,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3400         ADDC      A,#0x0
   \   000008   FB           MOV       R3,A
   \   000009   7409         MOV       A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_424:
   \   000003   C8           XCH       A,R0
   \   000004   2415         ADD       A,#0x15
   \   000006   F582         MOV       DPL,A
   \   000008   E4           CLR       A
   \   000009   38           ADDC      A,R0
   \   00000A   F583         MOV       DPH,A
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL     ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000003   F9           MOV       R1,A
   \   000004   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   000007   7407         MOV       A,#0x7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL     ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   12....       LCALL     ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_495:
   \   000006   7409         MOV       A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine166_0
   \   000004                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_426:
   \   000003   8882         MOV       DPL,R0
   \   000005   F583         MOV       DPH,A
   \   000007   E582         MOV       A,DPL
   \   000009   4583         ORL       A,DPH
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006   12....       LCALL     ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_487:
   \   000009   85..82       MOV       DPL,?V0
   \   00000C   85..83       MOV       DPH,?V1
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F9           MOV       R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL     ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine174_0
   \   000004                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F07         MOV       R7,#0x7
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL     ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   13           RRC       A
   \   000002   13           RRC       A
   \   000003   13           RRC       A
   \   000004   541F         ANL       A,#0x1f
   \   000006   6401         XRL       A,#0x1
   \   000008   5401         ANL       A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine197_0
   \   000004                ; // Fall through to label ??Subroutine197_0
   2400          
   2401          /*********************************************************************
   2402           * PRIVATE FUNCTIONS
   2403           *********************************************************************/
   2404          
   2405          /*********************************************************************
   2406           * @fn      zclParseHdr
   2407           *
   2408           * @brief   Parse header of the ZCL format
   2409           *
   2410           * @param   hdr - place to put the frame control information
   2411           * @param   pData - incoming buffer to parse
   2412           *
   2413           * @return  pointer past the header
   2414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2415          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2416          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   2417            // Clear the header
   2418            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV       R4,#0x6
   \   00000F   7D00         MOV       R5,#0x0
   \   000011   7900         MOV       R1,#0x0
   \   000013   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2419          
   2420            // Parse the Frame Control
   2421            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV       DPL,?V0
   \   000019   85..83       MOV       DPH,?V1
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   54FC         ANL       A,#0xfc
   \   00001F   F8           MOV       R0,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F9           MOV       R1,A
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   E0           MOVX      A,@DPTR
   \   000028   5403         ANL       A,#0x3
   \   00002A   FA           MOV       R2,A
   \   00002B   E8           MOV       A,R0
   \   00002C   4A           ORL       A,R2
   \   00002D   85..82       MOV       DPL,?V0
   \   000030   85..83       MOV       DPH,?V1
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   E9           MOV       A,R1
   \   000036   12....       LCALL     ?Subroutine28 & 0xFFFF
   2422            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_27:
   \   000039   A2E2         MOV       C,0xE0 /* A   */.2
   \   00003B   5004         JNC       ??zclParseHdr_0
   \   00003D   D2F0         SETB      B.0
   \   00003F   8002         SJMP      ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000041   C2F0         CLR       B.0
   \                     ??zclParseHdr_1:
   \   000043   85..82       MOV       DPL,?V0
   \   000046   85..83       MOV       DPH,?V1
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   54FB         ANL       A,#0xfb
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A2F0         MOV       C,B.0
   \   00004F   E4           CLR       A
   \   000050   33           RLC       A
   \   000051   F5..         MOV       ?V2,A
   \   000053   75..00       MOV       ?V3,#0x0
   \   000056   7402         MOV       A,#0x2
   \   000058   78..         MOV       R0,#?V2
   \   00005A   12....       LCALL     ?S_SHL
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   45..         ORL       A,?V2
   \   000060   12....       LCALL     ?Subroutine28 & 0xFFFF
   2423            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_28:
   \   000063   A2E3         MOV       C,0xE0 /* A   */.3
   \   000065   85..82       MOV       DPL,?V0
   \   000068   85..83       MOV       DPH,?V1
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   5004         JNC       ??zclParseHdr_2
   2424            {
   2425              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00006E   4408         ORL       A,#0x8
   \   000070   8002         SJMP      ??zclParseHdr_3
   2426            }
   2427            else
   2428            {
   2429              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000072   54F7         ANL       A,#0xf7
   2430            }
   \                     ??zclParseHdr_3:
   \   000074   12....       LCALL     ?Subroutine28 & 0xFFFF
   2431          
   2432            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_29:
   \   000077   A2E4         MOV       C,0xE0 /* A   */.4
   \   000079   5004         JNC       ??zclParseHdr_4
   \   00007B   D2F0         SETB      B.0
   \   00007D   8002         SJMP      ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   00007F   C2F0         CLR       B.0
   \                     ??zclParseHdr_5:
   \   000081   85..82       MOV       DPL,?V0
   \   000084   85..83       MOV       DPH,?V1
   \   000087   E0           MOVX      A,@DPTR
   \   000088   54EF         ANL       A,#0xef
   \   00008A   F0           MOVX      @DPTR,A
   \   00008B   A2F0         MOV       C,B.0
   \   00008D   E4           CLR       A
   \   00008E   33           RLC       A
   \   00008F   F5..         MOV       ?V2,A
   \   000091   7404         MOV       A,#0x4
   \   000093   78..         MOV       R0,#?V2
   \   000095   12....       LCALL     ?S_SHL
   \   000098   E0           MOVX      A,@DPTR
   \   000099   45..         ORL       A,?V2
   \   00009B   12....       LCALL     ?Subroutine24 & 0xFFFF
   2433            pData++;  // move past the frame control field
   2434          
   2435            // parse the manfacturer code
   2436            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_20:
   \   00009E   85..82       MOV       DPL,?V0
   \   0000A1   85..83       MOV       DPH,?V1
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   5404         ANL       A,#0x4
   \   0000A7   6010         JZ        ??zclParseHdr_6
   2437            {
   2438              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A9   8E82         MOV       DPL,R6
   \   0000AB   8F83         MOV       DPH,R7
   \   0000AD   E0           MOVX      A,@DPTR
   \   0000AE   FA           MOV       R2,A
   \   0000AF   A3           INC       DPTR
   \   0000B0   12....       LCALL     ?Subroutine76 & 0xFFFF
   2439              pData += 2;
   2440            }
   \                     ??CrossCallReturnLabel_127:
   \   0000B3   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   0000B6   5001         JNC       ??zclParseHdr_6
   \   0000B8   0F           INC       R7
   2441          
   2442            // parse the Transaction Sequence Number
   2443            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000B9   8E82         MOV       DPL,R6
   \   0000BB   8F83         MOV       DPH,R7
   \   0000BD   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   0000C0   A3           INC       DPTR
   \   0000C1   A3           INC       DPTR
   \   0000C2   12....       LCALL     ??Subroutine176_0 & 0xFFFF
   2444          
   2445            // parse the Cluster's command ID
   2446            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_347:
   \   0000C5   85..82       MOV       DPL,?V0
   \   0000C8   85..83       MOV       DPH,?V1
   \   0000CB   A3           INC       DPTR
   \   0000CC   A3           INC       DPTR
   \   0000CD   A3           INC       DPTR
   \   0000CE   A3           INC       DPTR
   \   0000CF   A3           INC       DPTR
   \   0000D0   F0           MOVX      @DPTR,A
   2447          
   2448            // Should point to the frame payload
   2449            return ( pData );
   \   0000D1   EE           MOV       A,R6
   \   0000D2   2402         ADD       A,#0x2
   \   0000D4   FA           MOV       R2,A
   \   0000D5   E4           CLR       A
   \   0000D6   3F           ADDC      A,R7
   \   0000D7   FB           MOV       R3,A
   \   0000D8   02....       LJMP      ?Subroutine3 & 0xFFFF
   2450          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine168_0
   \   000001                ; // Fall through to label ??Subroutine168_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   A3           INC       DPTR
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   EE           MOV       A,R6
   \   000006   2402         ADD       A,#0x2
   \   000008   FE           MOV       R6,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   12....       LCALL     ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL     ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   A3           INC       DPTR
   \   000006   AE82         MOV       R6,DPL
   \   000008   AF83         MOV       R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002   EA           MOV       A,R2
   \   000003   85..82       MOV       DPL,?V0
   \   000006   85..83       MOV       DPH,?V1
   \   000009   22           RET
   2451          
   2452          /*********************************************************************
   2453           * @fn      zclBuildHdr
   2454           *
   2455           * @brief   Build header of the ZCL format
   2456           *
   2457           * @param   hdr - outgoing header information
   2458           * @param   pData - outgoing header space
   2459           *
   2460           * @return  pointer past the header
   2461           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2462          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2463          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2464            // Build the Frame Control byte
   2465            *pData = hdr->fc.type;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   5403         ANL       A,#0x3
   \   00000C   8C82         MOV       DPL,R4
   \   00000E   8D83         MOV       DPH,R5
   \   000010   12....       LCALL     ??Subroutine170_0 & 0xFFFF
   2466            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_311:
   \   000013   5404         ANL       A,#0x4
   \   000015   12....       LCALL     ?Subroutine27 & 0xFFFF
   2467            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_309:
   \   000018   5408         ANL       A,#0x8
   \   00001A   12....       LCALL     ?Subroutine27 & 0xFFFF
   2468            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_310:
   \   00001D   5410         ANL       A,#0x10
   \   00001F   F8           MOV       R0,A
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   E0           MOVX      A,@DPTR
   \   000025   48           ORL       A,R0
   \   000026   F0           MOVX      @DPTR,A
   2469            pData++;  // move past the frame control field
   \   000027   A3           INC       DPTR
   \   000028   AC82         MOV       R4,DPL
   \   00002A   AD83         MOV       R5,DPH
   2470          
   2471            // Add the manfacturer code
   2472            if ( hdr->fc.manuSpecific )
   \   00002C   8A82         MOV       DPL,R2
   \   00002E   8B83         MOV       DPH,R3
   \   000030   E0           MOVX      A,@DPTR
   \   000031   5404         ANL       A,#0x4
   \   000033   6010         JZ        ??zclBuildHdr_0
   2473            {
   2474              *pData++ = LO_UINT16( hdr->manuCode );
   \   000035   12....       LCALL     ?Subroutine97 & 0xFFFF
   2475              *pData++ = HI_UINT16( hdr->manuCode );
   2476            }
   \                     ??CrossCallReturnLabel_164:
   \   000038   12....       LCALL     ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   00003B   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00003E   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000041   FC           MOV       R4,A
   \   000042   5001         JNC       ??zclBuildHdr_0
   \   000044   0D           INC       R5
   2477          
   2478            // Add the Transaction Sequence Number
   2479            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   000045   8A82         MOV       DPL,R2
   \   000047   8B83         MOV       DPH,R3
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   12....       LCALL     ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00004F   12....       LCALL     ?Subroutine23 & 0xFFFF
   2480          
   2481            // Add the Cluster's command ID
   2482            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_19:
   \   000052   12....       LCALL     ?Subroutine73 & 0xFFFF
   2483          
   2484            // Should point to the frame payload
   2485            return ( pData );
   \                     ??CrossCallReturnLabel_121:
   \   000055   FA           MOV       R2,A
   \   000056   E4           CLR       A
   \   000057   3D           ADDC      A,R5
   \   000058   FB           MOV       R3,A
   \   000059   80..         SJMP      ??Subroutine171_0
   2486          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL     ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000003   A3           INC       DPTR
   \   000004   F0           MOVX      @DPTR,A
   \   000005   EC           MOV       A,R4
   \   000006   2402         ADD       A,#0x2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   F8           MOV       R0,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   E0           MOVX      A,@DPTR
   \   000006   48           ORL       A,R0
   \   000007                REQUIRE ??Subroutine170_0
   \   000007                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
   2487          
   2488          /*********************************************************************
   2489           * @fn      zclCalcHdrSize
   2490           *
   2491           * @brief   Calculate the number of bytes needed for an outgoing
   2492           *          ZCL header.
   2493           *
   2494           * @param   hdr - outgoing header information
   2495           *
   2496           * @return  returns the number of bytes needed
   2497           */
   2498          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2499          {
   2500            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2501          
   2502            // Add the manfacturer code
   2503            if ( hdr->fc.manuSpecific )
   2504            {
   2505              needed += 2;
   2506            }
   2507          
   2508            return ( needed );
   2509          }
   2510          
   2511          /*********************************************************************
   2512           * @fn      zclFindPlugin
   2513           *
   2514           * @brief   Find the right plugin for a cluster ID
   2515           *
   2516           * @param   clusterID - cluster ID to look for
   2517           * @param   profileID - profile ID
   2518           *
   2519           * @return  pointer to plugin, NULL if not found
   2520           */
   2521          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2522          {
   2523            zclLibPlugin_t *pLoop = plugins;
   2524          
   2525            (void)profileID;  // Intentionally unreferenced parameter
   2526          
   2527            while ( pLoop != NULL )
   2528            {
   2529              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2530              {
   2531                return ( pLoop );
   2532              }
   2533          
   2534              pLoop = pLoop->next;
   2535            }
   2536          
   2537            return ( (zclLibPlugin_t *)NULL );
   2538          }
   2539          
   2540          #ifdef ZCL_DISCOVER
   2541          /*********************************************************************
   2542           * @fn      zclFindCmdRecsList
   2543           *
   2544           * @brief   Find the right command record list for an endpoint
   2545           *
   2546           * @param   endpoint - endpoint to look for
   2547           *
   2548           * @return  pointer to record list, NULL if not found
   2549           */
   2550          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2551          {
   2552            zclCmdRecsList_t *pLoop = gpCmdList;
   2553          
   2554            while ( pLoop != NULL )
   2555            {
   2556              if ( pLoop->endpoint == endpoint )
   2557              {
   2558                return ( pLoop );
   2559              }
   2560          
   2561              pLoop = pLoop->pNext;
   2562            }
   2563          
   2564            return ( NULL );
   2565          }
   2566          
   2567          /*********************************************************************
   2568           * @fn      zclFindCmdRec
   2569           *
   2570           * @brief   Find the command record that matchs the parameters
   2571           *
   2572           * @param   endpoint - Application's endpoint
   2573           * @param   clusterID - cluster ID
   2574           * @param   attrId - attribute looking for
   2575           * @param   pAttr - attribute record to be returned
   2576           *
   2577           * @return  TRUE if record found. FALSE, otherwise.
   2578           */
   2579          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2580          {
   2581            uint8 i;
   2582            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2583          
   2584            if ( pRec != NULL )
   2585            {
   2586              for ( i = 0; i < pRec->numCommands; i++ )
   2587              {
   2588                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2589                {
   2590                  *pCmd = pRec->pCmdRecs[i];
   2591          
   2592                  return ( TRUE ); // EMBEDDED RETURN
   2593                }
   2594              }
   2595            }
   2596          
   2597            return ( FALSE );
   2598          }
   2599          #endif // ZCL_DISCOVER
   2600          
   2601          /*********************************************************************
   2602           * @fn      zclFindAttrRecsList
   2603           *
   2604           * @brief   Find the right attribute record list for an endpoint
   2605           *
   2606           * @param   clusterID - endpointto look for
   2607           *
   2608           * @return  pointer to record list, NULL if not found
   2609           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2610          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2611          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2612            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV       DPTR,#attrList
   \   000007   8004         SJMP      ??zclFindAttrRecsList_0
   2613          
   2614            while ( pLoop != NULL )
   2615            {
   2616              if ( pLoop->endpoint == endpoint )
   2617              {
   2618                return ( pLoop );
   2619              }
   2620          
   2621              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000010   600C         JZ        ??zclFindAttrRecsList_2
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   69           XRL       A,R1
   \   00001A   70ED         JNZ       ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP      ??zclFindAttrRecsList_3
   2622            }
   2623          
   2624            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV       R2,#0x0
   \   000020   7B00         MOV       R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   2625          }
   2626          
   2627          /*********************************************************************
   2628           * @fn      zclFindAttrRec
   2629           *
   2630           * @brief   Find the attribute record that matchs the parameters
   2631           *
   2632           * @param   endpoint - Application's endpoint
   2633           * @param   clusterID - cluster ID
   2634           * @param   attrId - attribute looking for
   2635           * @param   pAttr - attribute record to be returned
   2636           *
   2637           * @return  TRUE if record found. FALSE, otherwise.
   2638           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2639          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2640          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   2641            uint8 x;
   2642            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV       ?V4,R2
   \   000012   8B..         MOV       ?V5,R3
   2643          
   2644            if ( pRec != NULL )
   \   000014   EA           MOV       A,R2
   \   000015   4B           ORL       A,R3
   \   000016   6078         JZ        ??zclFindAttrRec_0
   2645            {
   2646              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000018   7C00         MOV       R4,#0x0
   \   00001A   8001         SJMP      ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   00001C   0C           INC       R4
   \                     ??zclFindAttrRec_1:
   \   00001D   85..82       MOV       DPL,?V4
   \   000020   85..83       MOV       DPH,?V5
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F8           MOV       R0,A
   \   00002C   EC           MOV       A,R4
   \   00002D   C3           CLR       C
   \   00002E   98           SUBB      A,R0
   \   00002F   505F         JNC       ??zclFindAttrRec_0
   2647              {
   2648                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000031   EC           MOV       A,R4
   \   000032   F5..         MOV       ?V6,A
   \   000034   75..00       MOV       ?V7,#0x0
   \   000037   7403         MOV       A,#0x3
   \   000039   78..         MOV       R0,#?V6
   \   00003B   12....       LCALL     ?S_SHL
   \   00003E   85..82       MOV       DPL,?V4
   \   000041   85..83       MOV       DPH,?V5
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   25..         ADD       A,?V6
   \   00004F   F8           MOV       R0,A
   \   000050   A3           INC       DPTR
   \   000051   E0           MOVX      A,@DPTR
   \   000052   35..         ADDC      A,?V7
   \   000054   F9           MOV       R1,A
   \   000055   8882         MOV       DPL,R0
   \   000057   F583         MOV       DPH,A
   \   000059   E4           CLR       A
   \   00005A   93           MOVC      A,@A+DPTR
   \   00005B   FA           MOV       R2,A
   \   00005C   7401         MOV       A,#0x1
   \   00005E   93           MOVC      A,@A+DPTR
   \   00005F   FB           MOV       R3,A
   \   000060   E5..         MOV       A,?V0
   \   000062   6A           XRL       A,R2
   \   000063   7003         JNZ       ??zclFindAttrRec_3
   \   000065   E5..         MOV       A,?V1
   \   000067   6B           XRL       A,R3
   \                     ??zclFindAttrRec_3:
   \   000068   70B2         JNZ       ??zclFindAttrRec_2
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   E4           CLR       A
   \   00006D   93           MOVC      A,@A+DPTR
   \   00006E   FA           MOV       R2,A
   \   00006F   7401         MOV       A,#0x1
   \   000071   93           MOVC      A,@A+DPTR
   \   000072   FB           MOV       R3,A
   \   000073   EE           MOV       A,R6
   \   000074   6A           XRL       A,R2
   \   000075   7002         JNZ       ??zclFindAttrRec_4
   \   000077   EF           MOV       A,R7
   \   000078   6B           XRL       A,R3
   \                     ??zclFindAttrRec_4:
   \   000079   70A1         JNZ       ??zclFindAttrRec_2
   2649                {
   2650                  *pAttr = pRec->attrs[x];
   \   00007B   7410         MOV       A,#0x10
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   000083   8983         MOV       DPH,R1
   \   000085   8882         MOV       DPL,R0
   \   000087   7408         MOV       A,#0x8
   \   000089   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2651          
   2652                  return ( TRUE ); // EMBEDDED RETURN
   \   00008C   7901         MOV       R1,#0x1
   \   00008E   8002         SJMP      ??zclFindAttrRec_5
   2653                }
   2654              }
   2655            }
   2656          
   2657            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   000090   7900         MOV       R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   000092   80..         SJMP      ??Subroutine173_0
   2658          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   7F08         MOV       R7,#0x8
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   2659          
   2660          #if defined ( ZCL_STANDALONE )
   2661          /*********************************************************************
   2662           * @fn      zclSetAttrRecList
   2663           *
   2664           * @brief   Set attribute record list for end point
   2665           *
   2666           * @param   endpoint - endpoint the attribute list belongs to
   2667           * @param   numAttr - number of attributes in list
   2668           * @param   attrList - array of attribute records.
   2669           *                     NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE
   2670           *                     IN ASCENDING ORDER. OTHERWISE, THE DISCOVERY
   2671           *                     RESPONSE COMMAND WILL NOT HAVE THE RIGHT
   2672           *                     ATTRIBUTE INFO
   2673           *
   2674           * @return  TRUE if successful, FALSE otherwise.
   2675           */
   2676          uint8 zclSetAttrRecList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t attrList[] )
   2677          {
   2678            zclAttrRecsList *pRecsList = zclFindAttrRecsList( endpoint );
   2679          
   2680            if ( pRecsList != NULL )
   2681            {
   2682              pRecsList->numAttributes = numAttr;
   2683              pRecsList->attrs = attrList;
   2684              return ( TRUE );
   2685            }
   2686          
   2687            return ( FALSE );
   2688          }
   2689          
   2690          #endif // ZCL_STANDALONE
   2691          
   2692          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2693          /*********************************************************************
   2694           * @fn      zclGetReadWriteCB
   2695           *
   2696           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2697           *
   2698           * @param   endpoint - Application's endpoint
   2699           *
   2700           * @return  Read/Write CB, NULL if not found
   2701           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2702          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2703          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2704            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL     ?Subroutine109 & 0xFFFF
   2705          
   2706            if ( pRec != NULL )
   \                     ??CrossCallReturnLabel_177:
   \   000008   6005         JZ        ??zclGetReadWriteCB_0
   2707            {
   2708              return ( pRec->pfnReadWriteCB );
   \   00000A   12....       LCALL     ??Subroutine179_0 & 0xFFFF
   2709            }
   \                     ??CrossCallReturnLabel_378:
   \   00000D   8004         SJMP      ??zclGetReadWriteCB_1
   2710          
   2711            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   00000F   7A00         MOV       R2,#0x0
   \   000011   7B00         MOV       R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   000013   80..         SJMP      ?Subroutine2
   2712          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000003   8A82         MOV       DPL,R2
   \   000005   8B83         MOV       DPH,R3
   \   000007   E582         MOV       A,DPL
   \   000009   4583         ORL       A,DPH
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine180_0
   \   000003                ; // Fall through to label ??Subroutine180_0
   2713          
   2714          /*********************************************************************
   2715           * @fn      zclGetAuthorizeCB
   2716           *
   2717           * @brief   Get the Read/Write Authorization callback function pointer
   2718           *          for a given endpoint.
   2719           *
   2720           * @param   endpoint - Application's endpoint
   2721           *
   2722           * @return  Authorization CB, NULL if not found
   2723           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2724          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2725          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2726            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL     ?Subroutine109 & 0xFFFF
   2727          
   2728            if ( pRec != NULL )
   \                     ??CrossCallReturnLabel_178:
   \   000008   6005         JZ        ??zclGetAuthorizeCB_0
   2729            {
   2730              return ( pRec->pfnAuthorizeCB );
   \   00000A   12....       LCALL     ?Subroutine43 & 0xFFFF
   2731            }
   \                     ??CrossCallReturnLabel_383:
   \   00000D   8004         SJMP      ??zclGetAuthorizeCB_1
   2732          
   2733            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   00000F   7A00         MOV       R2,#0x0
   \   000011   7B00         MOV       R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   000013                REQUIRE ?Subroutine2
   \   000013                ; // Fall through to label ?Subroutine2
   2734          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine178_0
   \   000001                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine179_0
   \   000001                ; // Fall through to label ??Subroutine179_0
   2735          #endif // ZCL_READ || ZCL_WRITE
   2736          
   2737          /*********************************************************************
   2738           * @fn      zclFindClusterOption
   2739           *
   2740           * @brief   Find the option record that matchs the cluster id
   2741           *
   2742           * @param   endpoint - Application's endpoint
   2743           * @param   clusterID - cluster ID looking for
   2744           *
   2745           * @return  pointer to clutser option, NULL if not found
   2746           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2747          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2748          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FF           MOV       R7,A
   \   000007   EA           MOV       A,R2
   \   000008   FC           MOV       R4,A
   \   000009   EB           MOV       A,R3
   \   00000A   FD           MOV       R5,A
   2749            zclClusterOptionList *pLoop;
   2750          
   2751            pLoop = clusterOptionList;
   \   00000B   90....       MOV       DPTR,#clusterOptionList
   \   00000E   8004         SJMP      ??zclFindClusterOption_0
   2752            while ( pLoop != NULL )
   2753            {
   2754              if ( pLoop->endpoint == endpoint )
   2755              {
   2756                uint8 x;
   2757                for ( x = 0; x < pLoop->numOptions; x++ )
   2758                {
   2759                  if ( pLoop->options[x].clusterID == clusterID )
   2760                  {
   2761                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2762                  }
   2763                }
   2764              }
   2765          
   2766              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000010   8882         MOV       DPL,R0
   \   000012   8983         MOV       DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000014   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000017   6046         JZ        ??zclFindClusterOption_2
   \   000019   8882         MOV       DPL,R0
   \   00001B   8983         MOV       DPH,R1
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   6F           XRL       A,R7
   \   000021   70ED         JNZ       ??zclFindClusterOption_1
   \   000023   7E00         MOV       R6,#0x0
   \   000025   8001         SJMP      ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000027   0E           INC       R6
   \                     ??zclFindClusterOption_3:
   \   000028   8882         MOV       DPL,R0
   \   00002A   8983         MOV       DPH,R1
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   FA           MOV       R2,A
   \   000031   EE           MOV       A,R6
   \   000032   C3           CLR       C
   \   000033   9A           SUBB      A,R2
   \   000034   50DA         JNC       ??zclFindClusterOption_1
   \   000036   EE           MOV       A,R6
   \   000037   75F003       MOV       B,#0x3
   \   00003A   A4           MUL       AB
   \   00003B   FA           MOV       R2,A
   \   00003C   85F0..       MOV       ?V0,B
   \   00003F   AB..         MOV       R3,?V0
   \   000041   8882         MOV       DPL,R0
   \   000043   8983         MOV       DPH,R1
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   2A           ADD       A,R2
   \   00004B   FA           MOV       R2,A
   \   00004C   A3           INC       DPTR
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   3B           ADDC      A,R3
   \   00004F   FB           MOV       R3,A
   \   000050   8A82         MOV       DPL,R2
   \   000052   F583         MOV       DPH,A
   \   000054   E0           MOVX      A,@DPTR
   \   000055   6C           XRL       A,R4
   \   000056   7003         JNZ       ??zclFindClusterOption_5
   \   000058   A3           INC       DPTR
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   6D           XRL       A,R5
   \                     ??zclFindClusterOption_5:
   \   00005B   70CA         JNZ       ??zclFindClusterOption_4
   \   00005D   8004         SJMP      ??zclFindClusterOption_6
   2767            }
   2768          
   2769            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   00005F   7A00         MOV       R2,#0x0
   \   000061   7B00         MOV       R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   000063   02....       LJMP      ??Subroutine171_0 & 0xFFFF
   2770          }
   2771          
   2772          /*********************************************************************
   2773           * @fn      zclGetClusterOption
   2774           *
   2775           * @brief   Get the option record that matchs the cluster id
   2776           *
   2777           * @param   endpoint - Application's endpoint
   2778           * @param   clusterID - cluster ID looking for
   2779           *
   2780           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2782          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2783          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2784            uint8 option;
   2785            zclOptionRec_t *pOption;
   2786          
   2787            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL     `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   2788            if ( pOption != NULL )
   \   00000C   E582         MOV       A,DPL
   \   00000E   4583         ORL       A,DPH
   \   000010   6006         JZ        ??zclGetClusterOption_0
   2789            {
   2790              option = pOption->option;
   2791              if ( !ZG_SECURE_ENABLED )
   2792              {
   2793                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2794              }
   2795          
   2796              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F9           MOV       R1,A
   \   000016   8002         SJMP      ??zclGetClusterOption_1
   2797            }
   2798          
   2799            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000018   7900         MOV       R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001A   02....       LJMP      ?Subroutine2 & 0xFFFF
   2800          }
   2801          
   2802          /*********************************************************************
   2803           * @fn      zclSetSecurityOption
   2804           *
   2805           * @brief   Set the security option for the cluster id
   2806           *
   2807           * @param   endpoint - Application's endpoint
   2808           * @param   clusterID - cluster ID looking for
   2809           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2810           *
   2811           * @return  none
   2812           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2813          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2814          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV       A,R4
   \   000006   FF           MOV       R7,A
   2815            zclOptionRec_t *pOption;
   2816          
   2817            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL     `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   00000A   8B..         MOV       ?V1,R3
   \   00000C   A9..         MOV       R1,?V1
   2818            if ( pOption != NULL )
   \   00000E   EA           MOV       A,R2
   \   00000F   49           ORL       A,R1
   \   000010   6015         JZ        ??zclSetSecurityOption_0
   2819            {
   2820              if ( enable )
   \   000012   EA           MOV       A,R2
   \   000013   2402         ADD       A,#0x2
   \   000015   F582         MOV       DPL,A
   \   000017   E4           CLR       A
   \   000018   39           ADDC      A,R1
   \   000019   F583         MOV       DPH,A
   \   00001B   EF           MOV       A,R7
   \   00001C   6005         JZ        ??zclSetSecurityOption_1
   2821              {
   2822                pOption->option |= AF_EN_SECURITY;
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   D2E6         SETB      0xE0 /* A   */.6
   \   000021   8003         SJMP      ??zclSetSecurityOption_2
   2823              }
   2824              else
   2825              {
   2826                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000023   E0           MOVX      A,@DPTR
   \   000024   C2E6         CLR       0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   000026   F0           MOVX      @DPTR,A
   2827              }
   2828            }
   2829          }
   \                     ??zclSetSecurityOption_0:
   \   000027   02....       LJMP      ?Subroutine2 & 0xFFFF
   2830          
   2831          #ifdef ZCL_DISCOVER
   2832          /*********************************************************************
   2833           * @fn      zclFindNextCmdRec
   2834           *
   2835           * @brief   Find the command (or next) record that matchs the parameters
   2836           *
   2837           * @param   endpoint - Application's endpoint
   2838           * @param   clusterID - cluster ID
   2839           * @param   commandID - command ID from requesting command
   2840           * @param   direction- direction of received command
   2841           * @param   pCmdID - command looking for
   2842           * @param   pCmd - command information within command record list
   2843           *
   2844           * @return  pointer to command record, NULL no more records of this cluster
   2845           */
   2846          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2847                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2848          {
   2849            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2850            uint8 i;
   2851          
   2852            if ( pRec != NULL )
   2853            {
   2854              for ( i = 0; i < pRec->numCommands; i++ )
   2855              {
   2856                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2857                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2858                {
   2859                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2860                  {
   2861                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2862                    {
   2863                      *pCmd = pRec->pCmdRecs[i];
   2864          
   2865                      // Update command ID
   2866                      *pCmdID = pCmd->cmdID;
   2867          
   2868                      return ( TRUE ); // EMBEDDED RETURN
   2869                    }
   2870                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2871                    {
   2872                      *pCmd = pRec->pCmdRecs[i];
   2873          
   2874                      // Update command ID
   2875                      *pCmdID = pCmd->cmdID;
   2876          
   2877                      return ( TRUE ); // EMBEDDED RETURN
   2878                    }
   2879                  }
   2880                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2881                  {
   2882                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2883                    {
   2884                      *pCmd = pRec->pCmdRecs[i];
   2885          
   2886                      // Update command ID
   2887                      *pCmdID = pCmd->cmdID;
   2888          
   2889                      return ( TRUE ); // EMBEDDED RETURN
   2890                    }
   2891                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2892                    {
   2893                      *pCmd = pRec->pCmdRecs[i];
   2894          
   2895                      // Update command ID
   2896                      *pCmdID = pCmd->cmdID;
   2897          
   2898                      return ( TRUE ); // EMBEDDED RETURN
   2899                    }
   2900                  }
   2901                  else
   2902                  {
   2903                    return ( FALSE ); // Incorrect Command ID
   2904                  }
   2905                }
   2906              }
   2907            }
   2908          
   2909            return ( FALSE );
   2910          }
   2911          
   2912          /*********************************************************************
   2913           * @fn      zclFindNextAttrRec
   2914           *
   2915           * @brief   Find the attribute (or next) record that matchs the parameters
   2916           *
   2917           * @param   endpoint - Application's endpoint
   2918           * @param   clusterID - cluster ID
   2919           * @param   attr - attribute looking for
   2920           *
   2921           * @return  pointer to attribute record, NULL if not found
   2922           */
   2923          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2924                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2925          {
   2926            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2927            uint8 attrDir;
   2928          
   2929            if ( pRec != NULL )
   2930            {
   2931              uint16 x;
   2932          
   2933              for ( x = 0; x < pRec->numAttributes; x++ )
   2934              {
   2935                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2936                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2937                {
   2938                  // also make sure direction is right
   2939                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2940                  if ( (attrDir == direction) || (pRec->attrs[x].attr.accessControl & ACCESS_GLOBAL))
   2941                  {
   2942                    // return attribute and found attribute ID
   2943                    *pAttr = pRec->attrs[x];
   2944                    *attrId = pAttr->attr.attrId;
   2945          
   2946                    return ( TRUE ); // EMBEDDED RETURN
   2947                  }
   2948                }
   2949              }
   2950            }
   2951          
   2952            return ( FALSE );
   2953          }
   2954          #endif // ZCL_DISCOVER
   2955          
   2956          /*********************************************************************
   2957           * @fn      zclSerializeData
   2958           *
   2959           * @brief   Builds a buffer from the attribute data to sent out over
   2960           *          the air.
   2961           *          NOTE - Not compatible with application's attributes callbacks.
   2962           *
   2963           * @param   dataType - data types defined in zcl.h
   2964           * @param   attrData - pointer to the attribute data
   2965           * @param   buf - where to put the serialized data
   2966           *
   2967           * @return  pointer to end of destination buffer
   2968           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2969          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2970          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   EC           MOV       A,R4
   \   00000A   FA           MOV       R2,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FB           MOV       R3,A
   2971            uint8 *pStr;
   2972            uint16 len;
   2973          
   2974            if ( attrData == NULL )
   \   00000D   EE           MOV       A,R6
   \   00000E   4F           ORL       A,R7
   \   00000F   7003         JNZ       $+5
   \   000011   02....       LJMP      ??zclSerializeData_0 & 0xFFFF
   2975            {
   2976              return ( buf );
   2977            }
   2978          
   2979            switch ( dataType )
   \   000014   EC           MOV       A,R4
   \   000015   2402         ADD       A,#0x2
   \   000017   F5..         MOV       ?V4,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   F5..         MOV       ?V5,A
   \   00001D   8C82         MOV       DPL,R4
   \   00001F   8D83         MOV       DPH,R5
   \   000021   A3           INC       DPTR
   \   000022   AC82         MOV       R4,DPL
   \   000024   AD83         MOV       R5,DPH
   \   000026   8E..         MOV       ?V0,R6
   \   000028   8F..         MOV       ?V1,R7
   \   00002A   75..00       MOV       ?V2,#0x0
   \   00002D   E9           MOV       A,R1
   \   00002E   12....       LCALL     ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000031   04           DB        4
   \   000032   41           DB        65
   \   000033   42           DB        66
   \   000034   ....         DW        ??zclSerializeData_1
   \   000036   43           DB        67
   \   000037   44           DB        68
   \   000038   ....         DW        ??zclSerializeData_2
   \   00003A   E0           DB        224
   \   00003B   E2           DB        226
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   E8           DB        232
   \   00003F   E9           DB        233
   \   000040   ....         DW        ??zclSerializeData_4
   \   000042   25           DB        37
   \   000043   08           DB        8
   \   000044   ....         DW        ??zclSerializeData_5
   \   000046   09           DB        9
   \   000047   ....         DW        ??zclSerializeData_4
   \   000049   0A           DB        10
   \   00004A   ....         DW        ??zclSerializeData_6
   \   00004C   0B           DB        11
   \   00004D   ....         DW        ??zclSerializeData_3
   \   00004F   10           DB        16
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   18           DB        24
   \   000053   ....         DW        ??zclSerializeData_5
   \   000055   19           DB        25
   \   000056   ....         DW        ??zclSerializeData_4
   \   000058   1A           DB        26
   \   000059   ....         DW        ??zclSerializeData_6
   \   00005B   1B           DB        27
   \   00005C   ....         DW        ??zclSerializeData_3
   \   00005E   1C           DB        28
   \   00005F   ....         DW        ??zclSerializeData_7
   \   000061   1D           DB        29
   \   000062   ....         DW        ??zclSerializeData_8
   \   000064   1E           DB        30
   \   000065   ....         DW        ??zclSerializeData_9
   \   000067   1F           DB        31
   \   000068   ....         DW        ??zclSerializeData_10
   \   00006A   20           DB        32
   \   00006B   ....         DW        ??zclSerializeData_5
   \   00006D   21           DB        33
   \   00006E   ....         DW        ??zclSerializeData_4
   \   000070   22           DB        34
   \   000071   ....         DW        ??zclSerializeData_6
   \   000073   23           DB        35
   \   000074   ....         DW        ??zclSerializeData_3
   \   000076   24           DB        36
   \   000077   ....         DW        ??zclSerializeData_7
   \   000079   25           DB        37
   \   00007A   ....         DW        ??zclSerializeData_8
   \   00007C   26           DB        38
   \   00007D   ....         DW        ??zclSerializeData_9
   \   00007F   27           DB        39
   \   000080   ....         DW        ??zclSerializeData_10
   \   000082   28           DB        40
   \   000083   ....         DW        ??zclSerializeData_5
   \   000085   29           DB        41
   \   000086   ....         DW        ??zclSerializeData_4
   \   000088   2A           DB        42
   \   000089   ....         DW        ??zclSerializeData_6
   \   00008B   2B           DB        43
   \   00008C   ....         DW        ??zclSerializeData_3
   \   00008E   2C           DB        44
   \   00008F   ....         DW        ??zclSerializeData_7
   \   000091   2D           DB        45
   \   000092   ....         DW        ??zclSerializeData_8
   \   000094   2E           DB        46
   \   000095   ....         DW        ??zclSerializeData_9
   \   000097   2F           DB        47
   \   000098   ....         DW        ??zclSerializeData_10
   \   00009A   30           DB        48
   \   00009B   ....         DW        ??zclSerializeData_5
   \   00009D   31           DB        49
   \   00009E   ....         DW        ??zclSerializeData_4
   \   0000A0   38           DB        56
   \   0000A1   ....         DW        ??zclSerializeData_4
   \   0000A3   39           DB        57
   \   0000A4   ....         DW        ??zclSerializeData_3
   \   0000A6   3A           DB        58
   \   0000A7   ....         DW        ??zclSerializeData_10
   \   0000A9   EA           DB        234
   \   0000AA   ....         DW        ??zclSerializeData_3
   \   0000AC   F0           DB        240
   \   0000AD   ....         DW        ??zclSerializeData_10
   \   0000AF   F1           DB        241
   \   0000B0   ....         DW        ??zclSerializeData_11
   \   0000B2   ....         DW        ??zclSerializeData_0
   2980            {
   2981              case ZCL_DATATYPE_DATA8:
   2982              case ZCL_DATATYPE_BOOLEAN:
   2983              case ZCL_DATATYPE_BITMAP8:
   2984              case ZCL_DATATYPE_INT8:
   2985              case ZCL_DATATYPE_UINT8:
   2986              case ZCL_DATATYPE_ENUM8:
   2987                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   0000B4   8E82         MOV       DPL,R6
   \   0000B6   8F83         MOV       DPH,R7
   \   0000B8   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   0000BB   EC           MOV       A,R4
   \   0000BC   FA           MOV       R2,A
   \   0000BD   ED           MOV       A,R5
   \   0000BE   FB           MOV       R3,A
   2988                 break;
   \   0000BF   02....       LJMP      ??zclSerializeData_0 & 0xFFFF
   2989          
   2990              case ZCL_DATATYPE_DATA16:
   2991              case ZCL_DATATYPE_BITMAP16:
   2992              case ZCL_DATATYPE_UINT16:
   2993              case ZCL_DATATYPE_INT16:
   2994              case ZCL_DATATYPE_ENUM16:
   2995              case ZCL_DATATYPE_SEMI_PREC:
   2996              case ZCL_DATATYPE_CLUSTER_ID:
   2997              case ZCL_DATATYPE_ATTR_ID:
   2998                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000C2   12....       LCALL     ?Subroutine22 & 0xFFFF
   2999                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_345:
   \   0000C5   8C82         MOV       DPL,R4
   \   0000C7   8D83         MOV       DPH,R5
   \   0000C9   F0           MOVX      @DPTR,A
   \   0000CA   0A           INC       R2
   \   0000CB   0A           INC       R2
   \   0000CC   AB..         MOV       R3,?V5
   3000                break;
   \   0000CE   02....       LJMP      ??zclSerializeData_0 & 0xFFFF
   3001          
   3002              case ZCL_DATATYPE_DATA24:
   3003              case ZCL_DATATYPE_BITMAP24:
   3004              case ZCL_DATATYPE_UINT24:
   3005              case ZCL_DATATYPE_INT24:
   3006                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000D1   8E82         MOV       DPL,R6
   \   0000D3   8F83         MOV       DPH,R7
   \   0000D5   78..         MOV       R0,#?V0
   \   0000D7   12....       LCALL     ?L_MOV_X
   \   0000DA   8A82         MOV       DPL,R2
   \   0000DC   8B83         MOV       DPH,R3
   \   0000DE   E5..         MOV       A,?V0
   \   0000E0   12....       LCALL     ?Subroutine123 & 0xFFFF
   3007                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_350:
   \   0000E3   78..         MOV       R0,#?V0
   \   0000E5   12....       LCALL     ?L_MOV_X
   \   0000E8   E5..         MOV       A,?V1
   \   0000EA   8C82         MOV       DPL,R4
   \   0000EC   8D83         MOV       DPH,R5
   \   0000EE   12....       LCALL     ?Subroutine123 & 0xFFFF
   3008                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_351:
   \   0000F1   78..         MOV       R0,#?V0
   \   0000F3   12....       LCALL     ?L_MOV_X
   \   0000F6   7410         MOV       A,#0x10
   \   0000F8   78..         MOV       R0,#?V0
   \   0000FA   12....       LCALL     ?UL_SHR
   \   0000FD   85..82       MOV       DPL,?V4
   \   000100   85..83       MOV       DPH,?V5
   \   000103   E5..         MOV       A,?V0
   \   000105   F0           MOVX      @DPTR,A
   \   000106   EA           MOV       A,R2
   \   000107   2403         ADD       A,#0x3
   \   000109   FA           MOV       R2,A
   \   00010A   506B         JNC       ??zclSerializeData_0
   \   00010C   0B           INC       R3
   3009                break;
   \   00010D   8068         SJMP      ??zclSerializeData_0
   3010          
   3011              case ZCL_DATATYPE_DATA32:
   3012              case ZCL_DATATYPE_BITMAP32:
   3013              case ZCL_DATATYPE_UINT32:
   3014              case ZCL_DATATYPE_INT32:
   3015              case ZCL_DATATYPE_SINGLE_PREC:
   3016              case ZCL_DATATYPE_TOD:
   3017              case ZCL_DATATYPE_DATE:
   3018              case ZCL_DATATYPE_UTC:
   3019              case ZCL_DATATYPE_BAC_OID:
   3020                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   00010F                ; Setup parameters for call to function osal_buffer_uint32
   \   00010F   8E82         MOV       DPL,R6
   \   000111   8F83         MOV       DPH,R7
   \   000113   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000116   12....       LCALL     `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   000119   7404         MOV       A,#0x4
   \   00011B   12....       LCALL     ?DEALLOC_XSTACK8
   3021                break;
   \   00011E   8057         SJMP      ??zclSerializeData_0
   3022          
   3023              case ZCL_DATATYPE_BITMAP40:
   3024              case ZCL_DATATYPE_UINT40:
   3025              case ZCL_DATATYPE_INT40:
   3026                pStr = (uint8*)attrData;
   3027                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000120                ; Setup parameters for call to function osal_memcpy
   \   000120   78..         MOV       R0,#?V0
   \   000122   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000125   7C05         MOV       R4,#0x5
   \   000127   8046         SJMP      ??zclSerializeData_12
   3028                break;
   3029          
   3030              case ZCL_DATATYPE_BITMAP48:
   3031              case ZCL_DATATYPE_UINT48:
   3032              case ZCL_DATATYPE_INT48:
   3033                pStr = (uint8*)attrData;
   3034                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   000129                ; Setup parameters for call to function osal_memcpy
   \   000129   78..         MOV       R0,#?V0
   \   00012B   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00012E   7C06         MOV       R4,#0x6
   \   000130   803D         SJMP      ??zclSerializeData_12
   3035                break;
   3036          
   3037              case ZCL_DATATYPE_BITMAP56:
   3038              case ZCL_DATATYPE_UINT56:
   3039              case ZCL_DATATYPE_INT56:
   3040                pStr = (uint8*)attrData;
   3041                buf = zcl_memcpy( buf, pStr, 7 );
   \                     ??zclSerializeData_9:
   \   000132                ; Setup parameters for call to function osal_memcpy
   \   000132   78..         MOV       R0,#?V0
   \   000134   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000137   7C07         MOV       R4,#0x7
   \   000139   8034         SJMP      ??zclSerializeData_12
   3042                break;
   3043          
   3044              case ZCL_DATATYPE_BITMAP64:
   3045              case ZCL_DATATYPE_DOUBLE_PREC:
   3046              case ZCL_DATATYPE_IEEE_ADDR:
   3047              case ZCL_DATATYPE_UINT64:
   3048              case ZCL_DATATYPE_INT64:
   3049                pStr = (uint8*)attrData;
   3050                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_10:
   \   00013B                ; Setup parameters for call to function osal_memcpy
   \   00013B   78..         MOV       R0,#?V0
   \   00013D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000140   7C08         MOV       R4,#0x8
   \   000142   802B         SJMP      ??zclSerializeData_12
   3051                break;
   3052          
   3053              case ZCL_DATATYPE_CHAR_STR:
   3054              case ZCL_DATATYPE_OCTET_STR:
   3055                pStr = (uint8*)attrData;
   3056                len = *pStr;
   3057                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   000144                ; Setup parameters for call to function osal_memcpy
   \   000144   78..         MOV       R0,#?V0
   \   000146   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000149   8E82         MOV       DPL,R6
   \   00014B   8F83         MOV       DPH,R7
   \   00014D   E0           MOVX      A,@DPTR
   \   00014E   2401         ADD       A,#0x1
   \   000150   FC           MOV       R4,A
   \   000151   E4           CLR       A
   \   000152   3400         ADDC      A,#0x0
   \   000154   800F         SJMP      ??zclSerializeData_13
   3058                break;
   3059          
   3060              case ZCL_DATATYPE_LONG_CHAR_STR:
   3061              case ZCL_DATATYPE_LONG_OCTET_STR:
   3062                pStr = (uint8*)attrData;
   3063                len = BUILD_UINT16( pStr[0], pStr[1] );
   3064                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   000156                ; Setup parameters for call to function osal_memcpy
   \   000156   78..         MOV       R0,#?V0
   \   000158   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00015B   8E82         MOV       DPL,R6
   \   00015D   8F83         MOV       DPH,R7
   \   00015F   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000162   FC           MOV       R4,A
   \   000163   E4           CLR       A
   \   000164   39           ADDC      A,R1
   \                     ??zclSerializeData_13:
   \   000165   FD           MOV       R5,A
   \   000166   8009         SJMP      ??zclSerializeData_14
   3065                break;
   3066          
   3067              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3068                pStr = (uint8*)attrData;
   3069                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_11:
   \   000168                ; Setup parameters for call to function osal_memcpy
   \   000168   78..         MOV       R0,#?V0
   \   00016A   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00016D   7C10         MOV       R4,#0x10
   \                     ??zclSerializeData_12:
   \   00016F   7D00         MOV       R5,#0x0
   \                     ??zclSerializeData_14:
   \   000171   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000174   12....       LCALL     ?DEALLOC_XSTACK8
   3070                break;
   3071          
   3072              case ZCL_DATATYPE_NO_DATA:
   3073              case ZCL_DATATYPE_UNKNOWN:
   3074                // Fall through
   3075          
   3076              default:
   3077                break;
   3078            }
   3079          
   3080            return ( buf );
   \                     ??zclSerializeData_0:
   \   000177   02....       LJMP      ?Subroutine8 & 0xFFFF
   3081          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   E0           MOVX      A,@DPTR
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009                REQUIRE ??Subroutine176_0
   \   000009                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   F9           MOV       R1,A
   \   000004   EC           MOV       A,R4
   \   000005   2402         ADD       A,#0x2
   \   000007   22           RET
   3082          
   3083          #if defined ZCL_REPORTING_DEVICE || defined ZCL_REPORT_CONFIGURING_DEVICE
   3084          /*********************************************************************
   3085           * @fn      zclAnalogDataType
   3086           *
   3087           * @brief   Checks to see if Data Type is Analog
   3088           *
   3089           * @param   dataType - data type
   3090           *
   3091           * @return  TRUE if data type is analog
   3092           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3093          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   3094          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   3095            uint8 analog;
   3096          
   3097            switch ( dataType )
   \   000005   12....       LCALL     ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   3098            {
   3099              case ZCL_DATATYPE_UINT8:
   3100              case ZCL_DATATYPE_UINT16:
   3101              case ZCL_DATATYPE_UINT24:
   3102              case ZCL_DATATYPE_UINT32:
   3103              case ZCL_DATATYPE_UINT40:
   3104              case ZCL_DATATYPE_UINT48:
   3105              case ZCL_DATATYPE_UINT56:
   3106              case ZCL_DATATYPE_UINT64:
   3107              case ZCL_DATATYPE_INT8:
   3108              case ZCL_DATATYPE_INT16:
   3109              case ZCL_DATATYPE_INT24:
   3110              case ZCL_DATATYPE_INT32:
   3111              case ZCL_DATATYPE_INT40:
   3112              case ZCL_DATATYPE_INT48:
   3113              case ZCL_DATATYPE_INT56:
   3114              case ZCL_DATATYPE_INT64:
   3115              case ZCL_DATATYPE_SEMI_PREC:
   3116              case ZCL_DATATYPE_SINGLE_PREC:
   3117              case ZCL_DATATYPE_DOUBLE_PREC:
   3118              case ZCL_DATATYPE_TOD:
   3119              case ZCL_DATATYPE_DATE:
   3120              case ZCL_DATATYPE_UTC:
   3121                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV       R1,#0x1
   3122                break;
   \   00001A   8002         SJMP      ??zclAnalogDataType_2
   3123          
   3124              default:
   3125                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV       R1,#0x0
   3126                break;
   3127            }
   3128          
   3129            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP      ?Subroutine0 & 0xFFFF
   3130          }
   3131          
   3132          /*********************************************************************
   3133           * @fn      zclIsLittleEndianMachine
   3134           *
   3135           * @brief   Verifies endianness in system.
   3136           *
   3137           * @param   none
   3138           *
   3139           * @return  MSB-00 or LSB-01 depending on endianness in the system
   3140           */
   3141          static int zclIsLittleEndianMachine(void)
   3142          {
   3143            uint16 test = 0x0001;
   3144          
   3145            return (*((uint8 *)(&test)));
   3146          }
   3147          
   3148          /*********************************************************************
   3149           * @fn      zcl_BuildAnalogData
   3150           *
   3151           * @brief   Build an analog arribute out of sequential bytes.
   3152           *
   3153           * @param   dataType - type of data
   3154           * @param   pData - pointer to data
   3155           * @param   pBuf - where to put the data
   3156           *
   3157           * @return  none
   3158           */
   3159          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   3160          {
   3161            int current_byte_index;
   3162            int remaining_bytes;
   3163            int step;
   3164          
   3165            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   3166          
   3167            // decide if move forward or backwards to copy data
   3168            if ( zclIsLittleEndianMachine() )
   3169            {
   3170              step = 1;
   3171              current_byte_index = 0;
   3172            }
   3173            else
   3174            {
   3175              step = -1;
   3176              current_byte_index = remaining_bytes - 1;
   3177            }
   3178          
   3179            while ( remaining_bytes-- )
   3180            {
   3181              pData[current_byte_index] = *(pBuf++);
   3182              current_byte_index += step;
   3183            }
   3184          }
   3185          #endif
   3186          
   3187          /*********************************************************************
   3188           * @fn      zclGetDataTypeLength
   3189           *
   3190           * @brief   Return the length of the datatype in octet.
   3191           *
   3192           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   3193           *                ZCL_DATATYPE_CHAR_STR data types.
   3194           *
   3195           * @param   dataType - data type
   3196           *
   3197           * @return  length of data
   3198           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3199          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   3200          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   3201            uint8 len;
   3202          
   3203            switch ( dataType )
   \   000001   24F8         ADD       A,#-0x8
   \   000003   6078         JZ        ??zclGetDataTypeLength_0
   \   000005   14           DEC       A
   \   000006   6079         JZ        ??zclGetDataTypeLength_1
   \   000008   14           DEC       A
   \   000009   607A         JZ        ??zclGetDataTypeLength_2
   \   00000B   14           DEC       A
   \   00000C   607B         JZ        ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD       A,#-0x5
   \   000010   606B         JZ        ??zclGetDataTypeLength_0
   \   000012   24F8         ADD       A,#-0x8
   \   000014   6067         JZ        ??zclGetDataTypeLength_0
   \   000016   14           DEC       A
   \   000017   6068         JZ        ??zclGetDataTypeLength_1
   \   000019   14           DEC       A
   \   00001A   6069         JZ        ??zclGetDataTypeLength_2
   \   00001C   14           DEC       A
   \   00001D   606A         JZ        ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD       A,#-0x5
   \   000021   605A         JZ        ??zclGetDataTypeLength_0
   \   000023   14           DEC       A
   \   000024   605B         JZ        ??zclGetDataTypeLength_1
   \   000026   14           DEC       A
   \   000027   605C         JZ        ??zclGetDataTypeLength_2
   \   000029   14           DEC       A
   \   00002A   605D         JZ        ??zclGetDataTypeLength_3
   \   00002C   14           DEC       A
   \   00002D   605E         JZ        ??zclGetDataTypeLength_4
   \   00002F   14           DEC       A
   \   000030   605F         JZ        ??zclGetDataTypeLength_5
   \   000032   14           DEC       A
   \   000033   6060         JZ        ??zclGetDataTypeLength_6
   \   000035   14           DEC       A
   \   000036   6061         JZ        ??zclGetDataTypeLength_7
   \   000038   14           DEC       A
   \   000039   6042         JZ        ??zclGetDataTypeLength_0
   \   00003B   14           DEC       A
   \   00003C   6043         JZ        ??zclGetDataTypeLength_1
   \   00003E   14           DEC       A
   \   00003F   6044         JZ        ??zclGetDataTypeLength_2
   \   000041   14           DEC       A
   \   000042   6045         JZ        ??zclGetDataTypeLength_3
   \   000044   14           DEC       A
   \   000045   6046         JZ        ??zclGetDataTypeLength_4
   \   000047   14           DEC       A
   \   000048   6047         JZ        ??zclGetDataTypeLength_5
   \   00004A   14           DEC       A
   \   00004B   6048         JZ        ??zclGetDataTypeLength_6
   \   00004D   14           DEC       A
   \   00004E   6049         JZ        ??zclGetDataTypeLength_7
   \   000050   14           DEC       A
   \   000051   602A         JZ        ??zclGetDataTypeLength_0
   \   000053   14           DEC       A
   \   000054   602B         JZ        ??zclGetDataTypeLength_1
   \   000056   24F9         ADD       A,#-0x7
   \   000058   6027         JZ        ??zclGetDataTypeLength_1
   \   00005A   14           DEC       A
   \   00005B   602C         JZ        ??zclGetDataTypeLength_3
   \   00005D   14           DEC       A
   \   00005E   6039         JZ        ??zclGetDataTypeLength_7
   \   000060   245A         ADD       A,#0x5a
   \   000062   6025         JZ        ??zclGetDataTypeLength_3
   \   000064   14           DEC       A
   \   000065   6022         JZ        ??zclGetDataTypeLength_3
   \   000067   14           DEC       A
   \   000068   601F         JZ        ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD       A,#-0x6
   \   00006C   6013         JZ        ??zclGetDataTypeLength_1
   \   00006E   14           DEC       A
   \   00006F   6010         JZ        ??zclGetDataTypeLength_1
   \   000071   14           DEC       A
   \   000072   6015         JZ        ??zclGetDataTypeLength_3
   \   000074   24FA         ADD       A,#-0x6
   \   000076   6021         JZ        ??zclGetDataTypeLength_7
   \   000078   14           DEC       A
   \   000079   6022         JZ        ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP      ??zclGetDataTypeLength_9
   3204            {
   3205              case ZCL_DATATYPE_DATA8:
   3206              case ZCL_DATATYPE_BOOLEAN:
   3207              case ZCL_DATATYPE_BITMAP8:
   3208              case ZCL_DATATYPE_INT8:
   3209              case ZCL_DATATYPE_UINT8:
   3210              case ZCL_DATATYPE_ENUM8:
   3211                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV       R1,#0x1
   3212                break;
   \   00007F   8022         SJMP      ??zclGetDataTypeLength_10
   3213          
   3214              case ZCL_DATATYPE_DATA16:
   3215              case ZCL_DATATYPE_BITMAP16:
   3216              case ZCL_DATATYPE_UINT16:
   3217              case ZCL_DATATYPE_INT16:
   3218              case ZCL_DATATYPE_ENUM16:
   3219              case ZCL_DATATYPE_SEMI_PREC:
   3220              case ZCL_DATATYPE_CLUSTER_ID:
   3221              case ZCL_DATATYPE_ATTR_ID:
   3222                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV       R1,#0x2
   3223                break;
   \   000083   801E         SJMP      ??zclGetDataTypeLength_10
   3224          
   3225              case ZCL_DATATYPE_DATA24:
   3226              case ZCL_DATATYPE_BITMAP24:
   3227              case ZCL_DATATYPE_UINT24:
   3228              case ZCL_DATATYPE_INT24:
   3229                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV       R1,#0x3
   3230                break;
   \   000087   801A         SJMP      ??zclGetDataTypeLength_10
   3231          
   3232              case ZCL_DATATYPE_DATA32:
   3233              case ZCL_DATATYPE_BITMAP32:
   3234              case ZCL_DATATYPE_UINT32:
   3235              case ZCL_DATATYPE_INT32:
   3236              case ZCL_DATATYPE_SINGLE_PREC:
   3237              case ZCL_DATATYPE_TOD:
   3238              case ZCL_DATATYPE_DATE:
   3239              case ZCL_DATATYPE_UTC:
   3240              case ZCL_DATATYPE_BAC_OID:
   3241                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV       R1,#0x4
   3242                break;
   \   00008B   8016         SJMP      ??zclGetDataTypeLength_10
   3243          
   3244             case ZCL_DATATYPE_UINT40:
   3245             case ZCL_DATATYPE_INT40:
   3246                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV       R1,#0x5
   3247                 break;
   \   00008F   8012         SJMP      ??zclGetDataTypeLength_10
   3248          
   3249             case ZCL_DATATYPE_UINT48:
   3250             case ZCL_DATATYPE_INT48:
   3251                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV       R1,#0x6
   3252                 break;
   \   000093   800E         SJMP      ??zclGetDataTypeLength_10
   3253          
   3254             case ZCL_DATATYPE_UINT56:
   3255             case ZCL_DATATYPE_INT56:
   3256                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV       R1,#0x7
   3257                 break;
   \   000097   800A         SJMP      ??zclGetDataTypeLength_10
   3258          
   3259             case ZCL_DATATYPE_DOUBLE_PREC:
   3260             case ZCL_DATATYPE_IEEE_ADDR:
   3261             case ZCL_DATATYPE_UINT64:
   3262             case ZCL_DATATYPE_INT64:
   3263               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV       R1,#0x8
   3264               break;
   \   00009B   8006         SJMP      ??zclGetDataTypeLength_10
   3265          
   3266              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3267               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV       R1,#0x10
   3268               break;
   \   00009F   8002         SJMP      ??zclGetDataTypeLength_10
   3269          
   3270              case ZCL_DATATYPE_NO_DATA:
   3271              case ZCL_DATATYPE_UNKNOWN:
   3272                // Fall through
   3273          
   3274              default:
   3275                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV       R1,#0x0
   3276                break;
   3277            }
   3278          
   3279            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP      ?BRET
   3280          }
   3281          
   3282          /*********************************************************************
   3283           * @fn      zclGetAttrDataLength
   3284           *
   3285           * @brief   Return the length of the attribute.
   3286           *
   3287           * @param   dataType - data type
   3288           * @param   pData - pointer to data
   3289           *
   3290           * @return  returns atrribute length
   3291           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3292          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   3293          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   3294            uint16 dataLen = 0;
   3295          
   3296            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV       A,#0x44
   \   000009   6E           XRL       A,R6
   \   00000A   6005         JZ        ??zclGetAttrDataLength_0
   \   00000C   7443         MOV       A,#0x43
   \   00000E   6E           XRL       A,R6
   \   00000F   700C         JNZ       ??zclGetAttrDataLength_1
   3297            {
   3298              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   12....       LCALL     ?Subroutine94 & 0xFFFF
   3299            }
   \                     ??CrossCallReturnLabel_158:
   \   000018   FA           MOV       R2,A
   \   000019   E4           CLR       A
   \   00001A   39           ADDC      A,R1
   \   00001B   8015         SJMP      ??zclGetAttrDataLength_2
   3300            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV       A,#0x42
   \   00001F   6E           XRL       A,R6
   \   000020   6005         JZ        ??zclGetAttrDataLength_3
   \   000022   7441         MOV       A,#0x41
   \   000024   6E           XRL       A,R6
   \   000025   700E         JNZ       ??zclGetAttrDataLength_4
   3301            {
   3302              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV       DPL,R2
   \   000029   8B83         MOV       DPH,R3
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   2401         ADD       A,#0x1
   \   00002E   FA           MOV       R2,A
   \   00002F   E4           CLR       A
   \   000030   3400         ADDC      A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV       R3,A
   \   000033   8007         SJMP      ??zclGetAttrDataLength_5
   3303            }
   3304            else
   3305            {
   3306              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL     `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV       A,R1
   \   000039   FA           MOV       R2,A
   \   00003A   7B00         MOV       R3,#0x0
   3307            }
   3308          
   3309            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP      ??Subroutine171_0 & 0xFFFF
   3310          }
   3311          
   3312          #ifdef ZCL_READ
   3313          /*********************************************************************
   3314           * @fn      zclReadAttrData
   3315           *
   3316           * @brief   Read the attribute's current value into pAttrData.
   3317           *          NOTE - Not compatible with application's attributes callbacks.
   3318           *
   3319           * @param   pAttrData - where to put attribute data
   3320           * @param   pAttr - pointer to attribute
   3321           * @param   pDataLen - where to put attribute data length
   3322           *
   3323           * @return Success
   3324           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine156_0
   \   000001                ; // Fall through to label ??Subroutine156_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3325          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   3326          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   3327            uint16 dataLen;
   3328          
   3329            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV       A,R4
   \   00000A   2406         ADD       A,#0x6
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   3D           ADDC      A,R5
   \   00000F   88..         MOV       ?V0,R0
   \   000011   F5..         MOV       ?V1,A
   \   000013   8882         MOV       DPL,R0
   \   000015   F583         MOV       DPH,A
   \   000017   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   00001A   7004         JNZ       ??zclReadAttrData_0
   3330            {
   3331              return ( ZCL_STATUS_FAILURE );
   \   00001C   7901         MOV       R1,#0x1
   \   00001E   8044         SJMP      ??zclReadAttrData_1
   3332            }
   3333          
   3334            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000020                ; Setup parameters for call to function zclGetAttrDataLength
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000027   8A..         MOV       ?V2,R2
   \   000029   8B..         MOV       ?V3,R3
   3335            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   00002B                ; Setup parameters for call to function osal_memcpy
   \   00002B   85..82       MOV       DPL,?V0
   \   00002E   85..83       MOV       DPH,?V1
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F5..         MOV       ?V0,A
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   85....       MOV       ?V4,?V0
   \   000039   F5..         MOV       ?V5,A
   \   00003B   75..00       MOV       ?V6,#0x0
   \   00003E   78..         MOV       R0,#?V4
   \   000040   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000043   AC..         MOV       R4,?V2
   \   000045   AD..         MOV       R5,?V3
   \   000047   EE           MOV       A,R6
   \   000048   FA           MOV       R2,A
   \   000049   EF           MOV       A,R7
   \   00004A   FB           MOV       R3,A
   \   00004B   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   00004E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000051   740F         MOV       A,#0xf
   \   000053   12....       LCALL     ?XSTACK_DISP0_8
   \   000056   12....       LCALL     ??Subroutine166_0 & 0xFFFF
   3336          
   3337            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_289:
   \   000059   6007         JZ        ??zclReadAttrData_2
   3338            {
   3339              *pDataLen = dataLen;
   \   00005B   E5..         MOV       A,?V2
   \   00005D   F0           MOVX      @DPTR,A
   \   00005E   A3           INC       DPTR
   \   00005F   E5..         MOV       A,?V3
   \   000061   F0           MOVX      @DPTR,A
   3340            }
   3341          
   3342            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   000062   7900         MOV       R1,#0x0
   \                     ??zclReadAttrData_1:
   \   000064                REQUIRE ?Subroutine8
   \   000064                ; // Fall through to label ?Subroutine8
   3343          }
   3344          
   3345          /*********************************************************************
   3346           * @fn      zcl_ReadAttrData
   3347           *
   3348           * @brief   Read the attribute's current value into pAttrData.
   3349           *          Use application's callback function if assigned to this attribute.
   3350           *
   3351           * @param   endpoint - application's endpoint
   3352           * @param   clusterId - cluster that attribute belongs to
   3353           * @param   attrId - attribute id
   3354           * @param   pAttrData - where to put attribute data
   3355           * @param   pDataLen - where to put attribute data length
   3356           *
   3357           * @return  Successful if data was read
   3358           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine173_0
   \   000003                ; // Fall through to label ??Subroutine173_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3359          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3360                                                   uint8 *pAttrData, uint16 *pDataLen )
   3361          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   EC           MOV       A,R4
   \   000011   FE           MOV       R6,A
   \   000012   ED           MOV       A,R5
   \   000013   FF           MOV       R7,A
   3362            zclAttrRec_t attrRec;
   3363          
   3364            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V4,R0
   \   00001A   89..         MOV       ?V5,R1
   \   00001C   78..         MOV       R0,#?V4
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV       R1,?V2
   \   000023   12....       LCALL     ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000026   12....       LCALL     ?DEALLOC_XSTACK8
   \   000029   E9           MOV       A,R1
   \   00002A   7004         JNZ       ??zcl_ReadAttrData_0
   3365            {
   3366              return ( ZCL_STATUS_FAILURE );
   \   00002C   7901         MOV       R1,#0x1
   \   00002E   804C         SJMP      ??zcl_ReadAttrData_1
   3367            }
   \                     ??zcl_ReadAttrData_0:
   \   000030   7418         MOV       A,#0x18
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_467:
   \   000038   741A         MOV       A,#0x1a
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine55 & 0xFFFF
   3368          
   3369            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_89:
   \   000040   7406         MOV       A,#0x6
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   000048   78..         MOV       R0,#?V4
   \   00004A   6016         JZ        ??zcl_ReadAttrData_2
   3370            {
   3371              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004C                ; Setup parameters for call to function zclReadAttrData
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004F   7402         MOV       A,#0x2
   \   000051   12....       LCALL     ?XSTACK_DISP102_8
   \   000054   AA..         MOV       R2,?V6
   \   000056   AB..         MOV       R3,?V7
   \   000058   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   00005B   7402         MOV       A,#0x2
   \   00005D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000060   801A         SJMP      ??zcl_ReadAttrData_1
   3372            }
   3373            else
   3374            {
   3375              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000062                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   78..         MOV       R0,#?V6
   \   000067   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006A   EE           MOV       A,R6
   \   00006B   FC           MOV       R4,A
   \   00006C   EF           MOV       A,R7
   \   00006D   FD           MOV       R5,A
   \   00006E   AA..         MOV       R2,?V0
   \   000070   AB..         MOV       R3,?V1
   \   000072   A9..         MOV       R1,?V2
   \   000074   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000077   7404         MOV       A,#0x4
   \   000079   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007C   7408         MOV       A,#0x8
   3376            }
   \   00007E   02....       LJMP      ?Subroutine9 & 0xFFFF
   3377          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V6,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V7,A
   \   000007   22           RET
   3378          
   3379          /*********************************************************************
   3380           * @fn      zclGetAttrDataLengthUsingCB
   3381           *
   3382           * @brief   Use application's callback to get the length of the attribute's
   3383           *          current value stored in the database.
   3384           *
   3385           * @param   endpoint - application's endpoint
   3386           * @param   clusterId - cluster that attribute belongs to
   3387           * @param   attrId - attribute id
   3388           *
   3389           * @return  returns attribute length
   3390           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3391          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3392          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V4,R2
   \   00000C   8B..         MOV       ?V5,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3393            uint16 dataLen = 0;
   \   000012   85..82       MOV       DPL,?XSP + 0
   \   000015   85..83       MOV       DPH,?XSP + 1
   \   000018   E4           CLR       A
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   A3           INC       DPTR
   \   00001B   F0           MOVX      @DPTR,A
   3394            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV       ?V0,R2
   \   000021   8B..         MOV       ?V1,R3
   3395          
   3396            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV       A,R2
   \   000024   4B           ORL       A,R3
   \   000025   602F         JZ        ??zclGetAttrDataLengthUsingCB_0
   3397            {
   3398              // Only get the attribute length
   3399              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000027                ; Setup parameters for indirect call
   \   000027   A8..         MOV       R0,?XSP + 0
   \   000029   A9..         MOV       R1,?XSP + 1
   \   00002B   88..         MOV       ?V6,R0
   \   00002D   89..         MOV       ?V7,R1
   \   00002F   78..         MOV       R0,#?V6
   \   000031   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000034   E4           CLR       A
   \   000035   F5..         MOV       ?V6,A
   \   000037   F5..         MOV       ?V7,A
   \   000039   78..         MOV       R0,#?V6
   \   00003B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003E   7900         MOV       R1,#0x0
   \   000040   EE           MOV       A,R6
   \   000041   FC           MOV       R4,A
   \   000042   EF           MOV       A,R7
   \   000043   FD           MOV       R5,A
   \   000044   AA..         MOV       R2,?V4
   \   000046   AB..         MOV       R3,?V5
   \   000048   85..82       MOV       DPL,?V0
   \   00004B   85..83       MOV       DPH,?V1
   \   00004E   12....       LCALL     ?CALL_IND
   \   000051   7404         MOV       A,#0x4
   \   000053   12....       LCALL     ?DEALLOC_XSTACK8
   3400            }
   3401          
   3402            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000056   85..82       MOV       DPL,?XSP + 0
   \   000059   85..83       MOV       DPH,?XSP + 1
   \   00005C   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   00005F   7402         MOV       A,#0x2
   \   000061   02....       LJMP      ?Subroutine9 & 0xFFFF
   3403          }
   3404          
   3405          /*********************************************************************
   3406           * @fn      zclReadAttrDataUsingCB
   3407           *
   3408           * @brief   Use application's callback to read the attribute's current
   3409           *          value stored in the database.
   3410           *
   3411           * @param   endpoint - application's endpoint
   3412           * @param   clusterId - cluster that attribute belongs to
   3413           * @param   attrId - attribute id
   3414           * @param   pAttrData - where to put attribute data
   3415           * @param   pDataLen - where to put attribute data length
   3416           *
   3417           * @return  Successful if data was read
   3418           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3419          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3420                                                   uint8 *pAttrData, uint16 *pDataLen )
   3421          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   3422            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV       ?V2,R2
   \   000012   8B..         MOV       ?V3,R3
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   3423          
   3424            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_468:
   \   00001C   E5..         MOV       A,?V6
   \   00001E   45..         ORL       A,?V7
   \   000020   600A         JZ        ??zclReadAttrDataUsingCB_0
   3425            {
   3426              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV       DPL,?V6
   \   000025   85..83       MOV       DPH,?V7
   \   000028   E4           CLR       A
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   F0           MOVX      @DPTR,A
   3427            }
   3428          
   3429            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV       A,R2
   \   00002D   4B           ORL       A,R3
   \   00002E   6027         JZ        ??zclReadAttrDataUsingCB_1
   3430            {
   3431              // Read the attribute value and its length
   3432              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000030                ; Setup parameters for indirect call
   \   000030   78..         MOV       R0,#?V6
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   7412         MOV       A,#0x12
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00003D   7901         MOV       R1,#0x1
   \   00003F   EE           MOV       A,R6
   \   000040   FC           MOV       R4,A
   \   000041   EF           MOV       A,R7
   \   000042   FD           MOV       R5,A
   \   000043   AA..         MOV       R2,?V0
   \   000045   AB..         MOV       R3,?V1
   \   000047   85..82       MOV       DPL,?V2
   \   00004A   85..83       MOV       DPH,?V3
   \   00004D   12....       LCALL     ?CALL_IND
   \   000050   7404         MOV       A,#0x4
   \   000052   12....       LCALL     ?DEALLOC_XSTACK8
   \   000055   8002         SJMP      ??zclReadAttrDataUsingCB_2
   3433            }
   3434          
   3435            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000057   79C1         MOV       R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   000059   02....       LJMP      ??Subroutine173_0 & 0xFFFF
   3436          }
   3437          
   3438          /*********************************************************************
   3439           * @fn      zclAuthorizeRead
   3440           *
   3441           * @brief   Use application's callback to authorize a Read operation
   3442           *          on a given attribute.
   3443           *
   3444           * @param   endpoint - application's endpoint
   3445           * @param   srcAddr - source Address
   3446           * @param   pAttr - pointer to attribute
   3447           *
   3448           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3449           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3450           */
   3451          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3452          {
   3453            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3454            {
   3455              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3456          
   3457              if ( pfnAuthorizeCB != NULL )
   3458              {
   3459                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3460              }
   3461            }
   3462          
   3463            return ( ZCL_STATUS_SUCCESS );
   3464          }
   3465          #endif // ZCL_READ
   3466          
   3467          #ifdef ZCL_WRITE
   3468          /*********************************************************************
   3469           * @fn      zclWriteAttrData
   3470           *
   3471           * @brief   Write the received data.
   3472           *
   3473           * @param   endpoint - application's endpoint
   3474           * @param   pAttr - where to write data to
   3475           * @param   pWriteRec - data to be written
   3476           *
   3477           * @return  Successful if data was written
   3478           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3479          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3480                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3481          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV       A,R4
   \   000006   FE           MOV       R6,A
   \   000007   ED           MOV       A,R5
   \   000008   FF           MOV       R7,A
   3482            uint8 status;
   3483          
   3484            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8C82         MOV       DPL,R4
   \   00000B   F583         MOV       DPH,A
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   A2E1         MOV       C,0xE0 /* A   */.1
   \   000015   506E         JNC       ??zclWriteAttrData_0
   3485            {
   3486              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL     `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV       A,R1
   \   00001B   F5..         MOV       ?V2,A
   3487              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7069         JNZ       ??zclWriteAttrData_1
   \   00001F   740F         MOV       A,#0xf
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ?Subroutine65 & 0xFFFF
   3488              {
   3489                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \                     ??CrossCallReturnLabel_104:
   \   000027   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   00002A   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   00002D   6013         JZ        ??zclWriteAttrData_2
   \   00002F                ; Setup parameters for indirect call
   \   00002F   AC..         MOV       R4,?V0
   \   000031   AD..         MOV       R5,?V1
   \   000033   EE           MOV       A,R6
   \   000034   FA           MOV       R2,A
   \   000035   EF           MOV       A,R7
   \   000036   FB           MOV       R3,A
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F583         MOV       DPH,A
   \   00003A   8882         MOV       DPL,R0
   \   00003C   12....       LCALL     ?CALL_IND
   \   00003F   E9           MOV       A,R1
   \   000040   603E         JZ        ??zclWriteAttrData_3
   3490                {
   3491                  // Write the attribute value
   3492                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000042   E5..         MOV       A,?V0
   \   000044   2403         ADD       A,#0x3
   \   000046   F8           MOV       R0,A
   \   000047   E4           CLR       A
   \   000048   35..         ADDC      A,?V1
   \   00004A   88..         MOV       ?V0,R0
   \   00004C   F5..         MOV       ?V1,A
   \   00004E                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004E   8882         MOV       DPL,R0
   \   000050   F583         MOV       DPH,A
   \   000052   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_374:
   \   000055   8E82         MOV       DPL,R6
   \   000057   8F83         MOV       DPH,R7
   \   000059   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   00005C   8A..         MOV       ?V4,R2
   \   00005E   8B..         MOV       ?V5,R3
   \   000060   AC..         MOV       R4,?V4
   \   000062   AD..         MOV       R5,?V5
   3493                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   000064                ; Setup parameters for call to function osal_memcpy
   \   000064   85..82       MOV       DPL,?V0
   \   000067   85..83       MOV       DPH,?V1
   \   00006A   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00006D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000070   8E82         MOV       DPL,R6
   \   000072   8F83         MOV       DPH,R7
   \   000074   A3           INC       DPTR
   \   000075   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_384:
   \   000078   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   3494          
   3495                  status = ZCL_STATUS_SUCCESS;
   \   00007E   8008         SJMP      ??zclWriteAttrData_1
   3496                }
   3497                else
   3498                {
   3499                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000080   75..87       MOV       ?V2,#-0x79
   \   000083   8003         SJMP      ??zclWriteAttrData_1
   3500                }
   3501              }
   3502            }
   3503            else
   3504            {
   3505              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   000085   75..88       MOV       ?V2,#-0x78
   3506            }
   3507          
   3508            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000088   A9..         MOV       R1,?V2
   \   00008A   02....       LJMP      ?Subroutine8 & 0xFFFF
   3509          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V1,A
   \   000007   22           RET
   3510          
   3511          /*********************************************************************
   3512           * @fn      zclWriteAttrDataUsingCB
   3513           *
   3514           * @brief   Use application's callback to write the attribute's current
   3515           *          value stored in the database.
   3516           *
   3517           * @param   endpoint - application's endpoint
   3518           * @param   pAttr - where to write data to
   3519           * @param   pAttrData - data to be written
   3520           *
   3521           * @return  Successful if data was written
   3522           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3523          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3524                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3525          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EC           MOV       A,R4
   \   000008   FE           MOV       R6,A
   \   000009   ED           MOV       A,R5
   \   00000A   FF           MOV       R7,A
   3526            uint8 status;
   3527          
   3528            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8C82         MOV       DPL,R4
   \   00000D   F583         MOV       DPH,A
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   A2E1         MOV       C,0xE0 /* A   */.1
   \   000017   504C         JNC       ??zclWriteAttrDataUsingCB_0
   3529            {
   3530              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL     `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV       A,R1
   \   00001D   F9           MOV       R1,A
   3531              if ( status == ZCL_STATUS_SUCCESS )
   \   00001E   7047         JNZ       ??zclWriteAttrDataUsingCB_1
   3532              {
   3533                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000020                ; Setup parameters for call to function zclGetReadWriteCB
   \   000020   A9..         MOV       R1,?V0
   \   000022   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000025   8A..         MOV       ?V2,R2
   \   000027   8B..         MOV       ?V3,R3
   3534                if ( pfnReadWriteCB != NULL )
   \   000029   EA           MOV       A,R2
   \   00002A   4B           ORL       A,R3
   \   00002B   6034         JZ        ??zclWriteAttrDataUsingCB_2
   3535                {
   3536                  // Write the attribute value
   3537                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3538                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002D                ; Setup parameters for indirect call
   \   00002D   E4           CLR       A
   \   00002E   F5..         MOV       ?V4,A
   \   000030   F5..         MOV       ?V5,A
   \   000032   78..         MOV       R0,#?V4
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   7410         MOV       A,#0x10
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00003F   7902         MOV       R1,#0x2
   \   000041   8E82         MOV       DPL,R6
   \   000043   8F83         MOV       DPH,R7
   \   000045   12....       LCALL     ??Subroutine187_0 & 0xFFFF
   3539                }
   \                     ??CrossCallReturnLabel_434:
   \   000048   8E82         MOV       DPL,R6
   \   00004A   8F83         MOV       DPH,R7
   \   00004C   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   00004F   85..82       MOV       DPL,?V2
   \   000052   85..83       MOV       DPH,?V3
   \   000055   12....       LCALL     ?CALL_IND
   \   000058   7404         MOV       A,#0x4
   \   00005A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005D   E9           MOV       A,R1
   \   00005E   F9           MOV       R1,A
   \   00005F   8006         SJMP      ??zclWriteAttrDataUsingCB_1
   3540                else
   3541                {
   3542                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000061   79C1         MOV       R1,#-0x3f
   \   000063   8002         SJMP      ??zclWriteAttrDataUsingCB_1
   3543                }
   3544              }
   3545            }
   3546            else
   3547            {
   3548              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000065   7988         MOV       R1,#-0x78
   3549            }
   3550          
   3551            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000067   80..         SJMP      ?Subroutine4
   3552          }
   3553          
   3554          /*********************************************************************
   3555           * @fn      zclAuthorizeWrite
   3556           *
   3557           * @brief   Use application's callback to authorize a Write operation
   3558           *          on a given attribute.
   3559           *
   3560           * @param   endpoint - application's endpoint
   3561           * @param   srcAddr - source Address
   3562           * @param   pAttr - pointer to attribute
   3563           *
   3564           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3565           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3566           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3567          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3568          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   3569            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV       DPL,R4
   \   00000F   8D83         MOV       DPH,R5
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   A2E5         MOV       C,0xE0 /* A   */.5
   \   000019   5014         JNC       ??zclAuthorizeWrite_0
   3570            {
   3571              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL     ?Subroutine118 & 0xFFFF
   3572          
   3573              if ( pfnAuthorizeCB != NULL )
   \                     ??CrossCallReturnLabel_191:
   \   00001E   600F         JZ        ??zclAuthorizeWrite_0
   3574              {
   3575                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000020                ; Setup parameters for indirect call
   \   000020   7902         MOV       R1,#0x2
   \   000022   AC..         MOV       R4,?V0
   \   000024   AD..         MOV       R5,?V1
   \   000026   EE           MOV       A,R6
   \   000027   FA           MOV       R2,A
   \   000028   EF           MOV       A,R7
   \   000029   FB           MOV       R3,A
   \   00002A   12....       LCALL     ?CALL_IND
   \   00002D   8002         SJMP      ??zclAuthorizeWrite_1
   3576              }
   3577            }
   3578          
   3579            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   00002F   7900         MOV       R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000031                REQUIRE ?Subroutine4
   \   000031                ; // Fall through to label ?Subroutine4
   3580          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   12....       LCALL     `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   000003   8A82         MOV       DPL,R2
   \   000005   8B83         MOV       DPH,R3
   \   000007   E582         MOV       A,DPL
   \   000009   4583         ORL       A,DPH
   \   00000B   22           RET
   3581          #endif // ZCL_WRITE
   3582          
   3583          #ifdef ZCL_READ
   3584          /*********************************************************************
   3585           * @fn      zclParseInReadCmd
   3586           *
   3587           * @brief   Parse the "Profile" Read Commands
   3588           *
   3589           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3590           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3591           *
   3592           * @param   pCmd - pointer to incoming data to parse
   3593           *
   3594           * @return  pointer to the parsed command structure
   3595           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3596          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3597          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3598            zclReadCmd_t *readCmd;
   3599            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine79 & 0xFFFF
   3600          
   3601            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_133:
   \   000008   12....       LCALL     ?Subroutine59 & 0xFFFF
   3602            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_96:
   \   00000B   6053         JZ        ??zclParseInReadCmd_0
   3603            {
   3604              uint8 i;
   3605              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00000D   85..82       MOV       DPL,?V0
   \   000010   85..83       MOV       DPH,?V1
   \   000013   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_422:
   \   000016   C3           CLR       C
   \   000017   13           RRC       A
   \   000018   E8           MOV       A,R0
   \   000019   13           RRC       A
   \   00001A   8A82         MOV       DPL,R2
   \   00001C   8B83         MOV       DPH,R3
   \   00001E   F0           MOVX      @DPTR,A
   3606              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00001F   7C00         MOV       R4,#0x0
   \   000021   8032         SJMP      ??zclParseInReadCmd_1
   3607              {
   3608                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F5..         MOV       ?V0,A
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F8           MOV       R0,A
   \   00002D   E4           CLR       A
   \   00002E   C8           XCH       A,R0
   \   00002F   F9           MOV       R1,A
   \   000030   E5..         MOV       A,?V0
   \   000032   28           ADD       A,R0
   \   000033   E4           CLR       A
   \   000034   39           ADDC      A,R1
   \   000035   F5..         MOV       ?V1,A
   \   000037   EC           MOV       A,R4
   \   000038   25E0         ADD       A,0xE0 /* A   */
   \   00003A   F8           MOV       R0,A
   \   00003B   E4           CLR       A
   \   00003C   33           RLC       A
   \   00003D   F9           MOV       R1,A
   \   00003E   EA           MOV       A,R2
   \   00003F   28           ADD       A,R0
   \   000040   F582         MOV       DPL,A
   \   000042   EB           MOV       A,R3
   \   000043   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000046   E5..         MOV       A,?V0
   \   000048   F0           MOVX      @DPTR,A
   \   000049   A3           INC       DPTR
   \   00004A   E5..         MOV       A,?V1
   \   00004C   F0           MOVX      @DPTR,A
   3609                pBuf += 2;
   \   00004D   EE           MOV       A,R6
   \   00004E   2402         ADD       A,#0x2
   \   000050   FE           MOV       R6,A
   \   000051   5001         JNC       ??zclParseInReadCmd_3
   \   000053   0F           INC       R7
   3610              }
   \                     ??zclParseInReadCmd_3:
   \   000054   0C           INC       R4
   \                     ??zclParseInReadCmd_1:
   \   000055   8A82         MOV       DPL,R2
   \   000057   8B83         MOV       DPH,R3
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   F8           MOV       R0,A
   \   00005B   EC           MOV       A,R4
   \   00005C   C3           CLR       C
   \   00005D   98           SUBB      A,R0
   \   00005E   40C3         JC        ??zclParseInReadCmd_2
   3611            }
   3612          
   3613            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   000060   02....       LJMP      ?Subroutine3 & 0xFFFF
   3614          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   8582..       MOV       ?V0,DPL
   \   000008   8583..       MOV       ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   2401         ADD       A,#0x1
   \   00000E   FA           MOV       R2,A
   \   00000F   A3           INC       DPTR
   \   000010   E0           MOVX      A,@DPTR
   \   000011   3400         ADDC      A,#0x0
   \   000013   FB           MOV       R3,A
   \   000014   12....       LCALL     ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_419:
   \   00000A   E8           MOV       A,R0
   \   00000B   FE           MOV       R6,A
   \   00000C   E9           MOV       A,R1
   \   00000D   FF           MOV       R7,A
   \   00000E   22           RET
   3615          
   3616          /*********************************************************************
   3617           * @fn      zclParseInReadRspCmd
   3618           *
   3619           * @brief   Parse the "Profile" Read Response Commands
   3620           *
   3621           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3622           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3623           *
   3624           * @param   pCmd - pointer to incoming data to parse
   3625           *
   3626           * @return  pointer to the parsed command structure
   3627           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3628          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3629          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V8,R2
   \   000007   8B..         MOV       ?V9,R3
   3630            zclReadRspCmd_t *readRspCmd;
   3631            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV       A,R2
   \   00000A   2403         ADD       A,#0x3
   \   00000C   F5..         MOV       ?V4,A
   \   00000E   E4           CLR       A
   \   00000F   35..         ADDC      A,?V9
   \   000011   F5..         MOV       ?V5,A
   \   000013   85..82       MOV       DPL,?V4
   \   000016   F583         MOV       DPH,A
   \   000018   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   3632            uint8 *dataPtr;
   3633            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_395:
   \   00001B   75..00       MOV       ?V2,#0x0
   3634            uint8 hdrLen;
   3635            uint16 dataLen = 0;
   \   00001E   75..00       MOV       ?V6,#0x0
   \   000021   75..00       MOV       ?V7,#0x0
   \   000024   8049         SJMP      ??zclParseInReadRspCmd_0
   3636            uint16 attrDataLen;
   3637          
   3638            // find out the number of attributes and the length of attribute data
   3639            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3640            {
   3641              uint8 status;
   3642          
   3643              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   000026   05..         INC       ?V2
   3644              pBuf += 2; // move pass attribute id
   3645          
   3646              status = *pBuf++;
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   F8           MOV       R0,A
   \   000030   EE           MOV       A,R6
   \   000031   2403         ADD       A,#0x3
   \   000033   FE           MOV       R6,A
   \   000034   5001         JNC       ??zclParseInReadRspCmd_2
   \   000036   0F           INC       R7
   3647              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_2:
   \   000037   E8           MOV       A,R0
   \   000038   7035         JNZ       ??zclParseInReadRspCmd_0
   3648              {
   3649                uint8 dataType = *pBuf++;
   \   00003A   8E82         MOV       DPL,R6
   \   00003C   8F83         MOV       DPH,R7
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F9           MOV       R1,A
   \   000040   A3           INC       DPTR
   \   000041   AE82         MOV       R6,DPL
   \   000043   AF83         MOV       R7,DPH
   3650          
   3651                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000045                ; Setup parameters for call to function zclGetAttrDataLength
   \   000045   EE           MOV       A,R6
   \   000046   FA           MOV       R2,A
   \   000047   EF           MOV       A,R7
   \   000048   FB           MOV       R3,A
   \   000049   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00004C   8A..         MOV       ?V0,R2
   \   00004E   8B..         MOV       ?V1,R3
   3652                pBuf += attrDataLen; // move pass attribute data
   \   000050   EE           MOV       A,R6
   \   000051   2A           ADD       A,R2
   \   000052   FE           MOV       R6,A
   \   000053   EF           MOV       A,R7
   \   000054   35..         ADDC      A,?V1
   \   000056   FF           MOV       R7,A
   3653          
   3654                // add padding if needed
   3655                if ( PADDING_NEEDED( attrDataLen ) )
   \   000057   EA           MOV       A,R2
   \   000058   A2E0         MOV       C,0xE0 /* A   */.0
   \   00005A   5007         JNC       ??zclParseInReadRspCmd_3
   3656                {
   3657                  attrDataLen++;
   \   00005C   05..         INC       ?V0
   \   00005E   04           INC       A
   \   00005F   7002         JNZ       ??zclParseInReadRspCmd_3
   \   000061   05..         INC       ?V1
   3658                }
   3659          
   3660                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000063   E5..         MOV       A,?V6
   \   000065   25..         ADD       A,?V0
   \   000067   F5..         MOV       ?V6,A
   \   000069   E5..         MOV       A,?V7
   \   00006B   35..         ADDC      A,?V1
   \   00006D   F5..         MOV       ?V7,A
   3661              }
   3662            }
   \                     ??zclParseInReadRspCmd_0:
   \   00006F   85..82       MOV       DPL,?V8
   \   000072   85..83       MOV       DPH,?V9
   \   000075   A3           INC       DPTR
   \   000076   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000079   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00007C   40A8         JC        ??zclParseInReadRspCmd_1
   3663          
   3664            // calculate the length of the response header
   3665            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   00007E   75F006       MOV       B,#0x6
   \   000081   E5..         MOV       A,?V2
   \   000083   A4           MUL       AB
   \   000084   04           INC       A
   \   000085   F5..         MOV       ?V0,A
   3666          
   3667            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000087                ; Setup parameters for call to function osal_mem_alloc
   \   000087   25..         ADD       A,?V6
   \   000089   FA           MOV       R2,A
   \   00008A   E4           CLR       A
   \   00008B   35..         ADDC      A,?V7
   \   00008D   12....       LCALL     ?Subroutine108 & 0xFFFF
   3668            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_175:
   \   000090   7003         JNZ       $+5
   \   000092   02....       LJMP      ??zclParseInReadRspCmd_4 & 0xFFFF
   3669            {
   3670              uint8 i;
   3671              pBuf = pCmd->pData;
   \   000095   12....       LCALL     ?Subroutine90 & 0xFFFF
   3672              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_401:
   \   000098   A8..         MOV       R0,?V0
   \   00009A   EA           MOV       A,R2
   \   00009B   28           ADD       A,R0
   \   00009C   F5..         MOV       ?V8,A
   \   00009E   E4           CLR       A
   \   00009F   3B           ADDC      A,R3
   \   0000A0   F5..         MOV       ?V9,A
   3673          
   3674              readRspCmd->numAttr = numAttr;
   \   0000A2   8A82         MOV       DPL,R2
   \   0000A4   8B83         MOV       DPH,R3
   \   0000A6   E5..         MOV       A,?V2
   \   0000A8   F0           MOVX      @DPTR,A
   3675              for ( i = 0; i < numAttr; i++ )
   \   0000A9   75..00       MOV       ?V3,#0x0
   \   0000AC   02....       LJMP      ??zclParseInReadRspCmd_5 & 0xFFFF
   3676              {
   3677                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   0000AF   E5..         MOV       A,?V3
   \   0000B1   75F006       MOV       B,#0x6
   \   0000B4   12....       LCALL     ?Subroutine111 & 0xFFFF
   3678          
   3679                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_179:
   \   0000B7   8E82         MOV       DPL,R6
   \   0000B9   8F83         MOV       DPH,R7
   \   0000BB   12....       LCALL     ?Subroutine29 & 0xFFFF
   3680                pBuf += 2;
   3681          
   3682                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_507:
   \   0000BE   8E82         MOV       DPL,R6
   \   0000C0   8F83         MOV       DPH,R7
   \   0000C2   A3           INC       DPTR
   \   0000C3   A3           INC       DPTR
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   F8           MOV       R0,A
   \   0000C6   85..82       MOV       DPL,?V12
   \   0000C9   85..83       MOV       DPH,?V13
   \   0000CC   A3           INC       DPTR
   \   0000CD   A3           INC       DPTR
   \   0000CE   F0           MOVX      @DPTR,A
   \   0000CF   EE           MOV       A,R6
   \   0000D0   2403         ADD       A,#0x3
   \   0000D2   FE           MOV       R6,A
   \   0000D3   5001         JNC       ??zclParseInReadRspCmd_7
   \   0000D5   0F           INC       R7
   3683                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_7:
   \   0000D6   E8           MOV       A,R0
   \   0000D7   7062         JNZ       ??zclParseInReadRspCmd_8
   3684                {
   3685                  statusRec->dataType = *pBuf++;
   \   0000D9   8E82         MOV       DPL,R6
   \   0000DB   8F83         MOV       DPH,R7
   \   0000DD   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   0000E0   A3           INC       DPTR
   \   0000E1   12....       LCALL     ?Subroutine24 & 0xFFFF
   3686          
   3687                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_21:
   \   0000E4                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000E4   EE           MOV       A,R6
   \   0000E5   FA           MOV       R2,A
   \   0000E6   EF           MOV       A,R7
   \   0000E7   FB           MOV       R3,A
   \   0000E8   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000EB   8A..         MOV       ?V0,R2
   \   0000ED   8B..         MOV       ?V1,R3
   3688                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000EF                ; Setup parameters for call to function osal_memcpy
   \   0000EF   8E..         MOV       ?V4,R6
   \   0000F1   8F..         MOV       ?V5,R7
   \   0000F3   75..00       MOV       ?V6,#0x0
   \   0000F6   78..         MOV       R0,#?V4
   \   0000F8   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000FB   AC..         MOV       R4,?V0
   \   0000FD   AD..         MOV       R5,?V1
   \   0000FF   AA..         MOV       R2,?V8
   \   000101   AB..         MOV       R3,?V9
   \   000103   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_360:
   \   000106   12....       LCALL     ?DEALLOC_XSTACK8
   3689                  statusRec->data = dataPtr;
   \   000109   85..82       MOV       DPL,?V12
   \   00010C   85..83       MOV       DPH,?V13
   \   00010F   A3           INC       DPTR
   \   000110   A3           INC       DPTR
   \   000111   A3           INC       DPTR
   \   000112   A3           INC       DPTR
   \   000113   E5..         MOV       A,?V8
   \   000115   F0           MOVX      @DPTR,A
   \   000116   A3           INC       DPTR
   \   000117   E5..         MOV       A,?V9
   \   000119   F0           MOVX      @DPTR,A
   3690          
   3691                  pBuf += attrDataLen; // move pass attribute data
   \   00011A   EE           MOV       A,R6
   \   00011B   25..         ADD       A,?V0
   \   00011D   FE           MOV       R6,A
   \   00011E   EF           MOV       A,R7
   \   00011F   35..         ADDC      A,?V1
   \   000121   FF           MOV       R7,A
   3692          
   3693                  // advance attribute data pointer
   3694                  if ( PADDING_NEEDED( attrDataLen ) )
   \   000122   E5..         MOV       A,?V0
   \   000124   A2E0         MOV       C,0xE0 /* A   */.0
   \   000126   5007         JNC       ??zclParseInReadRspCmd_9
   3695                  {
   3696                    attrDataLen++;
   \   000128   05..         INC       ?V0
   \   00012A   04           INC       A
   \   00012B   7002         JNZ       ??zclParseInReadRspCmd_9
   \   00012D   05..         INC       ?V1
   3697                  }
   3698          
   3699                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   00012F   E5..         MOV       A,?V8
   \   000131   25..         ADD       A,?V0
   \   000133   F5..         MOV       ?V8,A
   \   000135   E5..         MOV       A,?V9
   \   000137   35..         ADDC      A,?V1
   \   000139   F5..         MOV       ?V9,A
   3700                }
   3701              }
   \                     ??zclParseInReadRspCmd_8:
   \   00013B   05..         INC       ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00013D   E5..         MOV       A,?V3
   \   00013F   C3           CLR       C
   \   000140   95..         SUBB      A,?V2
   \   000142   5003         JNC       $+5
   \   000144   02....       LJMP      ??zclParseInReadRspCmd_6 & 0xFFFF
   3702            }
   3703          
   3704            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000147                REQUIRE ?Subroutine10
   \   000147                ; // Fall through to label ?Subroutine10
   3705          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   AA..         MOV       R2,?V10
   \   000002   AB..         MOV       R3,?V11
   \   000004   02....       LJMP      ??Subroutine164_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   A4           MUL       AB
   \   000001   F8           MOV       R0,A
   \   000002   A9F0         MOV       R1,B
   \   000004   E5..         MOV       A,?V10
   \   000006   28           ADD       A,R0
   \   000007   F582         MOV       DPL,A
   \   000009   E5..         MOV       A,?V11
   \   00000B   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   00000E   8582..       MOV       ?V12,DPL
   \   000011   8583..       MOV       ?V13,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   FB           MOV       R3,A
   \   000001   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000004   8A..         MOV       ?V10,R2
   \   000006   8B..         MOV       ?V11,R3
   \   000008   EA           MOV       A,R2
   \   000009   4B           ORL       A,R3
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002   85..82       MOV       DPL,?V12
   \   000005   85..83       MOV       DPH,?V13
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   F8           MOV       R0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   F9           MOV       R1,A
   \   000007   C3           CLR       C
   \   000008   EE           MOV       A,R6
   \   000009   98           SUBB      A,R0
   \   00000A   EF           MOV       A,R7
   \   00000B   99           SUBB      A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   85..82       MOV       DPL,?V4
   \   000003   85..83       MOV       DPH,?V5
   \   000006                REQUIRE ??Subroutine183_0
   \   000006                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_417:
   \   000003   85..82       MOV       DPL,?V4
   \   000006   85..83       MOV       DPH,?V5
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   EA           MOV       A,R2
   \   000006   85..82       MOV       DPL,?V12
   \   000009   85..83       MOV       DPH,?V13
   \   00000C                REQUIRE ??Subroutine198_0
   \   00000C                ; // Fall through to label ??Subroutine198_0
   3706          #endif // ZCL_READ
   3707          
   3708          #ifdef ZCL_WRITE
   3709          /*********************************************************************
   3710           * @fn      zclParseInWriteCmd
   3711           *
   3712           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3713           *          Response Commands
   3714           *
   3715           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3716           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3717           *
   3718           * @param   pCmd - pointer to incoming data to parse
   3719           *
   3720           * @return  pointer to the parsed command structure
   3721           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3722          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3723          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V8,R2
   \   000007   8B..         MOV       ?V9,R3
   3724            zclWriteCmd_t *writeCmd;
   3725            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV       A,R2
   \   00000A   2403         ADD       A,#0x3
   \   00000C   F5..         MOV       ?V2,A
   \   00000E   E4           CLR       A
   \   00000F   35..         ADDC      A,?V9
   \   000011   F5..         MOV       ?V3,A
   \   000013   85..82       MOV       DPL,?V2
   \   000016   F583         MOV       DPH,A
   \   000018   12....       LCALL     ?Subroutine65 & 0xFFFF
   3726            uint16 attrDataLen;
   3727            uint8 *dataPtr;
   3728            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_105:
   \   00001B   75..00       MOV       ?V7,#0x0
   3729            uint8 hdrLen;
   3730            uint16 dataLen = 0;
   \   00001E   75..00       MOV       ?V4,#0x0
   \   000021   75..00       MOV       ?V5,#0x0
   \   000024   8042         SJMP      ??zclParseInWriteCmd_0
   3731          
   3732            // find out the number of attributes and the length of attribute data
   3733            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3734            {
   3735              uint8 dataType;
   3736          
   3737              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   000026   05..         INC       ?V7
   3738              pBuf += 2; // move pass attribute id
   3739          
   3740              dataType = *pBuf++;
   \   000028   85..82       MOV       DPL,?V0
   \   00002B   85..83       MOV       DPH,?V1
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F9           MOV       R1,A
   \   000032   E5..         MOV       A,?V0
   \   000034   2403         ADD       A,#0x3
   \   000036   F5..         MOV       ?V0,A
   \   000038   5002         JNC       ??zclParseInWriteCmd_2
   \   00003A   05..         INC       ?V1
   3741          
   3742              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInWriteCmd_2:
   \   00003C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003C   FA           MOV       R2,A
   \   00003D   AB..         MOV       R3,?V1
   \   00003F   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000042   8A..         MOV       ?V10,R2
   \   000044   8B..         MOV       ?V11,R3
   \   000046   AE..         MOV       R6,?V10
   \   000048   AF..         MOV       R7,?V11
   3743              pBuf += attrDataLen; // move pass attribute data
   \   00004A   E5..         MOV       A,?V0
   \   00004C   2A           ADD       A,R2
   \   00004D   F5..         MOV       ?V0,A
   \   00004F   E5..         MOV       A,?V1
   \   000051   3F           ADDC      A,R7
   \   000052   F5..         MOV       ?V1,A
   3744          
   3745              // add padding if needed
   3746              if ( PADDING_NEEDED( attrDataLen ) )
   \   000054   EA           MOV       A,R2
   \   000055   A2E0         MOV       C,0xE0 /* A   */.0
   \   000057   5005         JNC       ??zclParseInWriteCmd_3
   3747              {
   3748                attrDataLen++;
   \   000059   0E           INC       R6
   \   00005A   04           INC       A
   \   00005B   7001         JNZ       ??zclParseInWriteCmd_3
   \   00005D   0F           INC       R7
   3749              }
   3750          
   3751              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_3:
   \   00005E   E5..         MOV       A,?V4
   \   000060   2E           ADD       A,R6
   \   000061   F5..         MOV       ?V4,A
   \   000063   E5..         MOV       A,?V5
   \   000065   3F           ADDC      A,R7
   \   000066   F5..         MOV       ?V5,A
   3752            }
   \                     ??zclParseInWriteCmd_0:
   \   000068   85..82       MOV       DPL,?V8
   \   00006B   85..83       MOV       DPH,?V9
   \   00006E   A3           INC       DPTR
   \   00006F   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000072   12....       LCALL     ??Subroutine165_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000075   C3           CLR       C
   \   000076   E5..         MOV       A,?V0
   \   000078   98           SUBB      A,R0
   \   000079   E5..         MOV       A,?V1
   \   00007B   99           SUBB      A,R1
   \   00007C   40A8         JC        ??zclParseInWriteCmd_1
   3753          
   3754            // calculate the length of the response header
   3755            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   00007E   75F005       MOV       B,#0x5
   \   000081   E5..         MOV       A,?V7
   \   000083   A4           MUL       AB
   \   000084   04           INC       A
   \   000085   FE           MOV       R6,A
   3756          
   3757            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000086                ; Setup parameters for call to function osal_mem_alloc
   \   000086   25..         ADD       A,?V4
   \   000088   FA           MOV       R2,A
   \   000089   E4           CLR       A
   \   00008A   35..         ADDC      A,?V5
   \   00008C   12....       LCALL     ?Subroutine108 & 0xFFFF
   3758            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_176:
   \   00008F   7003         JNZ       $+5
   \   000091   02....       LJMP      ??zclParseInWriteCmd_4 & 0xFFFF
   3759            {
   3760              uint8 i;
   3761              pBuf = pCmd->pData;
   \   000094   85..82       MOV       DPL,?V2
   \   000097   85..83       MOV       DPH,?V3
   \   00009A   12....       LCALL     ?Subroutine65 & 0xFFFF
   3762              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \                     ??CrossCallReturnLabel_106:
   \   00009D   EA           MOV       A,R2
   \   00009E   2E           ADD       A,R6
   \   00009F   F5..         MOV       ?V2,A
   \   0000A1   E4           CLR       A
   \   0000A2   3B           ADDC      A,R3
   \   0000A3   F5..         MOV       ?V3,A
   3763          
   3764              writeCmd->numAttr = numAttr;
   \   0000A5   8A82         MOV       DPL,R2
   \   0000A7   8B83         MOV       DPH,R3
   \   0000A9   E5..         MOV       A,?V7
   \   0000AB   F0           MOVX      @DPTR,A
   3765              for ( i = 0; i < numAttr; i++ )
   \   0000AC   75..00       MOV       ?V8,#0x0
   \   0000AF   02....       LJMP      ??zclParseInWriteCmd_5 & 0xFFFF
   3766              {
   3767                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   0000B2   E5..         MOV       A,?V8
   \   0000B4   75F005       MOV       B,#0x5
   \   0000B7   12....       LCALL     ?Subroutine111 & 0xFFFF
   3768          
   3769                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_180:
   \   0000BA   85..82       MOV       DPL,?V0
   \   0000BD   85..83       MOV       DPH,?V1
   \   0000C0   12....       LCALL     ?Subroutine29 & 0xFFFF
   3770                pBuf += 2;
   3771                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_508:
   \   0000C3   85..82       MOV       DPL,?V0
   \   0000C6   85..83       MOV       DPH,?V1
   \   0000C9   A3           INC       DPTR
   \   0000CA   A3           INC       DPTR
   \   0000CB   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0000CE   F0           MOVX      @DPTR,A
   \   0000CF   E5..         MOV       A,?V0
   \   0000D1   2403         ADD       A,#0x3
   \   0000D3   F5..         MOV       ?V0,A
   \   0000D5   5002         JNC       ??zclParseInWriteCmd_7
   \   0000D7   05..         INC       ?V1
   3772          
   3773                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??zclParseInWriteCmd_7:
   \   0000D9                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000D9   FA           MOV       R2,A
   \   0000DA   AB..         MOV       R3,?V1
   \   0000DC   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000DF   8A..         MOV       ?V4,R2
   \   0000E1   8B..         MOV       ?V5,R3
   \   0000E3   AE..         MOV       R6,?V4
   \   0000E5   AF..         MOV       R7,?V5
   3774                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000E7                ; Setup parameters for call to function osal_memcpy
   \   0000E7   85....       MOV       ?V4,?V0
   \   0000EA   85....       MOV       ?V5,?V1
   \   0000ED   75..00       MOV       ?V6,#0x0
   \   0000F0   78..         MOV       R0,#?V4
   \   0000F2   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000F5   EA           MOV       A,R2
   \   0000F6   FC           MOV       R4,A
   \   0000F7   EB           MOV       A,R3
   \   0000F8   FD           MOV       R5,A
   \   0000F9   AA..         MOV       R2,?V2
   \   0000FB   AB..         MOV       R3,?V3
   \   0000FD   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   000100   12....       LCALL     ?DEALLOC_XSTACK8
   3775                statusRec->attrData = dataPtr;
   \   000103   85..82       MOV       DPL,?V12
   \   000106   85..83       MOV       DPH,?V13
   \   000109   A3           INC       DPTR
   \   00010A   A3           INC       DPTR
   \   00010B   A3           INC       DPTR
   \   00010C   E5..         MOV       A,?V2
   \   00010E   F0           MOVX      @DPTR,A
   \   00010F   A3           INC       DPTR
   \   000110   E5..         MOV       A,?V3
   \   000112   F0           MOVX      @DPTR,A
   3776          
   3777                pBuf += attrDataLen; // move pass attribute data
   \   000113   E5..         MOV       A,?V0
   \   000115   2E           ADD       A,R6
   \   000116   F5..         MOV       ?V0,A
   \   000118   E5..         MOV       A,?V1
   \   00011A   3F           ADDC      A,R7
   \   00011B   F5..         MOV       ?V1,A
   3778          
   3779                // advance attribute data pointer
   3780                if ( PADDING_NEEDED( attrDataLen ) )
   \   00011D   EE           MOV       A,R6
   \   00011E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000120   5005         JNC       ??zclParseInWriteCmd_8
   3781                {
   3782                  attrDataLen++;
   \   000122   0E           INC       R6
   \   000123   04           INC       A
   \   000124   7001         JNZ       ??zclParseInWriteCmd_8
   \   000126   0F           INC       R7
   3783                }
   3784          
   3785                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_8:
   \   000127   E5..         MOV       A,?V2
   \   000129   2E           ADD       A,R6
   \   00012A   F5..         MOV       ?V2,A
   \   00012C   E5..         MOV       A,?V3
   \   00012E   3F           ADDC      A,R7
   \   00012F   F5..         MOV       ?V3,A
   3786              }
   \   000131   05..         INC       ?V8
   \                     ??zclParseInWriteCmd_5:
   \   000133   E5..         MOV       A,?V8
   \   000135   C3           CLR       C
   \   000136   95..         SUBB      A,?V7
   \   000138   5003         JNC       $+5
   \   00013A   02....       LJMP      ??zclParseInWriteCmd_6 & 0xFFFF
   3787            }
   3788          
   3789            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   00013D   02....       LJMP      ?Subroutine10 & 0xFFFF
   3790          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine194_0
   \   000003                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002   85..82       MOV       DPL,?V2
   \   000005   85..83       MOV       DPH,?V3
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   12....       LCALL     ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_474:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
   3791          
   3792          /*********************************************************************
   3793           * @fn      zclParseInWriteRspCmd
   3794           *
   3795           * @brief   Parse the "Profile" Write Response Commands
   3796           *
   3797           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3798           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3799           *
   3800           * @param   pCmd - pointer to incoming data to parse
   3801           *
   3802           * @return  pointer to the parsed command structure
   3803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3804          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3805          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3806            zclWriteRspCmd_t *writeRspCmd;
   3807            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV       A,R2
   \   000006   2403         ADD       A,#0x3
   \   000008   F5..         MOV       ?V2,A
   \   00000A   E4           CLR       A
   \   00000B   3B           ADDC      A,R3
   \   00000C   F5..         MOV       ?V3,A
   \   00000E   85..82       MOV       DPL,?V2
   \   000011   12....       LCALL     ?Subroutine89 & 0xFFFF
   3808            uint8 i = 0;
   3809          
   3810            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_151:
   \   000014   12....       LCALL     ?Subroutine59 & 0xFFFF
   3811            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_97:
   \   000017   6050         JZ        ??zclParseInWriteRspCmd_0
   3812            {
   3813              if ( pCmd->dataLen == 1 )
   \   000019   85..82       MOV       DPL,?V0
   \   00001C   85..83       MOV       DPH,?V1
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   6401         XRL       A,#0x1
   \   000022   7002         JNZ       ??zclParseInWriteRspCmd_1
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   000026   702C         JNZ       ??zclParseInWriteRspCmd_2
   3814              {
   3815                // special case when all writes were successfull
   3816                writeRspCmd->attrList[i++].status = *pBuf;
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   12....       LCALL     ??Subroutine181_0 & 0xFFFF
   3817              }
   \                     ??CrossCallReturnLabel_386:
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   75..01       MOV       ?V4,#0x1
   \   000033   802D         SJMP      ??zclParseInWriteRspCmd_3
   3818              else
   3819              {
   3820                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3821                {
   3822                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000035   E5..         MOV       A,?V4
   \   000037   12....       LCALL     ?Subroutine15 & 0xFFFF
   3823                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_389:
   \   00003A   F5..         MOV       ?V6,A
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   FD           MOV       R5,A
   \   00003F   E5..         MOV       A,?V6
   \   000041   8882         MOV       DPL,R0
   \   000043   8983         MOV       DPH,R1
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   F0           MOVX      @DPTR,A
   \   000048   A3           INC       DPTR
   \   000049   ED           MOV       A,R5
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   05..         INC       ?V4
   3824                  pBuf += 2;
   \   00004D   EE           MOV       A,R6
   \   00004E   2402         ADD       A,#0x2
   \   000050   FE           MOV       R6,A
   \   000051   5001         JNC       ??zclParseInWriteRspCmd_2
   \   000053   0F           INC       R7
   3825                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000054   85..82       MOV       DPL,?V0
   \   000057   85..83       MOV       DPH,?V1
   \   00005A   12....       LCALL     ?Subroutine64 & 0xFFFF
   3826              }
   \                     ??CrossCallReturnLabel_102:
   \   00005D   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000060   40D3         JC        ??zclParseInWriteRspCmd_4
   3827          
   3828              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000062   8A82         MOV       DPL,R2
   \   000064   8B83         MOV       DPH,R3
   \   000066   E5..         MOV       A,?V4
   \   000068   F0           MOVX      @DPTR,A
   3829            }
   3830          
   3831            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   000069   02....       LJMP      ??Subroutine173_0 & 0xFFFF
   3832          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   75F003       MOV       B,#0x3
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007   EA           MOV       A,R2
   \   000008   28           ADD       A,R0
   \   000009   F8           MOV       R0,A
   \   00000A   EB           MOV       A,R3
   \   00000B   39           ADDC      A,R1
   \   00000C   F9           MOV       R1,A
   \   00000D   8E82         MOV       DPL,R6
   \   00000F   8F83         MOV       DPH,R7
   \   000011   12....       LCALL     ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000014                REQUIRE ??Subroutine182_0
   \   000014                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   12....       LCALL     ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_393:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   F583         MOV       DPH,A
   \   000002   E0           MOVX      A,@DPTR
   \   000003   FE           MOV       R6,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   FF           MOV       R7,A
   \   000007   75..00       MOV       ?V4,#0x0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL     ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_475:
   \   000003   22           RET
   3833          #endif // ZCL_WRITE
   3834          
   3835          #ifdef ZCL_REPORTING_DEVICE
   3836          /*********************************************************************
   3837           * @fn      zclParseInConfigReportCmd
   3838           *
   3839           * @brief   Parse the "Profile" Configure Reporting Command
   3840           *
   3841           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3842           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3843           *
   3844           * @param   pCmd - pointer to incoming data to parse
   3845           *
   3846           * @return  pointer to the parsed command structure
   3847           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3848          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3849          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   3850            zclCfgReportCmd_t *cfgReportCmd;
   3851            uint8 *pBuf = pCmd->pData;
   \   00000E   EA           MOV       A,R2
   \   00000F   2403         ADD       A,#0x3
   \   000011   F5..         MOV       ?V0,A
   \   000013   E4           CLR       A
   \   000014   35..         ADDC      A,?V3
   \   000016   F5..         MOV       ?V1,A
   \   000018   85..82       MOV       DPL,?V0
   \   00001B   12....       LCALL     ?Subroutine89 & 0xFFFF
   3852            uint8 *dataPtr;
   3853            uint8 numAttr = 0;
   3854            uint8 dataType;
   3855            uint8 hdrLen;
   3856            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_152:
   \   00001E   75..00       MOV       ?V6,#0x0
   \   000021   75..00       MOV       ?V7,#0x0
   \   000024   8007         SJMP      ??zclParseInConfigReportCmd_0
   3857            uint8 reportChangeLen; // length of Reportable Change field
   3858          
   3859            // Calculate the length of the Request command
   3860            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3861            {
   3862              uint8 direction;
   3863          
   3864              numAttr++;
   3865              direction = *pBuf++;
   3866              pBuf += 2; // move pass the attribute ID
   3867          
   3868              // Is there a Reportable Change field?
   3869              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3870              {
   3871                dataType = *pBuf++;
   3872                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3873          
   3874                // For attributes of 'discrete' data types this field is omitted
   3875                if ( zclAnalogDataType( dataType ) )
   3876                {
   3877                  reportChangeLen = zclGetDataTypeLength( dataType );
   3878                  pBuf += reportChangeLen;
   3879          
   3880                  // add padding if needed
   3881                  if ( PADDING_NEEDED( reportChangeLen ) )
   3882                  {
   3883                    reportChangeLen++;
   3884                  }
   3885          
   3886                  dataLen += reportChangeLen;
   3887                }
   3888                else
   3889                {
   3890                  pBuf++; // move past reportable change field
   3891                }
   3892              }
   3893              else
   3894              {
   3895                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   000026   EE           MOV       A,R6
   \   000027   2405         ADD       A,#0x5
   \   000029   FE           MOV       R6,A
   \   00002A   5001         JNC       ??zclParseInConfigReportCmd_0
   \   00002C   0F           INC       R7
   3896              }
   \                     ??zclParseInConfigReportCmd_0:
   \   00002D   85..82       MOV       DPL,?V2
   \   000030   85..83       MOV       DPH,?V3
   \   000033   A3           INC       DPTR
   \   000034   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   000037   85..82       MOV       DPL,?V0
   \   00003A   85..83       MOV       DPH,?V1
   \   00003D   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000040   5036         JNC       ??zclParseInConfigReportCmd_2
   \   000042   05..         INC       ?V4
   \   000044   8E82         MOV       DPL,R6
   \   000046   8F83         MOV       DPH,R7
   \   000048   E0           MOVX      A,@DPTR
   \   000049   70DB         JNZ       ??zclParseInConfigReportCmd_1
   \   00004B   A3           INC       DPTR
   \   00004C   A3           INC       DPTR
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   F5..         MOV       ?V5,A
   \   000051   EE           MOV       A,R6
   \   000052   2408         ADD       A,#0x8
   \   000054   FE           MOV       R6,A
   \   000055   5001         JNC       ??zclParseInConfigReportCmd_3
   \   000057   0F           INC       R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000058                ; Setup parameters for call to function zclAnalogDataType
   \   000058   A9..         MOV       R1,?V5
   \   00005A   12....       LCALL     `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00005D   E9           MOV       A,R1
   \   00005E   600D         JZ        ??zclParseInConfigReportCmd_4
   \   000060                ; Setup parameters for call to function zclGetDataTypeLength
   \   000060   A9..         MOV       R1,?V5
   \   000062   12....       LCALL     ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000065   5001         JNC       ??zclParseInConfigReportCmd_5
   \   000067   08           INC       R0
   \                     ??zclParseInConfigReportCmd_5:
   \   000068   12....       LCALL     ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00006B   80C0         SJMP      ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_4:
   \   00006D   8E82         MOV       DPL,R6
   \   00006F   8F83         MOV       DPH,R7
   \   000071   A3           INC       DPTR
   \   000072   AE82         MOV       R6,DPL
   \   000074   AF83         MOV       R7,DPH
   \   000076   80B5         SJMP      ??zclParseInConfigReportCmd_0
   3897            } // while loop
   3898          
   3899            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   000078   75F00C       MOV       B,#0xc
   \   00007B   E5..         MOV       A,?V4
   \   00007D   A4           MUL       AB
   \   00007E   04           INC       A
   \   00007F   F5..         MOV       ?V2,A
   3900          
   3901            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000081                ; Setup parameters for call to function osal_mem_alloc
   \   000081   25..         ADD       A,?V6
   \   000083   FA           MOV       R2,A
   \   000084   E4           CLR       A
   \   000085   35..         ADDC      A,?V7
   \   000087   FB           MOV       R3,A
   \   000088   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00008B   8A..         MOV       ?V8,R2
   \   00008D   8B..         MOV       ?V9,R3
   3902            if ( cfgReportCmd != NULL )
   \   00008F   EA           MOV       A,R2
   \   000090   4B           ORL       A,R3
   \   000091   7003         JNZ       $+5
   \   000093   02....       LJMP      ??zclParseInConfigReportCmd_6 & 0xFFFF
   3903            {
   3904              uint8 i;
   3905              pBuf = pCmd->pData;
   \   000096   85..82       MOV       DPL,?V0
   \   000099   85..83       MOV       DPH,?V1
   \   00009C   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   3906              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_396:
   \   00009F   A8..         MOV       R0,?V2
   \   0000A1   EA           MOV       A,R2
   \   0000A2   28           ADD       A,R0
   \   0000A3   F5..         MOV       ?V6,A
   \   0000A5   E4           CLR       A
   \   0000A6   3B           ADDC      A,R3
   \   0000A7   F5..         MOV       ?V7,A
   3907          
   3908              cfgReportCmd->numAttr = numAttr;
   \   0000A9   8A82         MOV       DPL,R2
   \   0000AB   8B83         MOV       DPH,R3
   \   0000AD   E5..         MOV       A,?V4
   \   0000AF   F0           MOVX      @DPTR,A
   3909              for ( i = 0; i < numAttr; i++ )
   \   0000B0   75..00       MOV       ?V5,#0x0
   \   0000B3   8018         SJMP      ??zclParseInConfigReportCmd_7
   3910              {
   3911                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3912          
   3913                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3914          
   3915                reportRec->direction = *pBuf++;
   3916                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3917                pBuf += 2;
   3918                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3919                {
   3920                  // Attribute to be reported
   3921                  reportRec->dataType = *pBuf++;
   3922                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3923                  pBuf += 2;
   3924                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3925                  pBuf += 2;
   3926          
   3927                  // For attributes of 'discrete' data types this field is omitted
   3928                  if ( zclAnalogDataType( reportRec->dataType ) )
   3929                  {
   3930                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3931                    reportRec->reportableChange = dataPtr;
   3932          
   3933                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3934                    pBuf += reportChangeLen;
   3935          
   3936                    // advance attribute data pointer
   3937                    if ( PADDING_NEEDED( reportChangeLen ) )
   3938                    {
   3939                      reportChangeLen++;
   3940                    }
   3941          
   3942                    dataPtr += reportChangeLen;
   3943                  }
   3944                }
   3945                else
   3946                {
   3947                  // Attribute reports to be received
   3948                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_8:
   \   0000B5   8882         MOV       DPL,R0
   \   0000B7   8983         MOV       DPH,R1
   \   0000B9   12....       LCALL     ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   0000BC   A3           INC       DPTR
   \   0000BD   A3           INC       DPTR
   \   0000BE   A3           INC       DPTR
   \   0000BF   A3           INC       DPTR
   \   0000C0   A3           INC       DPTR
   \   0000C1   A3           INC       DPTR
   \   0000C2   A3           INC       DPTR
   \   0000C3   A3           INC       DPTR
   \   0000C4   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   3949                  pBuf += 2;
   \                     ??CrossCallReturnLabel_500:
   \   0000C7   0E           INC       R6
   \   0000C8   0E           INC       R6
   \   0000C9   ED           MOV       A,R5
   \   0000CA   FF           MOV       R7,A
   3950                }
   \                     ??zclParseInConfigReportCmd_9:
   \   0000CB   05..         INC       ?V5
   \                     ??zclParseInConfigReportCmd_7:
   \   0000CD   E5..         MOV       A,?V5
   \   0000CF   C3           CLR       C
   \   0000D0   95..         SUBB      A,?V4
   \   0000D2   4003         JC        $+5
   \   0000D4   02....       LJMP      ??zclParseInConfigReportCmd_6 & 0xFFFF
   \   0000D7   E5..         MOV       A,?V5
   \   0000D9   75F00C       MOV       B,#0xc
   \   0000DC   12....       LCALL     ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   0000DF   12....       LCALL     ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   0000E2                ; Setup parameters for call to function osal_memset
   \   0000E2   7C0C         MOV       R4,#0xc
   \   0000E4   7D00         MOV       R5,#0x0
   \   0000E6   7900         MOV       R1,#0x0
   \   0000E8   AA..         MOV       R2,?V0
   \   0000EA   AB..         MOV       R3,?V1
   \   0000EC   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000EF   8E82         MOV       DPL,R6
   \   0000F1   8F83         MOV       DPH,R7
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   FB           MOV       R3,A
   \   0000F5   85..82       MOV       DPL,?V0
   \   0000F8   85..83       MOV       DPH,?V1
   \   0000FB   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   0000FE   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000101   12....       LCALL     ??Subroutine168_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000104   5001         JNC       ??zclParseInConfigReportCmd_10
   \   000106   0F           INC       R7
   \                     ??zclParseInConfigReportCmd_10:
   \   000107   2402         ADD       A,#0x2
   \   000109   FC           MOV       R4,A
   \   00010A   E4           CLR       A
   \   00010B   3F           ADDC      A,R7
   \   00010C   FD           MOV       R5,A
   \   00010D   8E82         MOV       DPL,R6
   \   00010F   8F83         MOV       DPH,R7
   \   000111   A3           INC       DPTR
   \   000112   A882         MOV       R0,DPL
   \   000114   A983         MOV       R1,DPH
   \   000116   8E82         MOV       DPL,R6
   \   000118   8F83         MOV       DPH,R7
   \   00011A   E0           MOVX      A,@DPTR
   \   00011B   FA           MOV       R2,A
   \   00011C   EB           MOV       A,R3
   \   00011D   7096         JNZ       ??zclParseInConfigReportCmd_8
   \   00011F   E5..         MOV       A,?V0
   \   000121   2403         ADD       A,#0x3
   \   000123   F5..         MOV       ?V12,A
   \   000125   E4           CLR       A
   \   000126   35..         ADDC      A,?V1
   \   000128   F5..         MOV       ?V13,A
   \   00012A   EA           MOV       A,R2
   \   00012B   85..82       MOV       DPL,?V12
   \   00012E   85..83       MOV       DPH,?V13
   \   000131   F0           MOVX      @DPTR,A
   \   000132   E9           MOV       A,R1
   \   000133   FF           MOV       R7,A
   \   000134   8882         MOV       DPL,R0
   \   000136   F583         MOV       DPH,A
   \   000138   E0           MOVX      A,@DPTR
   \   000139   F5..         MOV       ?V2,A
   \   00013B   8C82         MOV       DPL,R4
   \   00013D   8D83         MOV       DPH,R5
   \   00013F   E0           MOVX      A,@DPTR
   \   000140   F9           MOV       R1,A
   \   000141   E5..         MOV       A,?V2
   \   000143   85..82       MOV       DPL,?V0
   \   000146   85..83       MOV       DPH,?V1
   \   000149   A3           INC       DPTR
   \   00014A   A3           INC       DPTR
   \   00014B   A3           INC       DPTR
   \   00014C   A3           INC       DPTR
   \   00014D   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_501:
   \   000150   E8           MOV       A,R0
   \   000151   2402         ADD       A,#0x2
   \   000153   FE           MOV       R6,A
   \   000154   5001         JNC       ??zclParseInConfigReportCmd_11
   \   000156   0F           INC       R7
   \                     ??zclParseInConfigReportCmd_11:
   \   000157   F582         MOV       DPL,A
   \   000159   8F83         MOV       DPH,R7
   \   00015B   E0           MOVX      A,@DPTR
   \   00015C   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   00015F   A3           INC       DPTR
   \   000160   A3           INC       DPTR
   \   000161   A3           INC       DPTR
   \   000162   A3           INC       DPTR
   \   000163   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000166   5001         JNC       ??zclParseInConfigReportCmd_12
   \   000168   0F           INC       R7
   \                     ??zclParseInConfigReportCmd_12:
   \   000169                ; Setup parameters for call to function zclAnalogDataType
   \   000169   EA           MOV       A,R2
   \   00016A   F9           MOV       R1,A
   \   00016B   12....       LCALL     `??zclAnalogDataType::?relay`; Banked call to: zclAnalogDataType
   \   00016E   E9           MOV       A,R1
   \   00016F   7003         JNZ       $+5
   \   000171   02....       LJMP      ??zclParseInConfigReportCmd_9 & 0xFFFF
   \   000174   8E..         MOV       ?V2,R6
   \   000176   8F..         MOV       ?V3,R7
   \   000178                ; Setup parameters for call to function zclGetAttrDataLength
   \   000178   AA..         MOV       R2,?V6
   \   00017A   AB..         MOV       R3,?V7
   \   00017C   85..82       MOV       DPL,?V12
   \   00017F   85..83       MOV       DPH,?V13
   \   000182   12....       LCALL     ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000185   8A..         MOV       ?V10,R2
   \   000187   8B..         MOV       ?V11,R3
   \   000189   A8..         MOV       R0,?V10
   \   00018B   A9..         MOV       R1,?V11
   \   00018D   85..82       MOV       DPL,?XSP + 0
   \   000190   85..83       MOV       DPH,?XSP + 1
   \   000193   7401         MOV       A,#0x1
   \   000195   F0           MOVX      @DPTR,A
   \   000196   A3           INC       DPTR
   \   000197   E4           CLR       A
   \   000198   F0           MOVX      @DPTR,A
   \   000199   85..82       MOV       DPL,?XSP + 0
   \   00019C   85..83       MOV       DPH,?XSP + 1
   \   00019F   E0           MOVX      A,@DPTR
   \   0001A0   600C         JZ        ??zclParseInConfigReportCmd_13
   \   0001A2   75..01       MOV       ?V10,#0x1
   \   0001A5   75..00       MOV       ?V11,#0x0
   \   0001A8   7A00         MOV       R2,#0x0
   \   0001AA   7B00         MOV       R3,#0x0
   \   0001AC   803A         SJMP      ??zclParseInConfigReportCmd_14
   \                     ??zclParseInConfigReportCmd_13:
   \   0001AE   75..FF       MOV       ?V10,#-0x1
   \   0001B1   75..FF       MOV       ?V11,#-0x1
   \   0001B4   EA           MOV       A,R2
   \   0001B5   24FF         ADD       A,#-0x1
   \   0001B7   1A           DEC       R2
   \   0001B8   EB           MOV       A,R3
   \   0001B9   34FF         ADDC      A,#-0x1
   \   0001BB   802A         SJMP      ??zclParseInConfigReportCmd_15
   \                     ??zclParseInConfigReportCmd_16:
   \   0001BD   85..82       MOV       DPL,?V2
   \   0001C0   85..83       MOV       DPH,?V3
   \   0001C3   E0           MOVX      A,@DPTR
   \   0001C4   C0E0         PUSH      A
   \   0001C6   E5..         MOV       A,?V6
   \   0001C8   2A           ADD       A,R2
   \   0001C9   F582         MOV       DPL,A
   \   0001CB   E5..         MOV       A,?V7
   \   0001CD   3B           ADDC      A,R3
   \   0001CE   F583         MOV       DPH,A
   \   0001D0   D0E0         POP       A
   \   0001D2   F0           MOVX      @DPTR,A
   \   0001D3   85..82       MOV       DPL,?V2
   \   0001D6   85..83       MOV       DPH,?V3
   \   0001D9   A3           INC       DPTR
   \   0001DA   8582..       MOV       ?V2,DPL
   \   0001DD   8583..       MOV       ?V3,DPH
   \   0001E0   EA           MOV       A,R2
   \   0001E1   25..         ADD       A,?V10
   \   0001E3   FA           MOV       R2,A
   \   0001E4   EB           MOV       A,R3
   \   0001E5   35..         ADDC      A,?V11
   \                     ??zclParseInConfigReportCmd_15:
   \   0001E7   FB           MOV       R3,A
   \                     ??zclParseInConfigReportCmd_14:
   \   0001E8   E8           MOV       A,R0
   \   0001E9   FC           MOV       R4,A
   \   0001EA   E9           MOV       A,R1
   \   0001EB   FD           MOV       R5,A
   \   0001EC   EC           MOV       A,R4
   \   0001ED   24FF         ADD       A,#-0x1
   \   0001EF   18           DEC       R0
   \   0001F0   ED           MOV       A,R5
   \   0001F1   34FF         ADDC      A,#-0x1
   \   0001F3   F9           MOV       R1,A
   \   0001F4   EC           MOV       A,R4
   \   0001F5   4D           ORL       A,R5
   \   0001F6   70C5         JNZ       ??zclParseInConfigReportCmd_16
   \   0001F8   85..82       MOV       DPL,?V0
   \   0001FB   85..83       MOV       DPH,?V1
   \   0001FE   A3           INC       DPTR
   \   0001FF   A3           INC       DPTR
   \   000200   A3           INC       DPTR
   \   000201   A3           INC       DPTR
   \   000202   A3           INC       DPTR
   \   000203   A3           INC       DPTR
   \   000204   A3           INC       DPTR
   \   000205   A3           INC       DPTR
   \   000206   A3           INC       DPTR
   \   000207   A3           INC       DPTR
   \   000208   E5..         MOV       A,?V6
   \   00020A   F0           MOVX      @DPTR,A
   \   00020B   A3           INC       DPTR
   \   00020C   E5..         MOV       A,?V7
   \   00020E   F0           MOVX      @DPTR,A
   \   00020F                ; Setup parameters for call to function zclGetDataTypeLength
   \   00020F   85..82       MOV       DPL,?V12
   \   000212   85..83       MOV       DPH,?V13
   \   000215   E0           MOVX      A,@DPTR
   \   000216   F9           MOV       R1,A
   \   000217   12....       LCALL     ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   00021A   5001         JNC       ??zclParseInConfigReportCmd_17
   \   00021C   08           INC       R0
   \                     ??zclParseInConfigReportCmd_17:
   \   00021D   12....       LCALL     ?Subroutine116 & 0xFFFF
   3951              } // while loop
   3952            }
   \                     ??CrossCallReturnLabel_188:
   \   000220   02....       LJMP      ??zclParseInConfigReportCmd_9 & 0xFFFF
   3953          
   3954            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_6:
   \   000223   AA..         MOV       R2,?V8
   \   000225   AB..         MOV       R3,?V9
   \   000227   02....       LJMP      ?Subroutine7 & 0xFFFF
   3955          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   12....       LCALL     `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000003   E9           MOV       A,R1
   \   000004   F8           MOV       R0,A
   \   000005   EE           MOV       A,R6
   \   000006   29           ADD       A,R1
   \   000007   FE           MOV       R6,A
   \   000008   E4           CLR       A
   \   000009   3F           ADDC      A,R7
   \   00000A   FF           MOV       R7,A
   \   00000B   E9           MOV       A,R1
   \   00000C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   E5..         MOV       A,?V6
   \   000002   28           ADD       A,R0
   \   000003   F5..         MOV       ?V6,A
   \   000005   E4           CLR       A
   \   000006   35..         ADDC      A,?V7
   \   000008   F5..         MOV       ?V7,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   FC           MOV       R4,A
   \   000001   A3           INC       DPTR
   \   000002   E0           MOVX      A,@DPTR
   \   000003   F9           MOV       R1,A
   \   000004   EC           MOV       A,R4
   \   000005   85..82       MOV       DPL,?V0
   \   000008   85..83       MOV       DPH,?V1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000003   8582..       MOV       ?V0,DPL
   \   000006   8583..       MOV       ?V1,DPH
   \   000009   22           RET
   3956          #endif
   3957          
   3958          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   3959          /*********************************************************************
   3960           * @fn      zclParseInConfigReportRspCmd
   3961           *
   3962           * @brief   Parse the "Profile" Configure Reporting Response Command
   3963           *
   3964           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3965           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3966           *
   3967           * @param   pCmd - pointer to incoming data to parse
   3968           *
   3969           * @return  pointer to the parsed command structure
   3970           */
   3971          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3972          {
   3973            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3974            uint8 *pBuf = pCmd->pData;
   3975            uint8 numAttr;
   3976          
   3977            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3978          
   3979            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3980                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3981            if ( cfgReportRspCmd != NULL )
   3982            {
   3983              uint8 i;
   3984              cfgReportRspCmd->numAttr = numAttr;
   3985              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3986              {
   3987                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3988                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3989                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3990                pBuf += 2;
   3991              }
   3992            }
   3993          
   3994            return ( (void *)cfgReportRspCmd );
   3995          }
   3996          #endif
   3997          
   3998          #ifdef ZCL_REPORTING_DEVICE
   3999          /*********************************************************************
   4000           * @fn      zclParseInReadReportCfgCmd
   4001           *
   4002           * @brief   Parse the "Profile" Read Reporting Configuration Command
   4003           *
   4004           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4005           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4006           *
   4007           * @param   pCmd - pointer to incoming data to parse
   4008           *
   4009           * @return  pointer to the parsed command structure
   4010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4011          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   4012          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4013            zclReadReportCfgCmd_t *readReportCfgCmd;
   4014            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   4015            uint8 numAttr;
   4016          
   4017            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_397:
   \   00000F   8A82         MOV       DPL,R2
   \   000011   8B83         MOV       DPH,R3
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000017   7A03         MOV       R2,#0x3
   \   000019   7B00         MOV       R3,#0x0
   \   00001B   12....       LCALL     ?US_DIV_MOD
   \   00001E   E8           MOV       A,R0
   \   00001F   F5..         MOV       ?V0,A
   4018          
   4019            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   4020                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000021                ; Setup parameters for call to function osal_mem_alloc
   \   000021   75F003       MOV       B,#0x3
   \   000024   A4           MUL       AB
   \   000025   A9F0         MOV       R1,B
   \   000027   2401         ADD       A,#0x1
   \   000029   FA           MOV       R2,A
   \   00002A   E4           CLR       A
   \   00002B   39           ADDC      A,R1
   \   00002C   FB           MOV       R3,A
   \   00002D   12....       LCALL     ??Subroutine153_0 & 0xFFFF
   4021            if ( readReportCfgCmd != NULL )
   \                     ??CrossCallReturnLabel_254:
   \   000030   6034         JZ        ??zclParseInReadReportCfgCmd_0
   4022            {
   4023              uint8 i;
   4024              readReportCfgCmd->numAttr = numAttr;
   \   000032   8A82         MOV       DPL,R2
   \   000034   8B83         MOV       DPH,R3
   \   000036   E5..         MOV       A,?V0
   \   000038   F0           MOVX      @DPTR,A
   4025              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000039   75..00       MOV       ?V0,#0x0
   \   00003C   801F         SJMP      ??zclParseInReadReportCfgCmd_1
   4026              {
   4027                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00003E   E5..         MOV       A,?V0
   \   000040   12....       LCALL     ?Subroutine15 & 0xFFFF
   4028                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_390:
   \   000043   F5..         MOV       ?V2,A
   \   000045   A3           INC       DPTR
   \   000046   E0           MOVX      A,@DPTR
   \   000047   FD           MOV       R5,A
   \   000048   E5..         MOV       A,?V2
   \   00004A   8882         MOV       DPL,R0
   \   00004C   8983         MOV       DPH,R1
   \   00004E   A3           INC       DPTR
   \   00004F   A3           INC       DPTR
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   ED           MOV       A,R5
   \   000053   F0           MOVX      @DPTR,A
   4029                pBuf += 2;
   \   000054   EE           MOV       A,R6
   \   000055   2402         ADD       A,#0x2
   \   000057   FE           MOV       R6,A
   \   000058   5001         JNC       ??zclParseInReadReportCfgCmd_3
   \   00005A   0F           INC       R7
   4030              }
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00005B   05..         INC       ?V0
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00005D   8A82         MOV       DPL,R2
   \   00005F   8B83         MOV       DPH,R3
   \   000061   12....       LCALL     ??Subroutine161_0 & 0xFFFF
   4031            }
   \                     ??CrossCallReturnLabel_274:
   \   000064   40D8         JC        ??zclParseInReadReportCfgCmd_2
   4032          
   4033            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000066   02....       LJMP      ?Subroutine3 & 0xFFFF
   4034          }
   4035          #endif
   4036          
   4037          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   4038          /*********************************************************************
   4039           * @fn      zclParseInReadReportCfgRspCmd
   4040           *
   4041           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   4042           *
   4043           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4044           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4045           *
   4046           * @param   pCmd - pointer to incoming data to parse
   4047           *
   4048           * @return  pointer to the parsed command structure
   4049           */
   4050          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   4051          {
   4052            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   4053            uint8 reportChangeLen;
   4054            uint8 *pBuf = pCmd->pData;
   4055            uint8 *dataPtr;
   4056            uint8 numAttr = 0;
   4057            uint8 hdrLen;
   4058            uint16 dataLen = 0;
   4059          
   4060            // Calculate the length of the response command
   4061            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4062            {
   4063              uint8 status;
   4064              uint8 direction;
   4065          
   4066              numAttr++;
   4067              status = *pBuf++;
   4068              direction = *pBuf++;
   4069              pBuf += 2; // move pass the attribute ID
   4070          
   4071              if ( status == ZCL_STATUS_SUCCESS )
   4072              {
   4073                if ( direction == ZCL_SEND_ATTR_REPORTS )
   4074                {
   4075                  uint8 dataType = *pBuf++;
   4076                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   4077          
   4078                  // For attributes of 'discrete' data types this field is omitted
   4079                  if ( zclAnalogDataType( dataType ) )
   4080                  {
   4081                    reportChangeLen = zclGetDataTypeLength( dataType );
   4082                    pBuf += reportChangeLen;
   4083          
   4084                    // add padding if needed
   4085                    if ( PADDING_NEEDED( reportChangeLen ) )
   4086                    {
   4087                      reportChangeLen++;
   4088                    }
   4089          
   4090                    dataLen += reportChangeLen;
   4091                  }
   4092                }
   4093                else
   4094                {
   4095                  pBuf += 2; // move pass the Timeout field
   4096                }
   4097              }
   4098            } // while loop
   4099          
   4100            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   4101          
   4102            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4103            if ( readReportCfgRspCmd != NULL )
   4104            {
   4105              uint8 i;
   4106              pBuf = pCmd->pData;
   4107              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   4108          
   4109              readReportCfgRspCmd->numAttr = numAttr;
   4110              for ( i = 0; i < numAttr; i++ )
   4111              {
   4112                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   4113          
   4114                reportRspRec->status = *pBuf++;
   4115                reportRspRec->direction = *pBuf++;
   4116                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4117                pBuf += 2;
   4118          
   4119                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   4120                {
   4121                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   4122                  {
   4123                    reportRspRec->dataType = *pBuf++;
   4124                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4125                    pBuf += 2;
   4126                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4127                    pBuf += 2;
   4128          
   4129                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   4130                    {
   4131                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   4132                      reportRspRec->reportableChange = dataPtr;
   4133          
   4134                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   4135                      pBuf += reportChangeLen;
   4136          
   4137                      // advance attribute data pointer
   4138                      if ( PADDING_NEEDED( reportChangeLen ) )
   4139                      {
   4140                        reportChangeLen++;
   4141                      }
   4142          
   4143                      dataPtr += reportChangeLen;
   4144                    }
   4145                  }
   4146                  else
   4147                  {
   4148                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   4149                    pBuf += 2;
   4150                  }
   4151                }
   4152              }
   4153            }
   4154          
   4155            return ( (void *)readReportCfgRspCmd );
   4156          }
   4157          #endif
   4158          
   4159          #ifdef ZCL_REPORT_DESTINATION_DEVICE
   4160          /*********************************************************************
   4161           * @fn      zclParseInReportCmd
   4162           *
   4163           * @brief   Parse the "Profile" Report Command
   4164           *
   4165           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4166           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4167           *
   4168           * @param   pCmd - pointer to incoming data to parse
   4169           *
   4170           * @return  pointer to the parsed command structure
   4171           */
   4172          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   4173          {
   4174            zclReportCmd_t *reportCmd;
   4175            uint8 *pBuf = pCmd->pData;
   4176            uint16 attrDataLen;
   4177            uint8 *dataPtr;
   4178            uint8 numAttr = 0;
   4179            uint8 hdrLen;
   4180            uint16 dataLen = 0;
   4181          
   4182            // find out the number of attributes and the length of attribute data
   4183            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4184            {
   4185              uint8 dataType;
   4186          
   4187              numAttr++;
   4188              pBuf += 2; // move pass attribute id
   4189          
   4190              dataType = *pBuf++;
   4191          
   4192              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   4193              pBuf += attrDataLen; // move pass attribute data
   4194          
   4195              // add padding if needed
   4196              if ( PADDING_NEEDED( attrDataLen ) )
   4197              {
   4198                attrDataLen++;
   4199              }
   4200          
   4201              dataLen += attrDataLen;
   4202            }
   4203          
   4204            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   4205          
   4206            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4207            if (reportCmd != NULL )
   4208            {
   4209              uint8 i;
   4210              pBuf = pCmd->pData;
   4211              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   4212          
   4213              reportCmd->numAttr = numAttr;
   4214              for ( i = 0; i < numAttr; i++ )
   4215              {
   4216                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   4217          
   4218                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4219                pBuf += 2;
   4220                reportRec->dataType = *pBuf++;
   4221          
   4222                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   4223                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   4224                reportRec->attrData = dataPtr;
   4225          
   4226                pBuf += attrDataLen; // move pass attribute data
   4227          
   4228                // advance attribute data pointer
   4229                if ( PADDING_NEEDED( attrDataLen ) )
   4230                {
   4231                  attrDataLen++;
   4232                }
   4233          
   4234                dataPtr += attrDataLen;
   4235              }
   4236            }
   4237          
   4238            return ( (void *)reportCmd );
   4239          }
   4240          #endif
   4241          
   4242          /*********************************************************************
   4243           * @fn      zclParseInDefaultRspCmd
   4244           *
   4245           * @brief   Parse the "Profile" Default Response Command
   4246           *
   4247           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4248           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4249           *
   4250           * @param   pCmd - pointer to incoming data to parse
   4251           *
   4252           * @return  pointer to the parsed command structure
   4253           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4254          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   4255          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4256            zclDefaultRspCmd_t *defaultRspCmd;
   4257            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine79 & 0xFFFF
   4258          
   4259            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_134:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A02         MOV       R2,#0x2
   \   00000A   12....       LCALL     ?Subroutine141 & 0xFFFF
   4260            if ( defaultRspCmd != NULL )
   \                     ??CrossCallReturnLabel_252:
   \   00000D   6009         JZ        ??zclParseInDefaultRspCmd_0
   4261            {
   4262              defaultRspCmd->commandID = *pBuf++;
   \   00000F   12....       LCALL     ?Subroutine22 & 0xFFFF
   4263              defaultRspCmd->statusCode = *pBuf;
   4264            }
   \                     ??CrossCallReturnLabel_346:
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   F0           MOVX      @DPTR,A
   4265          
   4266            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000018   02....       LJMP      ?Subroutine2 & 0xFFFF
   4267          }
   4268          
   4269          #ifdef ZCL_DISCOVER
   4270          /*********************************************************************
   4271           * @fn      zclParseInDiscAttrsCmd
   4272           *
   4273           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   4274           *
   4275           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4276           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4277           *
   4278           * @param   pCmd - pointer to incoming data to parse
   4279           *
   4280           * @return  pointer to the parsed command structure
   4281           */
   4282          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   4283          {
   4284            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4285            uint8 *pBuf = pCmd->pData;
   4286          
   4287            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   4288            if ( pDiscoverCmd != NULL )
   4289            {
   4290              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   4291              pBuf += 2;
   4292              pDiscoverCmd->maxAttrIDs = *pBuf;
   4293            }
   4294          
   4295            return ( (void *)pDiscoverCmd );
   4296          }
   4297          
   4298          /*********************************************************************
   4299           * @fn      zclParseInDiscAttrsRspCmd
   4300           *
   4301           * @brief   Parse the "Profile" Discovery Response Commands
   4302           *
   4303           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4304           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4305           *
   4306           * @param   pCmd - pointer to incoming data to parse
   4307           *
   4308           * @return  pointer to the parsed command structure
   4309           */
   4310          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4311          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   4312          {
   4313            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   4314            uint8 *pBuf = pCmd->pData;
   4315            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   4316          
   4317            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   4318                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   4319          
   4320            if ( pDiscoverRspCmd != NULL )
   4321            {
   4322              uint8 i;
   4323          
   4324              pDiscoverRspCmd->discComplete = *pBuf++;
   4325              pDiscoverRspCmd->numAttr = numAttr;
   4326          
   4327              for ( i = 0; i < numAttr; i++ )
   4328              {
   4329                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4330                pBuf += 2;
   4331                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   4332              }
   4333            }
   4334          
   4335            return ( (void *)pDiscoverRspCmd );
   4336          }
   4337          
   4338          /*********************************************************************
   4339           * @fn      zclParseInDiscCmdsCmd
   4340           *
   4341           * @brief   Parse the "Profile" Discovery Commands
   4342           *
   4343           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4344           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4345           *
   4346           * @param   pCmd - pointer to incoming data to parse
   4347           *
   4348           * @return  pointer to the parsed command structure
   4349           */
   4350          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4351          {
   4352            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4353            uint8 *pBuf = pCmd->pData;
   4354          
   4355            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4356            if ( pDiscoverCmd != NULL )
   4357            {
   4358              pDiscoverCmd->startCmdID = *pBuf++;
   4359              pDiscoverCmd->maxCmdID = *pBuf++;
   4360            }
   4361          
   4362            return ( (void *)pDiscoverCmd );
   4363          }
   4364          
   4365          /*********************************************************************
   4366           * @fn      zclParseInDiscCmdsRspCmd
   4367           *
   4368           * @brief   Parse the Discover Commands Response Command
   4369           *
   4370           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4371           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4372           *
   4373           * @param   pCmd - pointer to incoming data to parse
   4374           *
   4375           * @return  pointer to the parsed command structure
   4376           */
   4377          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4378          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4379          {
   4380            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4381            uint8 *pBuf = pCmd->pData;
   4382            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4383          
   4384              // allocate memory for size of structure plus variable array
   4385            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4386                              ( numCmds * sizeof(uint8) ) );
   4387            if ( pDiscoverRspCmd != NULL )
   4388            {
   4389              uint8 i;
   4390              pDiscoverRspCmd->discComplete = *pBuf++;
   4391              pDiscoverRspCmd->numCmd = numCmds;
   4392          
   4393              for ( i = 0; i < numCmds; i++ )
   4394              {
   4395                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4396              }
   4397            }
   4398          
   4399            return ( (void *)pDiscoverRspCmd );
   4400          }
   4401          
   4402          /*********************************************************************
   4403           * @fn      zclParseInDiscAttrsExtRspCmd
   4404           *
   4405           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4406           *
   4407           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4408           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4409           *
   4410           * @param   pCmd - pointer to incoming data to parse
   4411           *
   4412           * @return  pointer to the parsed command structure
   4413           */
   4414          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4415          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4416          {
   4417            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4418            uint8 i;
   4419            uint8 *pBuf = pCmd->pData;
   4420            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4421          
   4422            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4423                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4424          
   4425            if ( pDiscoverRspCmd != NULL )
   4426            {
   4427              pDiscoverRspCmd->discComplete = *pBuf++;
   4428              pDiscoverRspCmd->numAttr = numAttrs;
   4429          
   4430              for ( i = 0; i < numAttrs; i++ )
   4431              {
   4432                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4433                pBuf += 2;
   4434                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4435                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4436              }
   4437            }
   4438          
   4439            return ( (void *)pDiscoverRspCmd );
   4440          }
   4441          #endif // ZCL_DISCOVER
   4442          
   4443          #ifdef ZCL_READ
   4444          /*********************************************************************
   4445           * @fn      zclProcessInReadCmd
   4446           *
   4447           * @brief   Process the "Profile" Read Command
   4448           *
   4449           * @param   pInMsg - incoming message to process
   4450           *
   4451           * @return  TRUE if command processed. FALSE, otherwise.
   4452           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4453          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4454          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   4455            zclReadCmd_t *readCmd;
   4456            zclReadRspCmd_t *readRspCmd;
   4457            zclAttrRec_t attrRec;
   4458            uint16 len;
   4459            uint8 i;
   4460            uint8 attrFound;
   4461          
   4462            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EA           MOV       A,R2
   \   00000F   240C         ADD       A,#0xc
   \   000011   F582         MOV       DPL,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F583         MOV       DPH,A
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F5..         MOV       ?V10,A
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F5..         MOV       ?V11,A
   4463          
   4464            // calculate the length of the response status record
   4465            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4466          
   4467            readRspCmd = zcl_mem_alloc( len );
   \   00001E                ; Setup parameters for call to function osal_mem_alloc
   \   00001E   85..82       MOV       DPL,?V10
   \   000021   F583         MOV       DPH,A
   \   000023   E0           MOVX      A,@DPTR
   \   000024   75F006       MOV       B,#0x6
   \   000027   A4           MUL       AB
   \   000028   A9F0         MOV       R1,B
   \   00002A   2401         ADD       A,#0x1
   \   00002C   FA           MOV       R2,A
   \   00002D   E4           CLR       A
   \   00002E   39           ADDC      A,R1
   \   00002F   12....       LCALL     ??Subroutine184_0 & 0xFFFF
   4468            if ( readRspCmd == NULL )
   \                     ??CrossCallReturnLabel_407:
   \   000032   7005         JNZ       ??zclProcessInReadCmd_0
   4469            {
   4470              return FALSE; // EMBEDDED RETURN
   \   000034   7900         MOV       R1,#0x0
   \   000036   02....       LJMP      ??zclProcessInReadCmd_1 & 0xFFFF
   4471            }
   4472          
   4473            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   000039   85..82       MOV       DPL,?V10
   \   00003C   85..83       MOV       DPH,?V11
   \   00003F   12....       LCALL     ?Subroutine85 & 0xFFFF
   4474            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_145:
   \   000042   75..00       MOV       ?V2,#0x0
   \   000045   EE           MOV       A,R6
   \   000046   2402         ADD       A,#0x2
   \   000048   F5..         MOV       ?V14,A
   \   00004A   E4           CLR       A
   \   00004B   3F           ADDC      A,R7
   \   00004C   F5..         MOV       ?V15,A
   \   00004E   800B         SJMP      ??zclProcessInReadCmd_2
   4475            {
   4476              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4477          
   4478              statusRec->attrID = readCmd->attrID[i];
   4479              
   4480              attrFound = zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec );
   4481              
   4482              //Validate the attribute is found and the access control
   4483              if ( ( attrFound == TRUE ) && 
   4484                   (  (attrRec.attr.accessControl & ACCESS_GLOBAL) || 
   4485                      (GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROL_MASK ) == pInMsg->hdr.fc.direction ) ) )
   4486              {
   4487                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4488                {
   4489                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4490                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4491                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4492                  {
   4493                    statusRec->data = attrRec.attr.dataPtr;
   4494                    statusRec->dataType = attrRec.attr.dataType;
   4495                  }
   4496                }
   4497                else
   4498                {
   4499                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4500                }
   4501              }
   4502              else
   4503              {
   4504                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   000050   85..82       MOV       DPL,?V6
   \   000053   85..83       MOV       DPH,?V7
   \   000056   7486         MOV       A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000058   F0           MOVX      @DPTR,A
   4505              }
   \                     ??zclProcessInReadCmd_5:
   \   000059   05..         INC       ?V2
   \                     ??zclProcessInReadCmd_2:
   \   00005B   85..82       MOV       DPL,?V10
   \   00005E   85..83       MOV       DPH,?V11
   \   000061   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000064   4003         JC        $+5
   \   000066   02....       LJMP      ??zclProcessInReadCmd_6 & 0xFFFF
   \   000069   A8..         MOV       R0,?V2
   \   00006B   E8           MOV       A,R0
   \   00006C   75F006       MOV       B,#0x6
   \   00006F   A4           MUL       AB
   \   000070   FA           MOV       R2,A
   \   000071   ABF0         MOV       R3,B
   \   000073   E5..         MOV       A,?V0
   \   000075   2A           ADD       A,R2
   \   000076   F582         MOV       DPL,A
   \   000078   E5..         MOV       A,?V1
   \   00007A   3B           ADDC      A,R3
   \   00007B   F583         MOV       DPH,A
   \   00007D   A3           INC       DPTR
   \   00007E   8582..       MOV       ?V4,DPL
   \   000081   8583..       MOV       ?V5,DPH
   \   000084   E8           MOV       A,R0
   \   000085   28           ADD       A,R0
   \   000086   F8           MOV       R0,A
   \   000087   E4           CLR       A
   \   000088   33           RLC       A
   \   000089   F9           MOV       R1,A
   \   00008A   E5..         MOV       A,?V10
   \   00008C   28           ADD       A,R0
   \   00008D   F582         MOV       DPL,A
   \   00008F   E5..         MOV       A,?V11
   \   000091   12....       LCALL     ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000094   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000097   E8           MOV       A,R0
   \   000098   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_502:
   \   00009B   E5..         MOV       A,?V4
   \   00009D   2402         ADD       A,#0x2
   \   00009F   F5..         MOV       ?V6,A
   \   0000A1   E4           CLR       A
   \   0000A2   35..         ADDC      A,?V5
   \   0000A4   F5..         MOV       ?V7,A
   \   0000A6   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_455:
   \   0000A9                ; Setup parameters for call to function zclFindAttrRec
   \   0000A9   A8..         MOV       R0,?XSP + 0
   \   0000AB   A9..         MOV       R1,?XSP + 1
   \   0000AD   88..         MOV       ?V12,R0
   \   0000AF   89..         MOV       ?V13,R1
   \   0000B1   78..         MOV       R0,#?V12
   \   0000B3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B6   8A82         MOV       DPL,R2
   \   0000B8   8B83         MOV       DPH,R3
   \   0000BA   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_431:
   \   0000BD   85..82       MOV       DPL,?V8
   \   0000C0   85..83       MOV       DPH,?V9
   \   0000C3   12....       LCALL     ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   0000C6   12....       LCALL     ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   0000C9   12....       LCALL     ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   0000CC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CF   E9           MOV       A,R1
   \   0000D0   6401         XRL       A,#0x1
   \   0000D2   6003         JZ        $+5
   \   0000D4   02....       LJMP      ??zclProcessInReadCmd_3 & 0xFFFF
   \   0000D7   7405         MOV       A,#0x5
   \   0000D9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   A2E6         MOV       C,0xE0 /* A   */.6
   \   0000DF   401A         JC        ??zclProcessInReadCmd_7
   \   0000E1   85..82       MOV       DPL,?V14
   \   0000E4   85..83       MOV       DPH,?V15
   \   0000E7   12....       LCALL     ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   0000EA   7405         MOV       A,#0x5
   \   0000EC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EF   E0           MOVX      A,@DPTR
   \   0000F0   A2E7         MOV       C,0xE0 /* A   */.7
   \   0000F2   20F001       JB        B.0,??zclProcessInReadCmd_8
   \   0000F5   B3           CPL       C
   \                     ??zclProcessInReadCmd_8:
   \   0000F6   4003         JC        $+5
   \   0000F8   02....       LJMP      ??zclProcessInReadCmd_3 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   0000FB   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000FD   5062         JNC       ??zclProcessInReadCmd_9
   \   0000FF   8E82         MOV       DPL,R6
   \   000101   8F83         MOV       DPH,R7
   \   000103   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   000106   E8           MOV       A,R0
   \   000107   2406         ADD       A,#0x6
   \   000109   F5..         MOV       ?V8,A
   \   00010B   E4           CLR       A
   \   00010C   39           ADDC      A,R1
   \   00010D   F5..         MOV       ?V9,A
   \   00010F   7405         MOV       A,#0x5
   \   000111   12....       LCALL     ?XSTACK_DISP0_8
   \   000114   E0           MOVX      A,@DPTR
   \   000115   A2E4         MOV       C,0xE0 /* A   */.4
   \   000117   5018         JNC       ??zclProcessInReadCmd_10
   \   000119                ; Setup parameters for call to function zclGetAuthorizeCB
   \   000119   12....       LCALL     ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00011C   12....       LCALL     ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   00011F   6010         JZ        ??zclProcessInReadCmd_10
   \   000121                ; Setup parameters for indirect call
   \   000121   7901         MOV       R1,#0x1
   \   000123   AC..         MOV       R4,?XSP + 0
   \   000125   AD..         MOV       R5,?XSP + 1
   \   000127   AA..         MOV       R2,?V8
   \   000129   AB..         MOV       R3,?V9
   \   00012B   12....       LCALL     ?CALL_IND
   \   00012E   E9           MOV       A,R1
   \   00012F   8002         SJMP      ??zclProcessInReadCmd_11
   \                     ??zclProcessInReadCmd_10:
   \   000131   7400         MOV       A,#0x0
   \                     ??zclProcessInReadCmd_11:
   \   000133   85..82       MOV       DPL,?V6
   \   000136   85..83       MOV       DPH,?V7
   \   000139   F0           MOVX      @DPTR,A
   \   00013A   6003         JZ        $+5
   \   00013C   02....       LJMP      ??zclProcessInReadCmd_5 & 0xFFFF
   \   00013F   7406         MOV       A,#0x6
   \   000141   12....       LCALL     ?XSTACK_DISP0_8
   \   000144   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000147   A3           INC       DPTR
   \   000148   A3           INC       DPTR
   \   000149   A3           INC       DPTR
   \   00014A   A3           INC       DPTR
   \   00014B   E8           MOV       A,R0
   \   00014C   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_503:
   \   00014F   7404         MOV       A,#0x4
   \   000151   12....       LCALL     ?XSTACK_DISP0_8
   \   000154   E0           MOVX      A,@DPTR
   \   000155   85..82       MOV       DPL,?V4
   \   000158   85..83       MOV       DPH,?V5
   \   00015B   A3           INC       DPTR
   \   00015C   A3           INC       DPTR
   \   00015D   A3           INC       DPTR
   \   00015E   02....       LJMP      ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_9:
   \   000161   85..82       MOV       DPL,?V6
   \   000164   85..83       MOV       DPH,?V7
   \   000167   748F         MOV       A,#-0x71
   \   000169   02....       LJMP      ??zclProcessInReadCmd_4 & 0xFFFF
   4506            }
   4507          
   4508            // Build and send Read Response command
   4509            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4510                             readRspCmd, !pInMsg->hdr.fc.direction,
   4511                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00016C   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_456:
   \   00016F                ; Setup parameters for call to function zcl_SendReadRsp
   \   00016F   8E82         MOV       DPL,R6
   \   000171   8F83         MOV       DPH,R7
   \   000173   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   000176   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000179   75..01       MOV       ?V2,#0x1
   \   00017C   78..         MOV       R0,#?V2
   \   00017E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000181   85..82       MOV       DPL,?V14
   \   000184   85..83       MOV       DPH,?V15
   \   000187   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00018A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00018D   78..         MOV       R0,#?V0
   \   00018F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000192   85..82       MOV       DPL,?V8
   \   000195   85..83       MOV       DPH,?V9
   \   000198   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   00019B   E5..         MOV       A,?V8
   \   00019D   12....       LCALL     ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   0001A0   35..         ADDC      A,?V9
   \   0001A2   FB           MOV       R3,A
   \   0001A3   12....       LCALL     ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   0001A6   12....       LCALL     `??zcl_SendReadRsp::?relay`; Banked call to: zcl_SendReadRsp
   \   0001A9   7405         MOV       A,#0x5
   \   0001AB   12....       LCALL     ?DEALLOC_XSTACK8
   4512            zcl_mem_free( readRspCmd );
   \   0001AE                ; Setup parameters for call to function osal_mem_free
   \   0001AE   AA..         MOV       R2,?V0
   \   0001B0   AB..         MOV       R3,?V1
   \   0001B2   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4513          
   4514            return TRUE;
   \   0001B5   7901         MOV       R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   0001B7   7408         MOV       A,#0x8
   \   0001B9                REQUIRE ?Subroutine5
   \   0001B9                ; // Fall through to label ?Subroutine5
   4515          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   E5..         MOV       A,?V8
   \   000002   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_464:
   \   000005   35..         ADDC      A,?V9
   \   000007   F583         MOV       DPH,A
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   F9           MOV       R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006                REQUIRE ??Subroutine190_0
   \   000006                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine191_0
   \   000004                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   13           RRC       A
   \   000002   13           RRC       A
   \   000003   13           RRC       A
   \   000004   541F         ANL       A,#0x1f
   \   000006   A2E0         MOV       C,0xE0 /* A   */.0
   \   000008   92F0         MOV       B.0,C
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL     ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   F5..         MOV       ?V2,A
   \   000005   78..         MOV       R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   2406         ADD       A,#0x6
   \   000002   FA           MOV       R2,A
   \   000003   E4           CLR       A
   \   000004   22           RET
   4516          #endif // ZCL_READ
   4517          
   4518          #ifdef ZCL_WRITE
   4519          /*********************************************************************
   4520           * @fn      processInWriteCmd
   4521           *
   4522           * @brief   Process the "Profile" Write and Write No Response Commands
   4523           *
   4524           * @param   pInMsg - incoming message to process
   4525           *
   4526           * @return  TRUE if command processed. FALSE, otherwise.
   4527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4528          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4529          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   4530            zclWriteCmd_t *writeCmd;
   4531            zclWriteRspCmd_t *writeRspCmd;
   4532            uint8 sendRsp = FALSE;
   \   00000E   C2..         CLR       ?VB.0
   4533            uint8 j = 0;
   \   000010   7E00         MOV       R6,#0x0
   4534            uint8 i;
   4535          
   4536            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000012   EA           MOV       A,R2
   \   000013   240C         ADD       A,#0xc
   \   000015   F582         MOV       DPL,A
   \   000017   E4           CLR       A
   \   000018   35..         ADDC      A,?V3
   \   00001A   F583         MOV       DPH,A
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F5..         MOV       ?V14,A
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F5..         MOV       ?V15,A
   4537            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   000023   8A82         MOV       DPL,R2
   \   000025   8B83         MOV       DPH,R3
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   6402         XRL       A,#0x2
   \   000031   7018         JNZ       ??zclProcessInWriteCmd_0
   4538            {
   4539              // We need to send a response back - allocate space for it
   4540              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4541                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000033                ; Setup parameters for call to function osal_mem_alloc
   \   000033   85..82       MOV       DPL,?V14
   \   000036   85..83       MOV       DPH,?V15
   \   000039   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00003C   8A..         MOV       ?V4,R2
   \   00003E   8B..         MOV       ?V5,R3
   4542              if ( writeRspCmd == NULL )
   \   000040   EA           MOV       A,R2
   \   000041   4B           ORL       A,R3
   \   000042   7005         JNZ       ??zclProcessInWriteCmd_1
   4543              {
   4544                return FALSE; // EMBEDDED RETURN
   \   000044   7900         MOV       R1,#0x0
   \   000046   02....       LJMP      ??zclProcessInWriteCmd_2 & 0xFFFF
   4545              }
   4546          
   4547              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000049   D2..         SETB      ?VB.0
   4548            }
   4549          
   4550            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   00004B   7F00         MOV       R7,#0x0
   \   00004D   8010         SJMP      ??zclProcessInWriteCmd_3
   4551            {
   4552              zclAttrRec_t attrRec;
   4553              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4554          
   4555              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4556                                   statusRec->attrID, &attrRec ) )
   4557              {
   4558                if ( GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROLEXT_MASK ) != pInMsg->hdr.fc.direction )
   4559                {
   4560                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4561                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4562                  break;
   4563                }
   4564                if ( statusRec->dataType == attrRec.attr.dataType )
   4565                {
   4566                  uint8 status;
   4567          
   4568                  // Write the new attribute value
   4569                  if ( attrRec.attr.dataPtr != NULL )
   4570                  {
   4571                    //Handle special case for Identify
   4572                    if((pInMsg->msg->clusterId == ZCL_CLUSTER_ID_GEN_IDENTIFY) && (statusRec->attrID == ATTRID_IDENTIFY_TIME))
   4573                    {
   4574                      uint16 identifyTime; 
   4575                            
   4576                      osal_memcpy((uint8*)&identifyTime,statusRec->attrData,sizeof(uint16));
   4577                                  
   4578                      bdb_ZclIdentifyCmdInd(identifyTime, pInMsg->msg->endPoint);
   4579                      
   4580                      status = ZCL_STATUS_SUCCESS;
   4581                    }          
   4582                    else
   4583                    {                
   4584                      status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4585                                                 &attrRec, statusRec );
   4586                    }
   4587                  }
   4588                  else // Use CB
   4589                  {
   4590                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4591                                                      &attrRec, statusRec->attrData );
   4592                  }
   4593          
   4594                  // If successful, a write attribute status record shall NOT be generated
   4595                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4596                  {
   4597                    // Attribute is read only - move on to the next write attribute record
   4598                    writeRspCmd->attrList[j].status = status;
   4599                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4600                  }
   4601                }
   4602                else
   4603                {
   4604                  // Attribute data type is incorrect - move on to the next write attribute record
   4605                  if ( sendRsp )
   4606                  {
   4607                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4608                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4609                  }
   4610                }
   4611              }
   4612              else
   4613              {
   4614                // Attribute is not supported - move on to the next write attribute record
   4615                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   00004F   A2..         MOV       C,?VB.0
   \   000051   500B         JNC       ??CrossCallReturnLabel_4
   4616                {
   4617                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000053   85..82       MOV       DPL,?V12
   \   000056   85..83       MOV       DPH,?V13
   \   000059   7486         MOV       A,#-0x7a
   4618                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4619                }
   4620              }
   \                     ??zclProcessInWriteCmd_5:
   \   00005B   12....       LCALL     ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00005E   0F           INC       R7
   \                     ??zclProcessInWriteCmd_3:
   \   00005F   85..82       MOV       DPL,?V14
   \   000062   85..83       MOV       DPH,?V15
   \   000065   E0           MOVX      A,@DPTR
   \   000066   F8           MOV       R0,A
   \   000067   EF           MOV       A,R7
   \   000068   C3           CLR       C
   \   000069   98           SUBB      A,R0
   \   00006A   507A         JNC       ??CrossCallReturnLabel_5
   \   00006C   EF           MOV       A,R7
   \   00006D   75F005       MOV       B,#0x5
   \   000070   A4           MUL       AB
   \   000071   F8           MOV       R0,A
   \   000072   A9F0         MOV       R1,B
   \   000074   E5..         MOV       A,?V14
   \   000076   28           ADD       A,R0
   \   000077   F582         MOV       DPL,A
   \   000079   E5..         MOV       A,?V15
   \   00007B   12....       LCALL     ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   00007E   EE           MOV       A,R6
   \   00007F   75F003       MOV       B,#0x3
   \   000082   A4           MUL       AB
   \   000083   F8           MOV       R0,A
   \   000084   A9F0         MOV       R1,B
   \   000086   E5..         MOV       A,?V4
   \   000088   28           ADD       A,R0
   \   000089   F582         MOV       DPL,A
   \   00008B   E5..         MOV       A,?V5
   \   00008D   39           ADDC      A,R1
   \   00008E   F583         MOV       DPH,A
   \   000090   E582         MOV       A,DPL
   \   000092   2402         ADD       A,#0x2
   \   000094   F5..         MOV       ?V8,A
   \   000096   E4           CLR       A
   \   000097   3583         ADDC      A,DPH
   \   000099   F5..         MOV       ?V9,A
   \   00009B   A3           INC       DPTR
   \   00009C   8582..       MOV       ?V12,DPL
   \   00009F   8583..       MOV       ?V13,DPH
   \   0000A2   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_471:
   \   0000A5                ; Setup parameters for call to function zclFindAttrRec
   \   0000A5   7402         MOV       A,#0x2
   \   0000A7   12....       LCALL     ?XSTACK_DISP100_8
   \   0000AA   88..         MOV       ?V10,R0
   \   0000AC   89..         MOV       ?V11,R1
   \   0000AE   78..         MOV       R0,#?V10
   \   0000B0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B3   85..82       MOV       DPL,?V0
   \   0000B6   85..83       MOV       DPH,?V1
   \   0000B9   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_484:
   \   0000BC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BF   E9           MOV       A,R1
   \   0000C0   608D         JZ        ??zclProcessInWriteCmd_4
   \   0000C2   85..82       MOV       DPL,?V2
   \   0000C5   85..83       MOV       DPH,?V3
   \   0000C8   A3           INC       DPTR
   \   0000C9   A3           INC       DPTR
   \   0000CA   12....       LCALL     ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   0000CD   7407         MOV       A,#0x7
   \   0000CF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D2   E0           MOVX      A,@DPTR
   \   0000D3   A2E7         MOV       C,0xE0 /* A   */.7
   \   0000D5   20F001       JB        B.0,??zclProcessInWriteCmd_6
   \   0000D8   B3           CPL       C
   \                     ??zclProcessInWriteCmd_6:
   \   0000D9   4072         JC        ??zclProcessInWriteCmd_7
   \   0000DB   85..82       MOV       DPL,?V12
   \   0000DE   85..83       MOV       DPH,?V13
   \   0000E1   7486         MOV       A,#-0x7a
   \   0000E3   12....       LCALL     ?Subroutine14 & 0xFFFF
   4621            } // for loop
   4622          
   4623            if ( sendRsp )
   \                     ??CrossCallReturnLabel_5:
   \   0000E6   A2..         MOV       C,?VB.0
   \   0000E8   505C         JNC       ??zclProcessInWriteCmd_8
   4624            {
   4625              writeRspCmd->numAttr = j;
   \   0000EA   EE           MOV       A,R6
   \   0000EB   85..82       MOV       DPL,?V4
   \   0000EE   85..83       MOV       DPH,?V5
   \   0000F1   F0           MOVX      @DPTR,A
   4626              if ( writeRspCmd->numAttr == 0 )
   \   0000F2   700B         JNZ       ??zclProcessInWriteCmd_9
   4627              {
   4628                // Since all records were written successful, include a single status record
   4629                // in the resonse command with the status field set to SUCCESS and the
   4630                // attribute ID field omitted.
   4631                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0000F4   A3           INC       DPTR
   \   0000F5   E4           CLR       A
   \   0000F6   F0           MOVX      @DPTR,A
   4632                writeRspCmd->numAttr = 1;
   \   0000F7   85..82       MOV       DPL,?V4
   \   0000FA   85..83       MOV       DPH,?V5
   \   0000FD   04           INC       A
   \   0000FE   F0           MOVX      @DPTR,A
   4633              }
   4634          
   4635              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4636                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4637                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_9:
   \   0000FF   85..82       MOV       DPL,?V2
   \   000102   85..83       MOV       DPH,?V3
   \   000105   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   000108                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000108   85..82       MOV       DPL,?V2
   \   00010B   85..83       MOV       DPH,?V3
   \   00010E   A3           INC       DPTR
   \   00010F   A3           INC       DPTR
   \   000110   A3           INC       DPTR
   \   000111   A3           INC       DPTR
   \   000112   A3           INC       DPTR
   \   000113   A3           INC       DPTR
   \   000114   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000117   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011A   75..01       MOV       ?V0,#0x1
   \   00011D   78..         MOV       R0,#?V0
   \   00011F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000122   85..82       MOV       DPL,?V2
   \   000125   85..83       MOV       DPH,?V3
   \   000128   A3           INC       DPTR
   \   000129   A3           INC       DPTR
   \   00012A   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   00012D   F5..         MOV       ?V0,A
   \   00012F   78..         MOV       R0,#?V0
   \   000131   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000134   78..         MOV       R0,#?V4
   \   000136   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000139   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00013C   12....       LCALL     ?DEALLOC_XSTACK8
   4638              zcl_mem_free( writeRspCmd );
   \   00013F                ; Setup parameters for call to function osal_mem_free
   \   00013F   AA..         MOV       R2,?V4
   \   000141   AB..         MOV       R3,?V5
   \   000143   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4639            }
   4640          
   4641            return TRUE;
   \                     ??zclProcessInWriteCmd_8:
   \   000146   7901         MOV       R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   000148   740A         MOV       A,#0xa
   \   00014A   02....       LJMP      ?Subroutine5 & 0xFFFF
   \                     ??zclProcessInWriteCmd_7:
   \   00014D   85..82       MOV       DPL,?V0
   \   000150   85..83       MOV       DPH,?V1
   \   000153   A3           INC       DPTR
   \   000154   A3           INC       DPTR
   \   000155   E0           MOVX      A,@DPTR
   \   000156   F8           MOV       R0,A
   \   000157   7406         MOV       A,#0x6
   \   000159   12....       LCALL     ?XSTACK_DISP0_8
   \   00015C   E0           MOVX      A,@DPTR
   \   00015D   68           XRL       A,R0
   \   00015E   6003         JZ        $+5
   \   000160   02....       LJMP      ??zclProcessInWriteCmd_10 & 0xFFFF
   \   000163   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000166   7408         MOV       A,#0x8
   \   000168   12....       LCALL     ?XSTACK_DISP0_8
   \   00016B   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   00016E   6069         JZ        ??zclProcessInWriteCmd_11
   \   000170   85..82       MOV       DPL,?V6
   \   000173   85..83       MOV       DPH,?V7
   \   000176   A3           INC       DPTR
   \   000177   A3           INC       DPTR
   \   000178   A3           INC       DPTR
   \   000179   A3           INC       DPTR
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   6403         XRL       A,#0x3
   \   00017D   7002         JNZ       ??zclProcessInWriteCmd_12
   \   00017F   A3           INC       DPTR
   \   000180   E0           MOVX      A,@DPTR
   \                     ??zclProcessInWriteCmd_12:
   \   000181   7047         JNZ       ??zclProcessInWriteCmd_13
   \   000183   85..82       MOV       DPL,?V0
   \   000186   85..83       MOV       DPH,?V1
   \   000189   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   00018C   703C         JNZ       ??zclProcessInWriteCmd_13
   \   00018E                ; Setup parameters for call to function osal_memcpy
   \   00018E   85..82       MOV       DPL,?V0
   \   000191   85..83       MOV       DPH,?V1
   \   000194   A3           INC       DPTR
   \   000195   A3           INC       DPTR
   \   000196   A3           INC       DPTR
   \   000197   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_453:
   \   00019A   75..00       MOV       ?V10,#0x0
   \   00019D   78..         MOV       R0,#?V8
   \   00019F   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001A2   7C02         MOV       R4,#0x2
   \   0001A4   7D00         MOV       R5,#0x0
   \   0001A6   7403         MOV       A,#0x3
   \   0001A8   12....       LCALL     ?XSTACK_DISP101_8
   \   0001AB   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_362:
   \   0001AE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B1                ; Setup parameters for call to function bdb_ZclIdentifyCmdInd
   \   0001B1   85..82       MOV       DPL,?V2
   \   0001B4   85..83       MOV       DPH,?V3
   \   0001B7   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   0001BA   F9           MOV       R1,A
   \   0001BB   85..82       MOV       DPL,?XSP + 0
   \   0001BE   85..83       MOV       DPH,?XSP + 1
   \   0001C1   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   0001C4   12....       LCALL     `??bdb_ZclIdentifyCmdInd::?relay`; Banked call to: bdb_ZclIdentifyCmdInd
   \   0001C7   02....       LJMP      ??CrossCallReturnLabel_4 & 0xFFFF
   \                     ??zclProcessInWriteCmd_13:
   \   0001CA                ; Setup parameters for call to function zclWriteAttrData
   \   0001CA   78..         MOV       R0,#?V0
   \   0001CC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001CF   7404         MOV       A,#0x4
   \   0001D1   12....       LCALL     ?XSTACK_DISP102_8
   \   0001D4   12....       LCALL     ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   0001D7   801F         SJMP      ??CrossCallReturnLabel_148
   \                     ??zclProcessInWriteCmd_11:
   \   0001D9                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   0001D9   85..82       MOV       DPL,?V0
   \   0001DC   85..83       MOV       DPH,?V1
   \   0001DF   A3           INC       DPTR
   \   0001E0   A3           INC       DPTR
   \   0001E1   A3           INC       DPTR
   \   0001E2   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0001E5   7404         MOV       A,#0x4
   \   0001E7   12....       LCALL     ?XSTACK_DISP102_8
   \   0001EA   12....       LCALL     ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_480:
   \   0001ED   35..         ADDC      A,?V7
   \   0001EF   FB           MOV       R3,A
   \   0001F0   12....       LCALL     ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   0001F3   35..         ADDC      A,?V7
   \   0001F5   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   0001F8   7402         MOV       A,#0x2
   \   0001FA   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001FD   E9           MOV       A,R1
   \   0001FE   A2..         MOV       C,?VB.0
   \   000200   4003         JC        $+5
   \   000202   02....       LJMP      ??CrossCallReturnLabel_4 & 0xFFFF
   \   000205   7003         JNZ       $+5
   \   000207   02....       LJMP      ??CrossCallReturnLabel_4 & 0xFFFF
   \   00020A   85..82       MOV       DPL,?V12
   \   00020D   85..83       MOV       DPH,?V13
   \   000210   02....       LJMP      ??zclProcessInWriteCmd_5 & 0xFFFF
   \                     ??zclProcessInWriteCmd_10:
   \   000213   A2..         MOV       C,?VB.0
   \   000215   4003         JC        $+5
   \   000217   02....       LJMP      ??CrossCallReturnLabel_4 & 0xFFFF
   \   00021A   85..82       MOV       DPL,?V12
   \   00021D   85..83       MOV       DPH,?V13
   \   000220   748D         MOV       A,#-0x73
   \   000222   02....       LJMP      ??zclProcessInWriteCmd_5 & 0xFFFF
   4642          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL     ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   F8           MOV       R0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   F9           MOV       R1,A
   \   000007   85..82       MOV       DPL,?V8
   \   00000A   85..83       MOV       DPH,?V9
   \   00000D   E8           MOV       A,R0
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   A3           INC       DPTR
   \   000010   E9           MOV       A,R1
   \   000011   F0           MOVX      @DPTR,A
   \   000012   0E           INC       R6
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   F583         MOV       DPH,A
   \   000002   E0           MOVX      A,@DPTR
   \   000003   F9           MOV       R1,A
   \   000004   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   E5..         MOV       A,?V6
   \   000002                REQUIRE ??Subroutine192_0
   \   000002                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   12....       LCALL     ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_481:
   \   000003   35..         ADDC      A,?V7
   \   000005   FB           MOV       R3,A
   \   000006   12....       LCALL     ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_485:
   \   000009   12....       LCALL     `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine193_0
   \   000006                ; // Fall through to label ??Subroutine193_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   75F003       MOV       B,#0x3
   \   000004   A4           MUL       AB
   \   000005   A9F0         MOV       R1,B
   \   000007   2401         ADD       A,#0x1
   \   000009   FA           MOV       R2,A
   \   00000A   E4           CLR       A
   \   00000B   39           ADDC      A,R1
   \   00000C   FB           MOV       R3,A
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   12....       LCALL     ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_494:
   \   000007   EE           MOV       A,R6
   \   000008   12....       LCALL     ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_479:
   \   00000B   3F           ADDC      A,R7
   \   00000C   FB           MOV       R3,A
   \   00000D   EE           MOV       A,R6
   \   00000E   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_463:
   \   000011   3F           ADDC      A,R7
   \   000012   F583         MOV       DPH,A
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F9           MOV       R1,A
   \   000016   12....       LCALL     `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   000019   7405         MOV       A,#0x5
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   E5..         MOV       A,?V6
   \   000002                REQUIRE ??Subroutine195_0
   \   000002                ; // Fall through to label ??Subroutine195_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   12....       LCALL     ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_497:
   \   000003   85..82       MOV       DPL,?V6
   \   000006   85..83       MOV       DPH,?V7
   \   000009   A3           INC       DPTR
   \   00000A   12....       LCALL     ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_492:
   \   00000D   12....       LCALL     ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_486:
   \   000010   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000013   7402         MOV       A,#0x2
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   E5..         MOV       A,?V6
   \   000002   2414         ADD       A,#0x14
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   35..         ADDC      A,?V7
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   F9           MOV       R1,A
   \   00000D   22           RET
   4643          
   4644          /*********************************************************************
   4645           * @fn      zclRevertWriteUndividedCmd
   4646           *
   4647           * @brief   Revert the "Profile" Write Undevided Command
   4648           *
   4649           * @param   pInMsg - incoming message to process
   4650           * @param   curWriteRec - old data
   4651           * @param   numAttr - number of attributes to be reverted
   4652           *
   4653           * @return  none
   4654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4655          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4656                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4657          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   8C..         MOV       ?V10,R4
   \   000010   8D..         MOV       ?V11,R5
   4658            uint8 i;
   4659          
   4660            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   741C         MOV       A,#0x1c
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_454:
   \   00001D   802C         SJMP      ??zclRevertWriteUndividedCmd_0
   4661            {
   4662              zclAttrRec_t attrRec;
   4663              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4664          
   4665              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4666                                    statusRec->attrID, &attrRec ) )
   4667              {
   4668                break; // should never happen
   4669              }
   4670          
   4671              if ( attrRec.attr.dataPtr != NULL )
   4672              {
   4673                // Just copy the old data back - no need to validate the data
   4674                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4675                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4676              }
   4677              else // Use CB
   4678              {
   4679                // Write the old data back
   4680                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4681                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV       DPL,?V2
   \   000022   85..83       MOV       DPH,?V3
   \   000025   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   4682              }
   \                     ??CrossCallReturnLabel_399:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV       ?V4,R2
   \   00002A   8B..         MOV       ?V5,R3
   \   00002C   78..         MOV       R0,#?V4
   \   00002E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV       A,#0x2
   \   000033   12....       LCALL     ?XSTACK_DISP102_8
   \   000036   EE           MOV       A,R6
   \   000037   12....       LCALL     ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_477:
   \   00003A   3F           ADDC      A,R7
   \   00003B   FB           MOV       R3,A
   \   00003C   EE           MOV       A,R6
   \   00003D   12....       LCALL     ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_458:
   \   000040   3F           ADDC      A,R7
   \   000041   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000044   7402         MOV       A,#0x2
   \   000046   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   000049   05..         INC       ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004B   C3           CLR       C
   \   00004C   E5..         MOV       A,?V0
   \   00004E   95..         SUBB      A,?V8
   \   000050   E4           CLR       A
   \   000051   95..         SUBB      A,?V9
   \   000053   4003         JC        $+5
   \   000055   02....       LJMP      ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   000058   E5..         MOV       A,?V0
   \   00005A   75F005       MOV       B,#0x5
   \   00005D   A4           MUL       AB
   \   00005E   F8           MOV       R0,A
   \   00005F   A9F0         MOV       R1,B
   \   000061   E5..         MOV       A,?V10
   \   000063   28           ADD       A,R0
   \   000064   FE           MOV       R6,A
   \   000065   E5..         MOV       A,?V11
   \   000067   39           ADDC      A,R1
   \   000068   FF           MOV       R7,A
   \   000069   85..82       MOV       DPL,?V2
   \   00006C   85..83       MOV       DPH,?V3
   \   00006F   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_423:
   \   000072   88..         MOV       ?V4,R0
   \   000074   F5..         MOV       ?V5,A
   \   000076                ; Setup parameters for call to function zclFindAttrRec
   \   000076   A8..         MOV       R0,?XSP + 0
   \   000078   A9..         MOV       R1,?XSP + 1
   \   00007A   88..         MOV       ?V6,R0
   \   00007C   89..         MOV       ?V7,R1
   \   00007E   78..         MOV       R0,#?V6
   \   000080   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000083   8E82         MOV       DPL,R6
   \   000085   8F83         MOV       DPH,R7
   \   000087   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   00008A   85..82       MOV       DPL,?V4
   \   00008D   85..83       MOV       DPH,?V5
   \   000090   12....       LCALL     ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   000093   E5..         MOV       A,?V4
   \   000095   12....       LCALL     ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   000098   35..         ADDC      A,?V5
   \   00009A   F583         MOV       DPH,A
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   12....       LCALL     ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   0000A0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A3   E9           MOV       A,R1
   \   0000A4   6049         JZ        ??zclRevertWriteUndividedCmd_3
   \   0000A6   EE           MOV       A,R6
   \   0000A7   2403         ADD       A,#0x3
   \   0000A9   F5..         MOV       ?V4,A
   \   0000AB   E4           CLR       A
   \   0000AC   3F           ADDC      A,R7
   \   0000AD   F5..         MOV       ?V5,A
   \   0000AF   85..82       MOV       DPL,?V4
   \   0000B2   F583         MOV       DPH,A
   \   0000B4   12....       LCALL     ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   0000B7   7406         MOV       A,#0x6
   \   0000B9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   0000BF   EE           MOV       A,R6
   \   0000C0   4F           ORL       A,R7
   \   0000C1   7003         JNZ       $+5
   \   0000C3   02....       LJMP      ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C6                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C6   7404         MOV       A,#0x4
   \   0000C8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CB   12....       LCALL     ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   0000CE   8A..         MOV       ?V6,R2
   \   0000D0   8B..         MOV       ?V7,R3
   \   0000D2   AC..         MOV       R4,?V6
   \   0000D4   AD..         MOV       R5,?V7
   \   0000D6                ; Setup parameters for call to function osal_memcpy
   \   0000D6   85..82       MOV       DPL,?V4
   \   0000D9   85..83       MOV       DPH,?V5
   \   0000DC   12....       LCALL     ?Subroutine45 & 0xFFFF
   4683            } // for loop
   \                     ??CrossCallReturnLabel_62:
   \   0000DF   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000E2   EE           MOV       A,R6
   \   0000E3   FA           MOV       R2,A
   \   0000E4   EF           MOV       A,R7
   \   0000E5   FB           MOV       R3,A
   \   0000E6   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_363:
   \   0000E9   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000EC   02....       LJMP      ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4684          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000EF   7408         MOV       A,#0x8
   \   0000F1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000F4   02....       LJMP      ??Subroutine158_0 & 0xFFFF
   4685          
   4686          /*********************************************************************
   4687           * @fn      zclProcessInWriteUndividedCmd
   4688           *
   4689           * @brief   Process the "Profile" Write Undivided Command
   4690           *
   4691           * @param   pInMsg - incoming message to process
   4692           *
   4693           * @return  TRUE if command processed. FALSE, otherwise.
   4694           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4695          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4696          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV       A,#-0xc
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V4,R2
   \   00000C   8B..         MOV       ?V5,R3
   4697            zclWriteCmd_t *writeCmd;
   4698            zclWriteRspCmd_t *writeRspCmd;
   4699            zclAttrRec_t attrRec;
   4700            uint16 dataLen;
   4701            uint16 curLen = 0;
   \   00000E   75..00       MOV       ?V8,#0x0
   \   000011   75..00       MOV       ?V9,#0x0
   4702            uint8 j = 0;
   \   000014   7E00         MOV       R6,#0x0
   4703            uint8 i;
   4704          
   4705            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000016   EA           MOV       A,R2
   \   000017   240C         ADD       A,#0xc
   \   000019   F582         MOV       DPL,A
   \   00001B   E4           CLR       A
   \   00001C   35..         ADDC      A,?V5
   \   00001E   F583         MOV       DPH,A
   \   000020   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000023   7402         MOV       A,#0x2
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   E8           MOV       A,R0
   \   000029   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   4706          
   4707            // Allocate space for Write Response Command
   4708            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4709                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_504:
   \   00002C                ; Setup parameters for call to function osal_mem_alloc
   \   00002C   7402         MOV       A,#0x2
   \   00002E   12....       LCALL     ?XSTACK_DISP0_8
   \   000031   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000034   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000037   8A..         MOV       ?V0,R2
   \   000039   8B..         MOV       ?V1,R3
   4710            if ( writeRspCmd == NULL )
   \   00003B   EA           MOV       A,R2
   \   00003C   4B           ORL       A,R3
   \   00003D   7003         JNZ       $+5
   \   00003F   02....       LJMP      ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4711            {
   4712              return FALSE; // EMBEDDED RETURN
   4713            }
   4714          
   4715            // If any attribute cannot be written, no attribute values are changed. Hence,
   4716            // make sure all the attributes are supported and writable
   4717            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000042   7F00         MOV       R7,#0x0
   \   000044   803D         SJMP      ??zclProcessInWriteUndividedCmd_1
   4718            {
   4719              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4720          
   4721              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4722                                    statusRec->attrID, &attrRec ) )
   4723              {
   4724                // Attribute is not supported - stop here
   4725                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4726                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4727                break;
   4728              }
   4729          
   4730              if ( statusRec->dataType != attrRec.attr.dataType )
   4731              {
   4732                // Attribute data type is incorrect - stope here
   4733                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4734                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4735                break;
   4736              }
   4737          
   4738              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4739              {
   4740                // Attribute is not writable - stop here
   4741                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4742                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4743                break;
   4744              }
   4745          
   4746              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4747              {
   4748                // Not authorized to write - stop here
   4749                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4750                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4751                break;
   4752              }
   4753          
   4754              // Attribute Data length
   4755              if ( attrRec.attr.dataPtr != NULL )
   4756              {
   4757                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4758              }
   4759              else // Use CB
   4760              {
   4761                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4762                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000046   85..82       MOV       DPL,?V4
   \   000049   85..83       MOV       DPH,?V5
   \   00004C   12....       LCALL     ?Subroutine62 & 0xFFFF
   4763              }
   \                     ??CrossCallReturnLabel_101:
   \   00004F   FC           MOV       R4,A
   \   000050   A3           INC       DPTR
   \   000051   E0           MOVX      A,@DPTR
   \   000052   FD           MOV       R5,A
   \   000053   8882         MOV       DPL,R0
   \   000055   8983         MOV       DPH,R1
   \   000057   12....       LCALL     ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   00005A   12....       LCALL     ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00005D   12....       LCALL     `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000060   12....       LCALL     ?Subroutine33 & 0xFFFF
   4764          
   4765              // add padding if needed
   4766              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_301:
   \   000063   85..82       MOV       DPL,?XSP + 0
   \   000066   85..83       MOV       DPH,?XSP + 1
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   A2E0         MOV       C,0xE0 /* A   */.0
   \   00006C   5003         JNC       ??CrossCallReturnLabel_193
   4767              {
   4768                dataLen++;
   \   00006E   12....       LCALL     ?Subroutine119 & 0xFFFF
   4769              }
   4770          
   4771              curLen += dataLen;
   \                     ??CrossCallReturnLabel_193:
   \   000071   85..82       MOV       DPL,?XSP + 0
   \   000074   85..83       MOV       DPH,?XSP + 1
   \   000077   E0           MOVX      A,@DPTR
   \   000078   25..         ADD       A,?V8
   \   00007A   F5..         MOV       ?V8,A
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   35..         ADDC      A,?V9
   \   000080   F5..         MOV       ?V9,A
   \   000082   0F           INC       R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000083   7402         MOV       A,#0x2
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   00008B   5046         JNC       ??zclProcessInWriteUndividedCmd_4
   \   00008D   EF           MOV       A,R7
   \   00008E   75F005       MOV       B,#0x5
   \   000091   A4           MUL       AB
   \   000092   F8           MOV       R0,A
   \   000093   A9F0         MOV       R1,B
   \   000095   7402         MOV       A,#0x2
   \   000097   12....       LCALL     ?XSTACK_DISP0_8
   \   00009A   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00009D   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   0000A0   12....       LCALL     ?XSTACK_DISP100_8
   \   0000A3   88..         MOV       ?V10,R0
   \   0000A5   89..         MOV       ?V11,R1
   \   0000A7   78..         MOV       R0,#?V10
   \   0000A9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AC   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_482:
   \   0000AF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B2   E9           MOV       A,R1
   \   0000B3   704E         JNZ       ??zclProcessInWriteUndividedCmd_5
   \   0000B5   85..82       MOV       DPL,?V0
   \   0000B8   85..83       MOV       DPH,?V1
   \   0000BB   A3           INC       DPTR
   \   0000BC   7486         MOV       A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000BE   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000C1   F8           MOV       R0,A
   \   0000C2   A3           INC       DPTR
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   F9           MOV       R1,A
   \   0000C5   85..82       MOV       DPL,?V0
   \   0000C8   85..83       MOV       DPH,?V1
   \   0000CB   A3           INC       DPTR
   \   0000CC   A3           INC       DPTR
   \   0000CD   E8           MOV       A,R0
   \   0000CE   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_505:
   \   0000D1   7E01         MOV       R6,#0x1
   4772            } // for loop
   4773          
   4774            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000D3   EE           MOV       A,R6
   \   0000D4   85..82       MOV       DPL,?V0
   \   0000D7   85..83       MOV       DPH,?V1
   \   0000DA   F0           MOVX      @DPTR,A
   4775            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000DB   6003         JZ        $+5
   \   0000DD   02....       LJMP      ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4776            {
   4777              uint8 *curDataPtr;
   4778              zclWriteRec_t *curWriteRec;
   4779          
   4780              // calculate the length of the current data header
   4781              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000E0   75F005       MOV       B,#0x5
   \   0000E3   A4           MUL       AB
   \   0000E4   FF           MOV       R7,A
   4782          
   4783              // Allocate space to keep a copy of the current data
   4784              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000E5                ; Setup parameters for call to function osal_mem_alloc
   \   0000E5   25..         ADD       A,?V8
   \   0000E7   FA           MOV       R2,A
   \   0000E8   E4           CLR       A
   \   0000E9   35..         ADDC      A,?V9
   \   0000EB   FB           MOV       R3,A
   \   0000EC   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000EF   8A..         MOV       ?V14,R2
   \   0000F1   8B..         MOV       ?V15,R3
   4785              if ( curWriteRec == NULL )
   \   0000F3   EA           MOV       A,R2
   \   0000F4   4B           ORL       A,R3
   \   0000F5   705D         JNZ       ??zclProcessInWriteUndividedCmd_8
   4786              {
   4787                zcl_mem_free(writeRspCmd );
   \   0000F7                ; Setup parameters for call to function osal_mem_free
   \   0000F7   AA..         MOV       R2,?V0
   \   0000F9   AB..         MOV       R3,?V1
   \   0000FB   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4788                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   0000FE   7900         MOV       R1,#0x0
   \   000100   02....       LJMP      ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4789              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000103   7408         MOV       A,#0x8
   \   000105   12....       LCALL     ?XSTACK_DISP0_8
   \   000108   12....       LCALL     ??Subroutine194_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_473:
   \   00010B   A3           INC       DPTR
   \   00010C   A3           INC       DPTR
   \   00010D   E0           MOVX      A,@DPTR
   \   00010E   69           XRL       A,R1
   \   00010F   600B         JZ        ??zclProcessInWriteUndividedCmd_10
   \   000111   85..82       MOV       DPL,?V0
   \   000114   85..83       MOV       DPH,?V1
   \   000117   A3           INC       DPTR
   \   000118   748D         MOV       A,#-0x73
   \   00011A   80A2         SJMP      ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00011C   7409         MOV       A,#0x9
   \   00011E   12....       LCALL     ?XSTACK_DISP0_8
   \   000121   E0           MOVX      A,@DPTR
   \   000122   A2E1         MOV       C,0xE0 /* A   */.1
   \   000124   400B         JC        ??zclProcessInWriteUndividedCmd_11
   \   000126   85..82       MOV       DPL,?V0
   \   000129   85..83       MOV       DPH,?V1
   \   00012C   A3           INC       DPTR
   \   00012D   7488         MOV       A,#-0x78
   \   00012F   808D         SJMP      ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000131   A2E5         MOV       C,0xE0 /* A   */.5
   \   000133   500C         JNC       ??zclProcessInWriteUndividedCmd_12
   \   000135   85..82       MOV       DPL,?V0
   \   000138   85..83       MOV       DPH,?V1
   \   00013B   A3           INC       DPTR
   \   00013C   747E         MOV       A,#0x7e
   \   00013E   02....       LJMP      ??zclProcessInWriteUndividedCmd_6 & 0xFFFF
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   000141   740A         MOV       A,#0xa
   \   000143   12....       LCALL     ?XSTACK_DISP0_8
   \   000146   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000149   7003         JNZ       $+5
   \   00014B   02....       LJMP      ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   00014E                ; Setup parameters for call to function zclGetAttrDataLength
   \   00014E   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000151   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4790          
   4791              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000154   EA           MOV       A,R2
   \   000155   2F           ADD       A,R7
   \   000156   F5..         MOV       ?V8,A
   \   000158   E4           CLR       A
   \   000159   3B           ADDC      A,R3
   \   00015A   F5..         MOV       ?V9,A
   4792          
   4793              // Write the new data over
   4794              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00015C   7F00         MOV       R7,#0x0
   \   00015E   801C         SJMP      ??zclProcessInWriteUndividedCmd_13
   4795              {
   4796                uint8 status;
   4797                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4798                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4799          
   4800                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4801                                      statusRec->attrID, &attrRec ) )
   4802                {
   4803                  break; // should never happen
   4804                }
   4805          
   4806                // Keep a copy of the current data before before writing the new data over
   4807                curStatusRec->attrID = statusRec->attrID;
   4808                curStatusRec->attrData = curDataPtr;
   4809          
   4810                if ( attrRec.attr.dataPtr != NULL )
   4811                {
   4812                  // Read the current value
   4813                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4814          
   4815                  // Write the new attribute value
   4816                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4817                                             &attrRec, statusRec );
   4818                }
   4819                else // Use CBs
   4820                {
   4821                  // Read the current value
   4822                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4823                                          statusRec->attrID, curDataPtr, &dataLen );
   4824                  // Write the new attribute value
   4825                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4826                                                    &attrRec, statusRec->attrData );
   4827                }
   4828          
   4829                // If successful, a write attribute status record shall NOT be generated
   4830                if ( status != ZCL_STATUS_SUCCESS )
   4831                {
   4832                  writeRspCmd->attrList[j].status = status;
   4833                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4834          
   4835                  // Since this write failed, we need to revert all the pervious writes
   4836                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4837                  break;
   4838                }
   4839          
   4840                // add padding if needed
   4841                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000160   85..82       MOV       DPL,?XSP + 0
   \   000163   85..83       MOV       DPH,?XSP + 1
   \   000166   E0           MOVX      A,@DPTR
   \   000167   A2E0         MOV       C,0xE0 /* A   */.0
   \   000169   5003         JNC       ??CrossCallReturnLabel_194
   4842                {
   4843                  dataLen++;
   \   00016B   12....       LCALL     ?Subroutine119 & 0xFFFF
   4844                }
   4845          
   4846                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_194:
   \   00016E   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000171   E5..         MOV       A,?V8
   \   000173   28           ADD       A,R0
   \   000174   F5..         MOV       ?V8,A
   \   000176   E5..         MOV       A,?V9
   \   000178   39           ADDC      A,R1
   \   000179   F5..         MOV       ?V9,A
   \   00017B   0F           INC       R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   00017C   7402         MOV       A,#0x2
   \   00017E   12....       LCALL     ?XSTACK_DISP0_8
   \   000181   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000184   4003         JC        $+5
   \   000186   02....       LJMP      ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   000189   EF           MOV       A,R7
   \   00018A   75F005       MOV       B,#0x5
   \   00018D   A4           MUL       AB
   \   00018E   F8           MOV       R0,A
   \   00018F   A9F0         MOV       R1,B
   \   000191   7402         MOV       A,#0x2
   \   000193   12....       LCALL     ?XSTACK_DISP0_8
   \   000196   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000199   E5..         MOV       A,?V14
   \   00019B   28           ADD       A,R0
   \   00019C   F5..         MOV       ?V12,A
   \   00019E   E5..         MOV       A,?V15
   \   0001A0   39           ADDC      A,R1
   \   0001A1   F5..         MOV       ?V13,A
   \   0001A3   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   0001A6   12....       LCALL     ?XSTACK_DISP100_8
   \   0001A9   88..         MOV       ?V10,R0
   \   0001AB   89..         MOV       ?V11,R1
   \   0001AD   78..         MOV       R0,#?V10
   \   0001AF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001B2   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_483:
   \   0001B5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B8   E9           MOV       A,R1
   \   0001B9   7003         JNZ       $+5
   \   0001BB   02....       LJMP      ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001BE   85..82       MOV       DPL,?V2
   \   0001C1   85..83       MOV       DPH,?V3
   \   0001C4   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   0001C7   85..82       MOV       DPL,?V12
   \   0001CA   85..83       MOV       DPH,?V13
   \   0001CD   E8           MOV       A,R0
   \   0001CE   F0           MOVX      @DPTR,A
   \   0001CF   A3           INC       DPTR
   \   0001D0   E9           MOV       A,R1
   \   0001D1   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0001D4   E5..         MOV       A,?V8
   \   0001D6   F0           MOVX      @DPTR,A
   \   0001D7   A3           INC       DPTR
   \   0001D8   E5..         MOV       A,?V9
   \   0001DA   F0           MOVX      @DPTR,A
   \   0001DB   740A         MOV       A,#0xa
   \   0001DD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001E0   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   0001E3   6036         JZ        ??zclProcessInWriteUndividedCmd_16
   \   0001E5                ; Setup parameters for call to function zclReadAttrData
   \   0001E5   A8..         MOV       R0,?XSP + 0
   \   0001E7   A9..         MOV       R1,?XSP + 1
   \   0001E9   88..         MOV       ?V6,R0
   \   0001EB   89..         MOV       ?V7,R1
   \   0001ED   78..         MOV       R0,#?V6
   \   0001EF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001F2   7406         MOV       A,#0x6
   \   0001F4   12....       LCALL     ?XSTACK_DISP102_8
   \   0001F7   AA..         MOV       R2,?V8
   \   0001F9   AB..         MOV       R3,?V9
   \   0001FB   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   0001FE   7402         MOV       A,#0x2
   \   000200   12....       LCALL     ?DEALLOC_XSTACK8
   \   000203   85..82       MOV       DPL,?V4
   \   000206   85..83       MOV       DPH,?V5
   \   000209   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_469:
   \   00020C                ; Setup parameters for call to function zclWriteAttrData
   \   00020C   78..         MOV       R0,#?V2
   \   00020E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000211   7406         MOV       A,#0x6
   \   000213   12....       LCALL     ?XSTACK_DISP102_8
   \   000216   12....       LCALL     ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000219   8060         SJMP      ??CrossCallReturnLabel_150
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   00021B   85..82       MOV       DPL,?V4
   \   00021E   85..83       MOV       DPH,?V5
   \   000221   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   000224                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000224   A8..         MOV       R0,?XSP + 0
   \   000226   A9..         MOV       R1,?XSP + 1
   \   000228   88..         MOV       ?V10,R0
   \   00022A   89..         MOV       ?V11,R1
   \   00022C   78..         MOV       R0,#?V10
   \   00022E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000231   78..         MOV       R0,#?V8
   \   000233   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000236   85..82       MOV       DPL,?V2
   \   000239   85..83       MOV       DPH,?V3
   \   00023C   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   00023F   85..82       MOV       DPL,?V6
   \   000242   85..83       MOV       DPH,?V7
   \   000245   12....       LCALL     ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   000248   12....       LCALL     ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_462:
   \   00024B   35..         ADDC      A,?V7
   \   00024D   F583         MOV       DPH,A
   \   00024F   E0           MOVX      A,@DPTR
   \   000250   F9           MOV       R1,A
   \   000251   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000254   7404         MOV       A,#0x4
   \   000256   12....       LCALL     ?DEALLOC_XSTACK8
   \   000259   85..82       MOV       DPL,?V4
   \   00025C   85..83       MOV       DPH,?V5
   \   00025F   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000262   A3           INC       DPTR
   \   000263   A3           INC       DPTR
   \   000264   A3           INC       DPTR
   \   000265   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000268   7406         MOV       A,#0x6
   \   00026A   12....       LCALL     ?XSTACK_DISP102_8
   \   00026D   E8           MOV       A,R0
   \   00026E   12....       LCALL     ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_478:
   \   000271   39           ADDC      A,R1
   \   000272   FB           MOV       R3,A
   \   000273   E8           MOV       A,R0
   \   000274   12....       LCALL     ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   000277   39           ADDC      A,R1
   \   000278   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   00027B   7402         MOV       A,#0x2
   \   00027D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000280   E9           MOV       A,R1
   \   000281   FA           MOV       R2,A
   \   000282   EA           MOV       A,R2
   \   000283   7003         JNZ       $+5
   \   000285   02....       LJMP      ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000288   EE           MOV       A,R6
   \   000289   75F003       MOV       B,#0x3
   \   00028C   A4           MUL       AB
   \   00028D   F8           MOV       R0,A
   \   00028E   A9F0         MOV       R1,B
   \   000290   E5..         MOV       A,?V0
   \   000292   28           ADD       A,R0
   \   000293   F8           MOV       R0,A
   \   000294   E5..         MOV       A,?V1
   \   000296   39           ADDC      A,R1
   \   000297   F9           MOV       R1,A
   \   000298   EA           MOV       A,R2
   \   000299   8882         MOV       DPL,R0
   \   00029B   8983         MOV       DPH,R1
   \   00029D   A3           INC       DPTR
   \   00029E   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0002A1   FA           MOV       R2,A
   \   0002A2   A3           INC       DPTR
   \   0002A3   E0           MOVX      A,@DPTR
   \   0002A4   FB           MOV       R3,A
   \   0002A5   8882         MOV       DPL,R0
   \   0002A7   8983         MOV       DPH,R1
   \   0002A9   A3           INC       DPTR
   \   0002AA   A3           INC       DPTR
   \   0002AB   12....       LCALL     ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   0002AE   0E           INC       R6
   \   0002AF                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   0002AF   EF           MOV       A,R7
   \   0002B0   F5..         MOV       ?V2,A
   \   0002B2   75..00       MOV       ?V3,#0x0
   \   0002B5   78..         MOV       R0,#?V2
   \   0002B7   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002BA   AC..         MOV       R4,?V14
   \   0002BC   AD..         MOV       R5,?V15
   \   0002BE   AA..         MOV       R2,?V4
   \   0002C0   AB..         MOV       R3,?V5
   \   0002C2   12....       LCALL     `??zclRevertWriteUndividedCmd::?relay`; Banked call to: zclRevertWriteUndividedCmd
   \   0002C5   7402         MOV       A,#0x2
   \   0002C7   12....       LCALL     ?DEALLOC_XSTACK8
   4847              } // for loop
   4848          
   4849              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002CA   EE           MOV       A,R6
   \   0002CB   85..82       MOV       DPL,?V0
   \   0002CE   85..83       MOV       DPH,?V1
   \   0002D1   F0           MOVX      @DPTR,A
   4850              if ( writeRspCmd->numAttr  == 0 )
   \   0002D2   700B         JNZ       ??zclProcessInWriteUndividedCmd_17
   4851              {
   4852                // Since all records were written successful, include a single status record
   4853                // in the resonse command with the status field set to SUCCESS and the
   4854                // attribute ID field omitted.
   4855                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002D4   A3           INC       DPTR
   \   0002D5   E4           CLR       A
   \   0002D6   F0           MOVX      @DPTR,A
   4856                writeRspCmd->numAttr = 1;
   \   0002D7   85..82       MOV       DPL,?V0
   \   0002DA   85..83       MOV       DPH,?V1
   \   0002DD   04           INC       A
   \   0002DE   F0           MOVX      @DPTR,A
   4857              }
   4858          
   4859              zcl_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   0002DF                ; Setup parameters for call to function osal_mem_free
   \   0002DF   AA..         MOV       R2,?V14
   \   0002E1   AB..         MOV       R3,?V15
   \   0002E3   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4860            }
   4861          
   4862            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4863                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4864                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002E6   12....       LCALL     ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_402:
   \   0002E9                ; Setup parameters for call to function zcl_SendWriteRsp
   \   0002E9   85..82       MOV       DPL,?V4
   \   0002EC   85..83       MOV       DPH,?V5
   \   0002EF   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   0002F2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002F5   75..01       MOV       ?V2,#0x1
   \   0002F8   78..         MOV       R0,#?V2
   \   0002FA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002FD   85..82       MOV       DPL,?V4
   \   000300   85..83       MOV       DPH,?V5
   \   000303   A3           INC       DPTR
   \   000304   A3           INC       DPTR
   \   000305   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000308   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00030B   78..         MOV       R0,#?V0
   \   00030D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000310   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000313   12....       LCALL     ?DEALLOC_XSTACK8
   4865            zcl_mem_free( writeRspCmd );
   \   000316                ; Setup parameters for call to function osal_mem_free
   \   000316   AA..         MOV       R2,?V0
   \   000318   AB..         MOV       R3,?V1
   \   00031A   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4866          
   4867            return TRUE;
   \   00031D   7901         MOV       R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00031F   740C         MOV       A,#0xc
   \   000321   02....       LJMP      ?Subroutine5 & 0xFFFF
   4868          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   2401         ADD       A,#0x1
   \   000002   F0           MOVX      @DPTR,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3400         ADDC      A,#0x0
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   E8           MOV       A,R0
   \   000001   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_465:
   \   000004   39           ADDC      A,R1
   \   000005   F583         MOV       DPH,A
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   85..82       MOV       DPL,?V4
   \   000003   85..83       MOV       DPH,?V5
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F5..         MOV       ?V6,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   F5..         MOV       ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7404         MOV       A,#0x4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL     ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   EF           MOV       A,R7
   \   000006   C3           CLR       C
   \   000007   98           SUBB      A,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   FA           MOV       R2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   8A82         MOV       DPL,R2
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   8582..       MOV       ?V2,DPL
   \   00000E   8583..       MOV       ?V3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine196_0
   \   000006                ; // Fall through to label ??Subroutine196_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V2
   \   000004   85..83       MOV       DPH,?V3
   \   000007   E0           MOVX      A,@DPTR
   \   000008   22           RET
   4869          #endif // ZCL_WRITE
   4870          
   4871          #ifdef ZCL_DISCOVER
   4872          /*********************************************************************
   4873           * @fn      zclProcessInDiscAttrs
   4874           *
   4875           * @brief   Process the "Profile" Discover Attributes Commands
   4876           *
   4877           * @param   pInMsg - incoming message to process
   4878           *
   4879           * @return  TRUE if command processed. FALSE, otherwise.
   4880           */
   4881          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4882          {
   4883            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4884            zclAttrRec_t attrRec;
   4885            uint16 attrID;
   4886            uint8 numAttrs;
   4887            uint8 i;
   4888          
   4889            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4890          
   4891            // Find out the number of attributes supported within the specified range
   4892            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4893            {
   4894              // finds the next attribute on this endpoint/cluster after the range.
   4895              // attributes must be in numerical order in the list.
   4896              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4897              {
   4898                break;
   4899              }
   4900            }
   4901          
   4902            numAttrs = i;  // store range of attributes in buffer
   4903          
   4904              // Process message for either attributes or extended attributes
   4905            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4906            {
   4907              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4908            }
   4909            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4910            {
   4911              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4912            }
   4913          
   4914            return TRUE;
   4915          }
   4916          
   4917          /*********************************************************************
   4918           * @fn      zclProcessInDiscAttrsCmd
   4919           *
   4920           * @brief   Process the Discover Attributes Command
   4921           *
   4922           * @param   pInMsg - incoming message to process
   4923           *
   4924           * @param   pDiscoverCmd - structure from requesting command
   4925           *
   4926           * @param   attrLenBuf - describes the amount of attributes to be processed
   4927           *
   4928           * @return  none
   4929           */
   4930          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4931          {
   4932            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4933            uint8 discComplete = TRUE;
   4934            zclAttrRec_t attrRec;
   4935            uint16 attrID;
   4936            uint8 i;
   4937          
   4938            // Allocate space for the response command
   4939            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4940                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4941            if ( pDiscoverRsp == NULL )
   4942            {
   4943              return; // EMBEDDED RETURN
   4944            }
   4945          
   4946            if ( numAttrs != 0 )
   4947            {
   4948              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4949              {
   4950                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4951                {
   4952                  break; // should not happen, as numAttrs already calculated
   4953                }
   4954          
   4955                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4956                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4957              }
   4958          
   4959              // Are there more attributes to be discovered?
   4960              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4961              {
   4962                discComplete = FALSE;
   4963              }
   4964            }
   4965          
   4966            pDiscoverRsp->discComplete = discComplete;
   4967            pDiscoverRsp->numAttr = numAttrs;
   4968          
   4969            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4970                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4971                                         true, pInMsg->hdr.transSeqNum );
   4972            zcl_mem_free( pDiscoverRsp );
   4973          
   4974            return;
   4975          }
   4976          
   4977          /*********************************************************************
   4978           * @fn      zclProcessInDiscAttrsExtCmd
   4979           *
   4980           * @brief   Process the Discover Attributes Extended Command
   4981           *
   4982           * @param   pInMsg - incoming message to process
   4983           *
   4984           * @param   pDiscoverCmd - structure from requesting command
   4985           *
   4986           * @param   attrLenBuf - describes the amount of attributes to be processed
   4987           *
   4988           * @return  none
   4989           */
   4990          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4991          {
   4992            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4993            uint8 discComplete = TRUE;
   4994            zclAttrRec_t attrRec;
   4995            uint16 attrID;
   4996            uint8 i;
   4997          
   4998              // Allocate space for the response command
   4999            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   5000                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   5001            if ( pDiscoverExtRsp == NULL )
   5002            {
   5003              return; // EMBEDDED RETURN
   5004            }
   5005          
   5006          
   5007            if ( numAttrs != 0 )
   5008            {
   5009              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   5010              {
   5011                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   5012                {
   5013                  break; // Should not happen, as numAttrs already calculated
   5014                }
   5015          
   5016                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   5017                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   5018                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   5019              }
   5020          
   5021              // Are there more attributes to be discovered?
   5022              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   5023              {
   5024                discComplete = FALSE;
   5025              }
   5026            }
   5027          
   5028            pDiscoverExtRsp->discComplete = discComplete;
   5029            pDiscoverExtRsp->numAttr = numAttrs;
   5030          
   5031            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5032                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   5033                                         true, pInMsg->hdr.transSeqNum );
   5034          
   5035            zcl_mem_free( pDiscoverExtRsp );
   5036          
   5037            return;
   5038          }
   5039          
   5040          /*********************************************************************
   5041           * @fn      zclProcessInDiscCmd
   5042           *
   5043           * @brief   Process the "Profile" Discover Command
   5044           *
   5045           * @param   pInMsg - incoming message to process
   5046           *
   5047           * @return  TRUE if command processed. FALSE, otherwise.
   5048           */
   5049          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   5050          {
   5051            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   5052            zclDiscoverCmdsCmdRsp_t cmdRsp;
   5053            ZStatus_t status;
   5054            zclCommandRec_t cmdRec;
   5055            uint8 cmdID;
   5056            uint8 i;
   5057            uint8 j;
   5058          
   5059            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   5060          
   5061            // Find out the number of commands supported within the specified range
   5062            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   5063            {
   5064              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   5065              {
   5066                break;  // Command not supported
   5067              }
   5068            }
   5069          
   5070            // Allocate space for the response command
   5071            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   5072          
   5073            if ( cmdRsp.pCmdID == NULL )
   5074            {
   5075              return FALSE; // EMBEDDED RETURN
   5076            }
   5077          
   5078            if ( i != 0 )
   5079            {
   5080              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   5081              {
   5082                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   5083                {
   5084                  break; // Attribute not supported
   5085                }
   5086          
   5087                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   5088              }
   5089            }
   5090          
   5091            // Are there more commands to be discovered?
   5092            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   5093            {
   5094              cmdRsp.discComplete = FALSE;
   5095            }
   5096            else
   5097            {
   5098              cmdRsp.discComplete = TRUE;
   5099            }
   5100          
   5101            // pass the command requested
   5102            cmdRsp.cmdType = pInMsg->hdr.commandID;
   5103          
   5104            // store number of commands returned
   5105            cmdRsp.numCmd = j;
   5106          
   5107            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5108                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   5109                                                true, pInMsg->hdr.transSeqNum );
   5110          
   5111            zcl_mem_free( cmdRsp.pCmdID );
   5112          
   5113            if ( status == ZSuccess )
   5114            {
   5115              return TRUE;
   5116            }
   5117            else
   5118            {
   5119              return FALSE;
   5120            }
   5121          }
   5122          
   5123          #endif // ZCL_DISCOVER
   5124          
   5125          /*********************************************************************
   5126           * @fn      zcl_registerConfigReportRecList
   5127           *
   5128           * @brief   Register an configReportRec List with ZCL Foundation
   5129           *
   5130           * @param   endpoint - endpoint the attribute list belongs to
   5131           *
   5132           * @param   numConfigReportRec - number of attributes in list
   5133           *
   5134           * @param   newConfigReportRecList - array of Attribute records
   5135           *
   5136           * @return  ZSuccess if OK
   5137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5138          ZStatus_t zcl_registerConfigReportRecList( uint8 endpoint, uint8 numConfigReportRec,
   \                     zcl_registerConfigReportRecList:
   5139                                                     zclConfigReportRec_t newConfigReportRecList[] )
   5140          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL     ?Subroutine101 & 0xFFFF
   5141            zclConfigReportRecsList *pNewItem;    // this pointer will hold config. report recs list to added
   5142            zclConfigReportRecsList *pLoop;       // this pointer is used to point to end of list
   5143            
   5144            // Allocate memory heap for config. report recs list variable
   5145            pNewItem = zcl_mem_alloc( sizeof( zclConfigReportRecsList ));
   5146            if ( pNewItem == NULL )       // when memory is full, it notice failure initialization
   \                     ??CrossCallReturnLabel_256:
   \   000008   7004         JNZ       ??zcl_registerConfigReportRecList_0
   5147            {
   5148              return (ZMemError);
   \   00000A   7910         MOV       R1,#0x10
   \   00000C   8022         SJMP      ??CrossCallReturnLabel_13
   5149            }
   5150            
   5151            // Assigns value to this pointer
   5152            pNewItem->next = (zclConfigReportRecsList *)NULL;
   \                     ??zcl_registerConfigReportRecList_0:
   \   00000E   12....       LCALL     ?Subroutine13 & 0xFFFF
   5153            pNewItem->endpoint = endpoint;
   5154            pNewItem->numConfigReportRec = numConfigReportRec;
   5155            pNewItem->configReportRecs = newConfigReportRecList;
   5156            
   5157            // If list is empty, this list will add the first item pNewItem
   5158            if ( configReportRecsList == NULL )
   \                     ??CrossCallReturnLabel_3:
   \   000011   90....       MOV       DPTR,#configReportRecsList
   \   000014   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000017   90....       MOV       DPTR,#configReportRecsList
   \   00001A   6011         JZ        ??zcl_registerConfigReportRecList_1
   5159            {
   5160              configReportRecsList = pNewItem;
   5161            }
   5162            else  // if this list have any item "config. report rec list" , it will find the lastest location and point to new item will be added
   5163            {
   5164              // Look for end of list
   5165              pLoop = configReportRecsList;
   \   00001C   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   00001F   8003         SJMP      ??zcl_registerConfigReportRecList_2
   5166              while ( pLoop->next != NULL )
   5167              {
   5168                pLoop = pLoop->next;
   \                     ??zcl_registerConfigReportRecList_3:
   \   000021   EA           MOV       A,R2
   \   000022   FC           MOV       R4,A
   \   000023   EB           MOV       A,R3
   5169              }
   \                     ??zcl_registerConfigReportRecList_2:
   \   000024   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   000027   70F8         JNZ       ??zcl_registerConfigReportRecList_3
   5170              
   5171              // Put new item at end of list
   5172              pLoop->next = pNewItem;
   \   000029   8C82         MOV       DPL,R4
   \   00002B   8D83         MOV       DPH,R5
   5173            }
   \                     ??zcl_registerConfigReportRecList_1:
   \   00002D   12....       LCALL     ?Subroutine19 & 0xFFFF
   5174            return (ZSuccess );
   \                     ??CrossCallReturnLabel_13:
   \   000030   02....       LJMP      ?Subroutine3 & 0xFFFF
   5175          }
   5176          
   5177          /*********************************************************************
   5178           * @fn      zclFindConfigReportRecsList
   5179           *
   5180           * @brief   Find the right configReport record list for an endpoint
   5181           *
   5182           * @param   endpoint - endpoint to look for
   5183           *
   5184           * @return  pointer to record list, NULL if not found
   5185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5186          zclConfigReportRecsList *zclFindConfigReportRecsList( uint8 endpoint )
   \                     zclFindConfigReportRecsList:
   5187          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   5188            zclConfigReportRecsList *pLoop = configReportRecsList;
   \   000004   90....       MOV       DPTR,#configReportRecsList
   \   000007   8004         SJMP      ??zclFindConfigReportRecsList_0
   5189            
   5190            while ( pLoop != NULL )
   5191            {
   5192              if ( pLoop->endpoint == endpoint )
   5193              {
   5194                return ( pLoop );
   5195              }
   5196              pLoop = pLoop->next;
   \                     ??zclFindConfigReportRecsList_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \                     ??zclFindConfigReportRecsList_0:
   \   00000D   12....       LCALL     ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   000010   600C         JZ        ??zclFindConfigReportRecsList_2
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   69           XRL       A,R1
   \   00001A   70ED         JNZ       ??zclFindConfigReportRecsList_1
   \   00001C   8004         SJMP      ??zclFindConfigReportRecsList_3
   5197            }
   5198            
   5199            return( NULL );
   \                     ??zclFindConfigReportRecsList_2:
   \   00001E   7A00         MOV       R2,#0x0
   \   000020   7B00         MOV       R3,#0x0
   \                     ??zclFindConfigReportRecsList_3:
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   5200          }
   5201          
   5202          /*********************************************************************
   5203           * @fn      zclFindConfigReportRec
   5204           *
   5205           * @brief   Find the configReportRec record that matches the parameters
   5206           *
   5207           * @param   endpoint - Application's endpoint
   5208           *
   5209           * @param   clustID - cluster ID
   5210           *
   5211           * @param   attrID - attribute looking for
   5212           *
   5213           * @param   pConfigReportRec - ConfigReportRec record to be returned
   5214           *
   5215           * @return  TRUE if record found. FALSE, otherwise
   5216           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5217          uint8 zclFindConfigReportRec( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclFindConfigReportRec:
   5218                                        zclConfigReportRec_t **pConfigReportRec )
   5219          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   5220            uint8 x;
   5221            zclConfigReportRecsList *pRec = zclFindConfigReportRecsList ( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindConfigReportRecsList
   \   00000D   12....       LCALL     `??zclFindConfigReportRecsList::?relay`; Banked call to: zclFindConfigReportRecsList
   \   000010   8A..         MOV       ?V4,R2
   \   000012   8B..         MOV       ?V5,R3
   \   000014   AC..         MOV       R4,?V4
   \   000016   AD..         MOV       R5,?V5
   5222            
   5223            if ( pRec != NULL )
   \   000018   EA           MOV       A,R2
   \   000019   4D           ORL       A,R5
   \   00001A   605E         JZ        ??zclFindConfigReportRec_0
   5224            {
   5225              for (x = 0; x < pRec->numConfigReportRec; x++)
   \   00001C   7A00         MOV       R2,#0x0
   \   00001E   8001         SJMP      ??zclFindConfigReportRec_1
   \                     ??zclFindConfigReportRec_2:
   \   000020   0A           INC       R2
   \                     ??zclFindConfigReportRec_1:
   \   000021   8C82         MOV       DPL,R4
   \   000023   8B83         MOV       DPH,R3
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F8           MOV       R0,A
   \   00002A   EA           MOV       A,R2
   \   00002B   C3           CLR       C
   \   00002C   98           SUBB      A,R0
   \   00002D   504B         JNC       ??zclFindConfigReportRec_0
   5226              {
   5227                if (pRec->configReportRecs[x].clusterId == clusterId &&
   5228                    pRec->configReportRecs[x].cfgReportRec.attrID == attrId )
   \   00002F   EA           MOV       A,R2
   \   000030   75F012       MOV       B,#0x12
   \   000033   A4           MUL       AB
   \   000034   F8           MOV       R0,A
   \   000035   A9F0         MOV       R1,B
   \   000037   8C82         MOV       DPL,R4
   \   000039   8B83         MOV       DPH,R3
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   12....       LCALL     ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000042   8882         MOV       DPL,R0
   \   000044   F583         MOV       DPH,A
   \   000046   E0           MOVX      A,@DPTR
   \   000047   65..         XRL       A,?V0
   \   000049   7004         JNZ       ??zclFindConfigReportRec_3
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   65..         XRL       A,?V1
   \                     ??zclFindConfigReportRec_3:
   \   00004F   70CF         JNZ       ??zclFindConfigReportRec_2
   \   000051   8882         MOV       DPL,R0
   \   000053   8983         MOV       DPH,R1
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   6E           XRL       A,R6
   \   00005E   7003         JNZ       ??zclFindConfigReportRec_4
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   6F           XRL       A,R7
   \                     ??zclFindConfigReportRec_4:
   \   000063   70BB         JNZ       ??zclFindConfigReportRec_2
   5229                {
   5230                  *pConfigReportRec = &(pRec->configReportRecs[x]);
   \   000065   740E         MOV       A,#0xe
   \   000067   12....       LCALL     ?XSTACK_DISP0_8
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   FA           MOV       R2,A
   \   00006C   A3           INC       DPTR
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   F583         MOV       DPH,A
   \   000070   8A82         MOV       DPL,R2
   \   000072   E8           MOV       A,R0
   \   000073   12....       LCALL     ??Subroutine198_0 & 0xFFFF
   5231                  return (TRUE);
   \                     ??CrossCallReturnLabel_506:
   \   000076   7901         MOV       R1,#0x1
   \   000078   8002         SJMP      ??zclFindConfigReportRec_5
   5232                }
   5233              }
   5234            }
   5235            return (FALSE);
   \                     ??zclFindConfigReportRec_0:
   \   00007A   7900         MOV       R1,#0x0
   \                     ??zclFindConfigReportRec_5:
   \   00007C   02....       LJMP      ?Subroutine4 & 0xFFFF
   5236          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_radius>`:
   \   000000   1E           DB 30

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_32:
   \   000000   32000000     DD 50

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsgExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsgExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_addExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_addExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_HandleExternal::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getRawAFMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getParsedTransSeqNum::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerPlugin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerAttrList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerClusterOptionList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerValidateAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_DeviceOperational::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendCommand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendConfigReportRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadReportCfgRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ProcessMessageMSG::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclBuildHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAuthorizeCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSetSecurityOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSerializeData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAnalogDataType::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetDataTypeLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLengthUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAuthorizeWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInConfigReportCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadReportCfgCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclRevertWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerConfigReportRecList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerConfigReportRecList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindConfigReportRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindConfigReportRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindConfigReportRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindConfigReportRec
   5237          
   5238          
   5239          /*********************************************************************
   5240          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     26   zclAnalogDataType
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     39   zclBuildHdr
      2     54   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     16   zclFindAttrRecsList
      0     19   zclFindClusterOption
      0     16   zclFindConfigReportRec
        0     14   -> zclFindConfigReportRecsList
      2     14   zclFindConfigReportRecsList
      0     45   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     58   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     42   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     46   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     26   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     48   zclParseHdr
        0     12   -> osal_memset
      1     24   zclParseInConfigReportCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_memset
        0     24   -> zclAnalogDataType
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetDataTypeLength
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     37   zclProcessInReadCmd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     32   -> zclGetAuthorizeCB
        0     37   -> zcl_SendReadRsp
      1     39   zclProcessInWriteCmd
        0     34   -> bdb_ZclIdentifyCmdInd
        0     34   -> osal_mem_alloc
        0     34   -> osal_mem_free
        0     37   -> osal_memcpy
        0     36   -> zclFindAttrRec
        0     36   -> zclWriteAttrData
        0     36   -> zclWriteAttrDataUsingCB
        0     39   -> zcl_SendWriteRsp
      1     41   zclProcessInWriteUndividedCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     36   -> zclGetAttrDataLength
        0     36   -> zclGetAttrDataLengthUsingCB
        0     38   -> zclReadAttrData
        0     40   -> zclReadAttrDataUsingCB
        0     38   -> zclRevertWriteUndividedCmd
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      0     56   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     60   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     69   zclRevertWriteUndividedCmd
        0     31   -> osal_memcpy
        0     30   -> zclFindAttrRec
        0     28   -> zclGetAttrDataLength
        0     30   -> zclWriteAttrDataUsingCB
      1     45   zclSerializeData
        0     19   -> osal_buffer_uint32
        0     18   -> osal_memcpy
      0     46   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     56   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     56   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      0     61   zcl_DeviceOperational
        0     23   -> zclFindAttrRec
        0     23   -> zclReadAttrData
      1     12   zcl_HandleExternal
        0     12   -> osal_msg_allocate
        0     12   -> osal_msg_send
        0     12   -> zcl_getExternalFoundationHandler
      2      0   zcl_Init
      1    135   zcl_ProcessMessageMSG
        0     36   -> afFindEndPointDesc
        0     36   -> osal_mem_free
        0     36   -> zclGetClusterOption
        0     36   -> zclParseHdr
        0     36   -> zclSetSecurityOption
        0     38   -> zcl_DeviceOperational
        0     43   -> zcl_SendDefaultRspCmd
      0     32   zcl_ReadAttrData
        0     26   -> zclFindAttrRec
        0     26   -> zclReadAttrData
        0     28   -> zclReadAttrDataUsingCB
      1    142   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     66   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     42   zcl_SendReadReportCfgRspCmd
        0     26   -> osal_mem_alloc
        0     26   -> osal_mem_free
        0     26   -> zclAnalogDataType
        0     26   -> zclGetDataTypeLength
        0     26   -> zclSerializeData
        0     37   -> zcl_SendCommand
      1     72   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     38   zcl_SendReportCmd
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     39   zcl_SendWriteRequest
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     72   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     19   zcl_addExternalFoundationHandler
        0     10   -> osal_mem_alloc
        0     10   -> osal_mem_free
      0    103   zcl_event_loop
        0     92   -> bdb_getZCLFrameCounter
        0     92   -> gp_GetHeadNotificationMsg
        0     92   -> gp_GetPHeadNotification
        0     92   -> gp_NotificationMsgClean
        0     94   -> gp_getProxyTableByGpId
        0     95   -> osal_memcpy
        0     92   -> osal_msg_deallocate
        0     92   -> osal_msg_receive
        0     92   -> osal_msg_send
        0     95   -> osal_revmemcpy
        0     96   -> osal_start_timerEx
        0     92   -> zcl_ProcessMessageMSG
        0    103   -> zcl_SendCommand
        0     92   -> zcl_getExternalFoundationHandler
      2     92   zcl_getExternalFoundationHandler
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerConfigReportRecList
        0     12   -> osal_mem_alloc
      0      9   zcl_registerForMsg
        0      9   -> zcl_addExternalFoundationHandler
      0      9   zcl_registerForMsgExt
        0      9   -> zcl_addExternalFoundationHandler
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_radius>
       6  ??Subroutine153_0
      16  ??Subroutine154_0
       6  ??Subroutine155_0
       3  ??Subroutine156_0
       6  ??Subroutine157_0
       5  ??Subroutine158_0
       8  ??Subroutine159_0
       6  ??Subroutine160_0
       7  ??Subroutine161_0
       6  ??Subroutine162_0
       6  ??Subroutine163_0
       5  ??Subroutine164_0
       7  ??Subroutine165_0
      12  ??Subroutine166_0
       6  ??Subroutine167_0
      10  ??Subroutine168_0
       6  ??Subroutine169_0
       5  ??Subroutine170_0
       5  ??Subroutine171_0
       6  ??Subroutine172_0
       5  ??Subroutine173_0
       1  ??Subroutine174_0
       6  ??Subroutine175_0
       6  ??Subroutine176_0
       6  ??Subroutine177_0
       1  ??Subroutine178_0
       3  ??Subroutine179_0
       4  ??Subroutine180_0
       7  ??Subroutine181_0
       5  ??Subroutine182_0
       6  ??Subroutine183_0
       1  ??Subroutine184_0
      10  ??Subroutine185_0
       4  ??Subroutine186_0
       2  ??Subroutine187_0
       4  ??Subroutine188_0
       7  ??Subroutine189_0
       6  ??Subroutine190_0
       8  ??Subroutine191_0
       4  ??Subroutine192_0
       8  ??Subroutine193_0
       9  ??Subroutine194_0
       5  ??Subroutine195_0
      22  ??Subroutine196_0
       6  ??Subroutine197_0
       5  ??Subroutine198_0
       7  ?Subroutine0
       3  ?Subroutine1
       7  ?Subroutine10
      12  ?Subroutine100
      10  ?Subroutine101
       4  ?Subroutine102
      13  ?Subroutine103
      12  ?Subroutine104
      10  ?Subroutine105
       2  ?Subroutine106
      14  ?Subroutine107
      11  ?Subroutine108
      12  ?Subroutine109
       5  ?Subroutine11
       1  ?Subroutine110
      21  ?Subroutine111
      10  ?Subroutine112
       8  ?Subroutine113
       8  ?Subroutine114
       1  ?Subroutine115
      11  ?Subroutine116
      15  ?Subroutine117
      12  ?Subroutine118
       9  ?Subroutine119
      79  ?Subroutine12
      15  ?Subroutine120
       8  ?Subroutine121
      11  ?Subroutine122
       6  ?Subroutine123
       4  ?Subroutine124
       9  ?Subroutine125
       9  ?Subroutine126
       5  ?Subroutine127
       3  ?Subroutine128
       3  ?Subroutine129
      24  ?Subroutine13
       8  ?Subroutine130
       5  ?Subroutine131
       4  ?Subroutine132
       8  ?Subroutine133
      13  ?Subroutine134
      11  ?Subroutine135
       1  ?Subroutine136
       6  ?Subroutine137
       5  ?Subroutine138
       9  ?Subroutine139
      20  ?Subroutine14
       2  ?Subroutine140
       2  ?Subroutine141
       8  ?Subroutine142
      12  ?Subroutine143
      12  ?Subroutine144
      14  ?Subroutine145
       6  ?Subroutine146
       2  ?Subroutine147
       5  ?Subroutine148
       6  ?Subroutine149
      20  ?Subroutine15
       5  ?Subroutine150
       5  ?Subroutine151
       6  ?Subroutine152
      14  ?Subroutine16
       1  ?Subroutine17
       4  ?Subroutine18
       8  ?Subroutine19
       5  ?Subroutine2
       6  ?Subroutine20
       7  ?Subroutine21
       9  ?Subroutine22
       4  ?Subroutine23
       4  ?Subroutine24
       6  ?Subroutine25
       4  ?Subroutine26
       7  ?Subroutine27
       5  ?Subroutine28
      12  ?Subroutine29
       5  ?Subroutine3
       7  ?Subroutine30
       4  ?Subroutine31
       8  ?Subroutine32
       6  ?Subroutine33
       9  ?Subroutine34
       6  ?Subroutine35
       4  ?Subroutine36
       5  ?Subroutine37
      52  ?Subroutine38
      28  ?Subroutine39
       5  ?Subroutine4
      10  ?Subroutine40
       6  ?Subroutine41
      18  ?Subroutine42
       1  ?Subroutine43
       4  ?Subroutine44
       9  ?Subroutine45
      13  ?Subroutine46
       9  ?Subroutine47
      10  ?Subroutine48
       6  ?Subroutine49
       8  ?Subroutine5
       6  ?Subroutine50
      10  ?Subroutine51
      18  ?Subroutine52
      17  ?Subroutine53
       6  ?Subroutine54
       4  ?Subroutine55
       6  ?Subroutine56
      14  ?Subroutine57
       8  ?Subroutine58
      24  ?Subroutine59
       2  ?Subroutine6
       9  ?Subroutine60
       1  ?Subroutine61
       5  ?Subroutine62
       1  ?Subroutine63
       4  ?Subroutine64
       8  ?Subroutine65
      10  ?Subroutine66
       2  ?Subroutine67
      12  ?Subroutine68
      11  ?Subroutine69
       5  ?Subroutine7
      14  ?Subroutine70
      11  ?Subroutine71
       8  ?Subroutine72
       9  ?Subroutine73
       4  ?Subroutine74
      11  ?Subroutine75
      10  ?Subroutine76
      12  ?Subroutine77
       8  ?Subroutine78
      15  ?Subroutine79
       5  ?Subroutine8
       6  ?Subroutine80
       6  ?Subroutine81
       5  ?Subroutine82
      10  ?Subroutine83
       8  ?Subroutine84
       7  ?Subroutine85
      16  ?Subroutine86
       6  ?Subroutine87
       8  ?Subroutine88
      11  ?Subroutine89
       3  ?Subroutine9
       6  ?Subroutine90
       4  ?Subroutine91
       9  ?Subroutine92
       4  ?Subroutine93
       8  ?Subroutine94
       5  ?Subroutine95
       4  ?Subroutine96
      12  ?Subroutine97
       8  ?Subroutine98
      10  ?Subroutine99
       4  __Constant_32
       2  attrList
       2  clusterOptionList
       2  configReportRecsList
       2  externalEndPointHandlerList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
       6  zclAnalogDataType::?relay
      49  zclAuthorizeWrite
       6  zclAuthorizeWrite::?relay
      91  zclBuildHdr
       6  zclBuildHdr::?relay
      92  zclCmdTable
     148  zclFindAttrRec
       6  zclFindAttrRec::?relay
      37  zclFindAttrRecsList
       6  zclFindAttrRecsList::?relay
     102  zclFindClusterOption
       6  zclFindClusterOption::?relay
     127  zclFindConfigReportRec
       6  zclFindConfigReportRec::?relay
      37  zclFindConfigReportRecsList
       6  zclFindConfigReportRecsList::?relay
      63  zclGetAttrDataLength
       6  zclGetAttrDataLength::?relay
     100  zclGetAttrDataLengthUsingCB
       6  zclGetAttrDataLengthUsingCB::?relay
      19  zclGetAuthorizeCB
       6  zclGetAuthorizeCB::?relay
      29  zclGetClusterOption
       6  zclGetClusterOption::?relay
     166  zclGetDataTypeLength
       6  zclGetDataTypeLength::?relay
      21  zclGetReadWriteCB
       6  zclGetReadWriteCB::?relay
     219  zclParseHdr
       6  zclParseHdr::?relay
     554  zclParseInConfigReportCmd
       6  zclParseInConfigReportCmd::?relay
      27  zclParseInDefaultRspCmd
       6  zclParseInDefaultRspCmd::?relay
      99  zclParseInReadCmd
       6  zclParseInReadCmd::?relay
     105  zclParseInReadReportCfgCmd
       6  zclParseInReadReportCfgCmd::?relay
     327  zclParseInReadRspCmd
       6  zclParseInReadRspCmd::?relay
     320  zclParseInWriteCmd
       6  zclParseInWriteCmd::?relay
     108  zclParseInWriteRspCmd
       6  zclParseInWriteRspCmd::?relay
     441  zclProcessInReadCmd
       6  zclProcessInReadCmd::?relay
     549  zclProcessInWriteCmd
       6  zclProcessInWriteCmd::?relay
     804  zclProcessInWriteUndividedCmd
       6  zclProcessInWriteUndividedCmd::?relay
     100  zclReadAttrData
       6  zclReadAttrData::?relay
      92  zclReadAttrDataUsingCB
       6  zclReadAttrDataUsingCB::?relay
     247  zclRevertWriteUndividedCmd
       6  zclRevertWriteUndividedCmd::?relay
     378  zclSerializeData
       6  zclSerializeData::?relay
      42  zclSetSecurityOption
       6  zclSetSecurityOption::?relay
     141  zclWriteAttrData
       6  zclWriteAttrData::?relay
     105  zclWriteAttrDataUsingCB
       6  zclWriteAttrDataUsingCB::?relay
     118  zcl_DeviceOperational
       6  zcl_DeviceOperational::?relay
     180  zcl_HandleExternal
       6  zcl_HandleExternal::?relay
       1  zcl_InSeqNum
      12  zcl_Init
       6  zcl_Init::?relay
    1076  zcl_ProcessMessageMSG
       6  zcl_ProcessMessageMSG::?relay
     129  zcl_ReadAttrData
       6  zcl_ReadAttrData::?relay
     407  zcl_SendCommand
       6  zcl_SendCommand::?relay
     247  zcl_SendConfigReportRspCmd
       6  zcl_SendConfigReportRspCmd::?relay
     134  zcl_SendDefaultRspCmd
       6  zcl_SendDefaultRspCmd::?relay
     175  zcl_SendRead
       6  zcl_SendRead::?relay
     505  zcl_SendReadReportCfgRspCmd
       6  zcl_SendReadReportCfgRspCmd::?relay
     405  zcl_SendReadRsp
       6  zcl_SendReadRsp::?relay
     185  zcl_SendReportCmd
       6  zcl_SendReportCmd::?relay
     188  zcl_SendWriteRequest
       6  zcl_SendWriteRequest::?relay
     217  zcl_SendWriteRsp
       6  zcl_SendWriteRsp::?relay
       1  zcl_TaskID
       2  zcl_ValidateAttrDataCB
     128  zcl_addExternalFoundationHandler
       6  zcl_addExternalFoundationHandler::?relay
     566  zcl_event_loop
       6  zcl_event_loop::?relay
      60  zcl_getExternalFoundationHandler
       6  zcl_getExternalFoundationHandler::?relay
      12  zcl_getParsedTransSeqNum
       6  zcl_getParsedTransSeqNum::?relay
      13  zcl_getRawAFMsg
       6  zcl_getRawAFMsg::?relay
       1  zcl_radius
      85  zcl_registerAttrList
       6  zcl_registerAttrList::?relay
      51  zcl_registerClusterOptionList
       6  zcl_registerClusterOptionList::?relay
      51  zcl_registerConfigReportRecList
       6  zcl_registerConfigReportRecList::?relay
      10  zcl_registerForMsg
       6  zcl_registerForMsg::?relay
       8  zcl_registerForMsgExt
       6  zcl_registerForMsgExt::?relay
      96  zcl_registerPlugin
       6  zcl_registerPlugin::?relay
      54  zcl_registerReadWriteCB
       6  zcl_registerReadWriteCB::?relay
      12  zcl_registerValidateAttrData
       6  zcl_registerValidateAttrData::?relay

 
 12 456 bytes in segment BANKED_CODE
    354 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
      4 bytes in segment XDATA_ROM_C
     17 bytes in segment XDATA_Z
 
    447 bytes of CODE     memory
      0 bytes of CONST    memory (+ 4 bytes shared)
 12 456 bytes of HUGECODE memory
     18 bytes of XDATA    memory

Errors: none
Warnings: none
